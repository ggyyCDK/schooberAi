"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("@babel/parser");
var traverse_1 = require("@babel/traverse");
var postcss = require("postcss");
var utils_1 = require("./utils");
// const log = debug('jsx2css:compile.ts');
exports.default = (function (code) {
    var root = postcss.root();
    var filterTags = [
        'defs',
        'path',
        'g',
        'image',
        'ellipse',
        'circle',
        'rect',
        'path',
        'mask',
        'use',
    ];
    // parse
    var ast = parser_1.parse(code, {
        allowImportExportEverywhere: true,
        plugins: ['jsx', 'typescript', 'classProperties'],
    });
    // log('compile time: ');
    var childrenVisitor = {
        JSXElement: {
            enter: function (path, state) {
                var node = path.node;
                var parentRule = state.parentRule;
                var className = utils_1.getClassName(node.openingElement);
                if (filterTags.find(function (tag) { return tag === className; })) {
                    path.skip();
                    return;
                }
                var rule = utils_1.getRule(parentRule, className);
                if (rule && className) {
                    // condition className
                    parentRule.append(rule);
                    state.parentRule = rule;
                }
            },
            exit: function (path, state) {
                var node = path.node;
                var exitRule = state.parentRule;
                var exitClassName = utils_1.getClassName(node.openingElement);
                // avoid ul > li * 2, duplicate parentRecursive
                var noRepeat = exitRule.nodes.every(function (node) { return node.selector !== exitClassName; });
                if (exitRule && exitRule.parent && exitClassName && noRepeat) {
                    state.parentRule = exitRule.parent;
                }
            },
        },
    };
    var visitor = {
        JSXElement: {
            enter: function (path) {
                // children skip
                var node = path.node;
                var className = utils_1.getClassName(node.openingElement);
                if (className) {
                    // condition className
                    var rule = utils_1.getRule(root, className);
                    root.append(rule);
                    if ('children' in node && node.children.length) {
                        path.traverse(childrenVisitor, { parentRule: rule });
                        // handle by childrenVisitor
                        path.skip();
                    }
                }
            },
        },
    };
    traverse_1.default(ast, visitor);
    // log('compile time: ');
    return root;
});
//# sourceMappingURL=compile.js.map