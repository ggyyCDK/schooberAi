#! /usr/bin/env node
import { DepsService, create, checkPkgJson, checkAndInstallCoreDeps, interactivePrompt, init, logger, FileService } from './chunk-Q7EUFCXR.js';
export { create } from './chunk-Q7EUFCXR.js';
import { PosthogAnalytics, setAnalytics } from './chunk-OQQFOUQW.js';
export { PosthogAnalytics } from './chunk-OQQFOUQW.js';
import { __glob } from './chunk-QKQ47GQZ.js';
import { Command } from 'commander';
import color from 'picocolors';
import * as p2 from '@clack/prompts';
import fs, { readFileSync } from 'fs';
import path, { join, dirname } from 'path';
import { getServerOptions, FileService as FileService$2, getBundlerOptions, getWatcherInputOptions, writeTelemetryConfig, createWatcher } from '@mastra/deployer/build';
import { Bundler } from '@mastra/deployer/bundler';
import { getDeployer, FileService as FileService$1 } from '@mastra/deployer';
import { config } from 'dotenv';
import stripJsonComments from 'strip-json-comments';
import process2 from 'process';
import { isWebContainer } from '@webcontainer/env';
import { execa } from 'execa';
import getPort from 'get-port';
import { writeFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import * as fsExtra from 'fs-extra';
import { spawn } from 'child_process';

// src/utils/string.ts
var toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
};

// src/commands/scorers/available-scorers.ts
var AVAILABLE_SCORERS = [
  // Accuracy and Reliability scorers
  {
    id: "answer-relevancy",
    name: "Answer Relevancy",
    description: "Evaluates how well responses address the input query using LLM",
    category: "accuracy-and-reliability",
    filename: "answer-relevancy-scorer.ts"
  },
  {
    id: "faithfulness",
    name: "Faithfulness",
    description: "Measures how accurately responses represent provided context",
    category: "accuracy-and-reliability",
    filename: "faithfulness-scorer.ts"
  },
  {
    id: "hallucination",
    name: "Hallucination Detection",
    description: "Detects facts or claims not present in provided context",
    category: "accuracy-and-reliability",
    filename: "hallucination-scorer.ts"
  },
  {
    id: "completeness",
    name: "Completeness",
    description: "Checks if responses include all necessary information",
    category: "accuracy-and-reliability",
    filename: "completeness-scorer.ts"
  },
  {
    id: "content-similarity",
    name: "Content Similarity",
    description: "Evaluates consistency of information across different phrasings",
    category: "accuracy-and-reliability",
    filename: "content-similarity-scorer.ts"
  },
  {
    id: "textual-difference",
    name: "Textual Difference",
    description: "Measures textual differences between strings",
    category: "accuracy-and-reliability",
    filename: "textual-difference-scorer.ts"
  },
  // Output Quality scorers
  {
    id: "tone-consistency",
    name: "Tone Consistency",
    description: "Measures consistency in formality, complexity, and style",
    category: "output-quality",
    filename: "tone-consistency-scorer.ts"
  },
  {
    id: "toxicity-detection",
    name: "Toxicity Detection",
    description: "Detects harmful or inappropriate content in responses",
    category: "output-quality",
    filename: "toxicity-detection-scorer.ts"
  },
  {
    id: "bias-detection",
    name: "Bias Detection",
    description: "Detects potential biases in output",
    category: "output-quality",
    filename: "bias-detection-scorer.ts"
  },
  {
    id: "keyword-coverage",
    name: "Keyword Coverage",
    description: "Assesses how well output covers important keywords from input",
    category: "output-quality",
    filename: "keyword-coverage-scorer.ts"
  }
];
var DEFAULT_SCORERS_DIR = "src/mastra/scorers";
function writeScorer(filename, content, customPath) {
  const rootDir = process.cwd();
  const scorersPath = customPath || DEFAULT_SCORERS_DIR;
  const fullPath = path.join(rootDir, scorersPath);
  if (!fs.existsSync(fullPath)) {
    try {
      fs.mkdirSync(fullPath, { recursive: true });
      p2.log.success(`Created scorers directory at ${scorersPath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create directory: ${errorMessage}`);
    }
  }
  const filePath = path.join(fullPath, filename);
  if (fs.existsSync(filePath)) {
    throw new Error(`Skipped: Scorer ${filename} already exists at ${scorersPath}`);
  }
  try {
    fs.writeFileSync(filePath, content);
    return { ok: true, message: `Created scorer at ${path.relative(rootDir, filePath)}` };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to write scorer: ${errorMessage}`);
  }
}

// import("../../templates/scorers/**/*") in src/commands/scorers/add-new-scorer.ts
var globImport_templates_scorers = __glob({
  "../../templates/scorers/answer-relevancy-scorer.ts": () => import('./answer-relevancy-scorer-CTIL35GQ.js'),
  "../../templates/scorers/bias-detection-scorer.ts": () => import('./bias-detection-scorer-IWHTLHDC.js'),
  "../../templates/scorers/completeness-scorer.ts": () => import('./completeness-scorer-KH4LU4BW.js'),
  "../../templates/scorers/content-similarity-scorer.ts": () => import('./content-similarity-scorer-NB76ISB5.js'),
  "../../templates/scorers/faithfulness-scorer.ts": () => import('./faithfulness-scorer-F6GLSRTV.js'),
  "../../templates/scorers/hallucination-scorer.ts": () => import('./hallucination-scorer-NJW7PTKD.js'),
  "../../templates/scorers/keyword-coverage-scorer.ts": () => import('./keyword-coverage-scorer-63AEWDTL.js'),
  "../../templates/scorers/textual-difference-scorer.ts": () => import('./textual-difference-scorer-2MUWQ22U.js'),
  "../../templates/scorers/tone-consistency-scorer.ts": () => import('./tone-consistency-scorer-ZEXVRFCP.js'),
  "../../templates/scorers/toxicity-detection-scorer.ts": () => import('./toxicity-detection-scorer-RMTLQCHI.js')
});

// src/commands/scorers/add-new-scorer.ts
async function selectScorer() {
  const options = [];
  for (const scorer of AVAILABLE_SCORERS) {
    options.push({
      value: scorer.id,
      label: `${scorer.name}`,
      hint: `${scorer.description}`
    });
  }
  const selectedIds = await p2.multiselect({
    message: "Choose a scorer to add:",
    options
  });
  if (p2.isCancel(selectedIds) || typeof selectedIds !== "object") {
    p2.log.info("Scorer selection cancelled.");
    return null;
  }
  if (!Array.isArray(selectedIds)) {
    return null;
  }
  const selectedScorers = selectedIds.map((scorerId) => {
    const foundScorer = AVAILABLE_SCORERS.find((s) => s.id === scorerId);
    return foundScorer;
  }).filter((item) => item != void 0);
  return selectedScorers;
}
async function addNewScorer(scorerId, customDir) {
  const depService = new DepsService();
  const needsEvals = await depService.checkDependencies(["@mastra/evals"]) !== `ok`;
  if (needsEvals) {
    await depService.installPackages(["@mastra/evals"]);
  }
  if (!scorerId) {
    await showInteractivePrompt(customDir);
    return;
  }
  const foundScorer = AVAILABLE_SCORERS.find((scorer) => scorer.id === scorerId.toLowerCase());
  if (!foundScorer) {
    p2.log.error(`Scorer for ${scorerId} not available`);
    return;
  }
  const { id, filename } = foundScorer;
  try {
    const res = await initializeScorer(id, filename, customDir);
    if (!res.ok) {
      return;
    }
    p2.log.success(res.message);
    showSuccessNote();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("Skipped")) {
      return p2.log.warning(errorMessage);
    }
    p2.log.error(errorMessage);
  }
}
async function initializeScorer(scorerId, filename, customPath) {
  try {
    const templateModule = await globImport_templates_scorers(`../../templates/scorers/${filename}`);
    const key = `${toCamelCase(scorerId)}Scorer`;
    const templateContent = templateModule[key];
    const res = writeScorer(filename, templateContent, customPath);
    return res;
  } catch (error) {
    throw error;
  }
}
function showSuccessNote() {
  p2.note(`
        ${color.green("To use: Add the Scorer to your workflow or agent!")}
        `);
}
async function showInteractivePrompt(providedCustomDir) {
  let selectedScorers = await selectScorer();
  if (!selectedScorers) {
    return;
  }
  let customPath = providedCustomDir;
  if (!providedCustomDir) {
    const useCustomDir = await p2.confirm({
      message: `Would you like to use a custom directory?${color.gray("(Default: src/mastra/scorers)")}`,
      initialValue: false
    });
    if (p2.isCancel(useCustomDir)) {
      p2.log.info("Operation cancelled.");
      return;
    }
    if (useCustomDir) {
      const dirPath = await p2.text({
        message: "Enter the directory path (relative to project root):",
        placeholder: "src/scorers"
      });
      if (p2.isCancel(dirPath)) {
        p2.log.info("Operation cancelled.");
        return;
      }
      customPath = dirPath;
    }
  }
  const result = await Promise.allSettled(
    selectedScorers.map((scorer) => {
      const { id, filename } = scorer;
      return initializeScorer(id, filename, customPath);
    })
  );
  result.forEach((op) => {
    if (op.status === "fulfilled") {
      p2.log.success(op.value.message);
      return;
    }
    const errorMessage = String(op.reason);
    const coreError = errorMessage.replace("Error:", "").trim();
    if (coreError.includes("Skipped")) {
      return p2.log.warning(coreError);
    }
    p2.log.error(coreError);
  });
  const containsSuccessfulWrites = result.some((item) => item.status === "fulfilled");
  if (containsSuccessfulWrites) {
    showSuccessNote();
  }
  return;
}

// src/commands/actions/add-scorer.ts
var origin = process.env.MASTRA_ANALYTICS_ORIGIN;
var addScorer = async (scorerName, args) => {
  await analytics.trackCommandExecution({
    command: "scorers-add",
    args: { ...args, scorerName },
    execution: async () => {
      await addNewScorer(scorerName, args.dir);
    },
    origin
  });
};
var BuildBundler = class extends Bundler {
  customEnvFile;
  constructor(customEnvFile) {
    super("Build");
    this.customEnvFile = customEnvFile;
  }
  getEnvFiles() {
    const possibleFiles = [".env.production", ".env.local", ".env"];
    if (this.customEnvFile) {
      possibleFiles.unshift(this.customEnvFile);
    }
    try {
      const fileService = new FileService$2();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch (err) {
    }
    return Promise.resolve([]);
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
  }
  async bundle(entryFile, outputDirectory, toolsPaths) {
    return this._bundle(this.getEntry(), entryFile, outputDirectory, toolsPaths);
  }
  getEntry() {
    return `
    // @ts-ignore
    import { evaluate } from '@mastra/core/eval';
    import { AvailableHooks, registerHook } from '@mastra/core/hooks';
    import { TABLE_EVALS } from '@mastra/core/storage';
    import { checkEvalStorageFields } from '@mastra/core/utils';
    import { mastra } from '#mastra';
    import { createNodeServer, getToolExports } from '#server';
    import { tools } from '#tools';
    // @ts-ignore
    await createNodeServer(mastra, { tools: getToolExports(tools) });

    registerHook(AvailableHooks.ON_GENERATION, ({ input, output, metric, runId, agentName, instructions }) => {
      evaluate({
        agentName,
        input,
        metric,
        output,
        runId,
        globalRunId: runId,
        instructions,
      });
    });

    if (mastra.getStorage()) {
      // start storage init in the background
      mastra.getStorage().init();
    }

    registerHook(AvailableHooks.ON_EVALUATION, async traceObject => {
      const storage = mastra.getStorage();
      if (storage) {
        // Check for required fields
        const logger = mastra?.getLogger();
        const areFieldsValid = checkEvalStorageFields(traceObject, logger);
        if (!areFieldsValid) return;

        await storage.insert({
          tableName: TABLE_EVALS,
          record: {
            input: traceObject.input,
            output: traceObject.output,
            result: JSON.stringify(traceObject.result || {}),
            agent_name: traceObject.agentName,
            metric_name: traceObject.metricName,
            instructions: traceObject.instructions,
            test_info: null,
            global_run_id: traceObject.globalRunId,
            run_id: traceObject.runId,
            created_at: new Date().toISOString(),
          },
        });
      }
    });
    `;
  }
  async lint(entryFile, outputDirectory, toolsPaths) {
    await super.lint(entryFile, outputDirectory, toolsPaths);
  }
};
async function build({
  dir: dir2,
  tools,
  root,
  env
}) {
  const rootDir = root || process.cwd();
  const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(rootDir, dir2) : join(rootDir, "src", "mastra");
  const outputDirectory = join(rootDir, ".mastra");
  const defaultToolsPath = join(mastraDir, "tools/**/*.{js,ts}");
  const defaultToolsIgnorePaths = [
    `!${join(mastraDir, "tools/**/*.{test,spec}.{js,ts}")}`,
    `!${join(mastraDir, "tools/**/__tests__/**")}`
  ];
  const defaultTools = [defaultToolsPath, ...defaultToolsIgnorePaths];
  const discoveredTools = [defaultTools, ...tools ?? []];
  try {
    const fs3 = new FileService();
    const mastraEntryFile = fs3.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
    const platformDeployer = await getDeployer(mastraEntryFile, outputDirectory);
    if (!platformDeployer) {
      const deployer = new BuildBundler(env);
      deployer.__setLogger(logger);
      await deployer.prepare(outputDirectory);
      await deployer.bundle(mastraEntryFile, outputDirectory, discoveredTools);
      logger.info(`Build successful, you can now deploy the .mastra/output directory to your target platform.`);
      logger.info(
        `To start the server, run: node --import=./.mastra/output/instrumentation.mjs .mastra/output/index.mjs`
      );
      return;
    }
    logger.info("Deployer found, preparing deployer build...");
    platformDeployer.__setLogger(logger);
    await platformDeployer.prepare(outputDirectory);
    await platformDeployer.bundle(mastraEntryFile, outputDirectory, discoveredTools);
    logger.info("You can now deploy the .mastra/output directory to your target platform.");
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Mastra Build failed`, { error });
    }
    process.exit(1);
  }
}

// src/commands/actions/build-project.ts
var buildProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "mastra build",
    args,
    execution: async () => {
      await build({
        dir: args?.dir,
        root: args?.root,
        tools: args?.tools ? args.tools.split(",") : [],
        env: args?.env
      });
    },
    origin: origin2
  });
};

// src/commands/actions/create-project.ts
var origin3 = process.env.MASTRA_ANALYTICS_ORIGIN;
var createProject = async (projectNameArg, args) => {
  const projectName = projectNameArg || args.projectName;
  await analytics.trackCommandExecution({
    command: "create",
    args: { ...args, projectName },
    execution: async () => {
      const timeout = args?.timeout ? args?.timeout === true ? 6e4 : parseInt(args?.timeout, 10) : void 0;
      if (args.default) {
        await create({
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: true,
          timeout,
          mcpServer: args.mcp,
          template: args.template
        });
        return;
      }
      await create({
        components: args.components ? args.components.split(",") : [],
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args["llm-api-key"],
        timeout,
        projectName,
        directory: args.dir,
        mcpServer: args.mcp,
        template: args.template
      });
    },
    origin: origin3
  });
};
async function deploy({ dir: dir2 }) {
  let mastraDir = dir2 || join(process.cwd(), "src/mastra");
  try {
    const outputDirectory = join(process.cwd(), ".mastra");
    const fs3 = new FileService();
    const mastraEntryFile = fs3.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
    const deployer = await getDeployer(mastraEntryFile, outputDirectory);
    if (!deployer) {
      logger.warn("No deployer found.");
      return;
    }
    try {
      await deployer.prepare(outputDirectory);
      await deployer.bundle(mastraEntryFile, outputDirectory, []);
      try {
        await deployer.deploy(outputDirectory);
      } catch (error) {
        console.error("[Mastra Deploy] - Error deploying:", error);
      }
    } catch (err) {
      if (err instanceof Error) {
        logger.debug(`error: ${err.message}`, { error: err });
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      logger.debug(`error: ${error.message}`, { error });
    }
    logger.warn("No deployer found.");
  }
}

// src/commands/actions/deploy-project.ts
var deployProject = async (args) => {
  config({ path: [".env", ".env.production"] });
  await analytics.trackCommandExecution({
    command: "mastra deploy",
    args,
    execution: async () => {
      logger.warn(`DEPRECATED: The deploy command is deprecated.
          Please use the mastra build command instead.
          Then deploy .mastra/output to your target platform.
          `);
      await deploy({ dir: args.dir });
    },
    origin: origin2
  });
};

// src/commands/actions/init-project.ts
var origin4 = process.env.MASTRA_ANALYTICS_ORIGIN;
var initProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "init",
    args,
    execution: async () => {
      await checkPkgJson();
      await checkAndInstallCoreDeps(args?.example || args?.default);
      if (!Object.keys(args).length) {
        const result = await interactivePrompt();
        await init({
          ...result,
          llmApiKey: result?.llmApiKey,
          components: ["agents", "tools", "workflows"],
          addExample: true
        });
        return;
      }
      if (args?.default) {
        await init({
          directory: "src/",
          components: ["agents", "tools", "workflows"],
          llmProvider: "openai",
          addExample: true,
          configureEditorWithDocsMCP: args.mcp
        });
        return;
      }
      const componentsArr = args.components ? args.components.split(",") : [];
      await init({
        directory: args.dir,
        components: componentsArr,
        llmProvider: args.llm,
        addExample: args.example,
        llmApiKey: args["llm-api-key"],
        configureEditorWithDocsMCP: args.mcp
      });
      return;
    },
    origin: origin4
  });
};

// src/commands/lint/rules/mastraCoreRule.ts
var mastraCoreRule = {
  name: "mastra-core",
  description: "Checks if @mastra/core is installed",
  async run(context) {
    const hasCore = context.mastraPackages.some((pkg) => pkg.name === "@mastra/core");
    if (!hasCore) {
      logger.error("@mastra/core is not installed. This package is required for Mastra to work properly.");
      return false;
    }
    return true;
  }
};
function readNextConfig(dir) {
  const nextConfigPath = join(dir, "next.config.js");
  try {
    const nextConfigContent = readFileSync(nextConfigPath, "utf-8");
    const configMatch = nextConfigContent.match(/const nextConfig = ({[\s\S]*?});/);
    if (!configMatch?.[1]) {
      return null;
    }
    const configStr = configMatch[1].replace(/\n/g, "").replace(/\s+/g, " ");
    return eval(`(${configStr})`);
  } catch {
    return null;
  }
}
function isNextJsProject(dir2) {
  const nextConfigPath2 = join(dir2, "next.config.js");
  try {
    readFileSync(nextConfigPath2, "utf-8");
    return true;
  } catch {
    return false;
  }
}
var nextConfigRule = {
  name: "next-config",
  description: "Checks if Next.js config is properly configured for Mastra packages",
  async run(context) {
    if (!isNextJsProject(context.rootDir)) {
      return true;
    }
    const nextConfig = readNextConfig(context.rootDir);
    if (!nextConfig) {
      return false;
    }
    const serverExternals = nextConfig.serverExternalPackages || [];
    const hasMastraExternals = serverExternals.some(
      (pkg) => pkg === "@mastra/*" || pkg === "@mastra/core" || pkg.startsWith("@mastra/")
    );
    if (!hasMastraExternals) {
      logger.error("next.config.js is missing Mastra packages in serverExternalPackages");
      logger.error("Please add the following to your next.config.js:");
      logger.error('  serverExternalPackages: ["@mastra/*"],');
      return false;
    }
    logger.info("Next.js config is properly configured for Mastra packages");
    return true;
  }
};
function readTsConfig(dir2) {
  const tsConfigPath = join(dir2, "tsconfig.json");
  try {
    const tsConfigContent = readFileSync(tsConfigPath, "utf-8");
    const cleanTsConfigContent = stripJsonComments(tsConfigContent);
    return JSON.parse(cleanTsConfigContent);
  } catch {
    return null;
  }
}
var tsConfigRule = {
  name: "ts-config",
  description: "Checks if TypeScript config is properly configured for Mastra packages",
  async run(context) {
    const tsConfig = readTsConfig(context.rootDir);
    if (!tsConfig) {
      logger.warn("No tsconfig.json found. This might cause issues with Mastra packages.");
      return true;
    }
    const { module, moduleResolution } = tsConfig.compilerOptions || {};
    const isValidConfig = moduleResolution === "bundler" || module === "CommonJS";
    if (!isValidConfig) {
      logger.error("tsconfig.json has invalid configuration");
      logger.error("Please set either:");
      logger.error('  "compilerOptions": {');
      logger.error('    "moduleResolution": "bundler"');
      logger.error("  }");
      logger.error("or");
      logger.error('  "compilerOptions": {');
      logger.error('    "module": "CommonJS"');
      logger.error("  }");
      logger.error("For the recommended TypeScript configuration, see:");
      logger.error("https://mastra.ai/en/docs/getting-started/installation#initialize-typescript");
      return false;
    }
    logger.info("TypeScript config is properly configured for Mastra packages");
    return true;
  }
};

// src/commands/lint/rules/index.ts
var rules = [nextConfigRule, tsConfigRule, mastraCoreRule];

// src/commands/lint/index.ts
function readPackageJson(dir2) {
  const packageJsonPath = join(dir2, "package.json");
  try {
    const packageJsonContent = readFileSync(packageJsonPath, "utf-8");
    return JSON.parse(packageJsonContent);
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Failed to read package.json: ${error.message}`);
    }
    throw error;
  }
}
function getMastraPackages(packageJson) {
  const allDependencies = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
  const mastraPackages = Object.entries(allDependencies).filter(
    ([name]) => name.startsWith("@mastra/") || name === "mastra"
  );
  return mastraPackages.map(([name, version2]) => ({
    name,
    version: version2,
    isAlpha: version2.includes("alpha")
  }));
}
async function lint({ dir: dir2, root, tools }) {
  try {
    const rootDir = root || process.cwd();
    const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(process.cwd(), dir2) : join(process.cwd(), "src", "mastra");
    const outputDirectory = join(rootDir, ".mastra");
    const defaultToolsPath = join(mastraDir, "tools");
    const discoveredTools = [defaultToolsPath, ...tools ?? []];
    const packageJson = readPackageJson(rootDir);
    const mastraPackages = getMastraPackages(packageJson);
    const context = {
      rootDir,
      mastraDir,
      outputDirectory,
      discoveredTools,
      packageJson,
      mastraPackages
    };
    const results = await Promise.all(rules.map((rule) => rule.run(context)));
    const allRulesPassed = results.every((result) => result);
    if (allRulesPassed) {
      const fileService = new FileService();
      const mastraEntryFile = fileService.getFirstExistingFile([
        join(mastraDir, "index.ts"),
        join(mastraDir, "index.js")
      ]);
      const platformDeployer = await getDeployer(mastraEntryFile, outputDirectory);
      if (!platformDeployer) {
        const deployer = new BuildBundler();
        await deployer.lint(mastraEntryFile, outputDirectory, discoveredTools);
      } else {
        await platformDeployer.lint(mastraEntryFile, outputDirectory, discoveredTools);
      }
    }
    return allRulesPassed;
  } catch (error) {
    if (error instanceof Error) {
      logger.error(`Lint check failed: ${error.message}`);
    }
    return false;
  }
}

// src/commands/actions/lint-project.ts
var lintProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "lint",
    args,
    execution: async () => {
      await lint({ dir: args.dir, root: args.root, tools: args.tools ? args.tools.split(",") : [] });
    },
    origin: origin2
  });
};
function listAllScorers() {
  p2.intro(color.inverse(" Available Scorers "));
  const groupedScorers = AVAILABLE_SCORERS.reduce(
    (acc, scorer) => {
      if (!acc[scorer.category]) {
        acc[scorer.category] = [];
      }
      acc[scorer.category].push(scorer);
      return acc;
    },
    {}
  );
  for (const [category, scorers] of Object.entries(groupedScorers)) {
    const categoryLabel = category === "accuracy-and-reliability" ? "Accuracy and Reliability" : "Output Quality";
    p2.log.info(`${color.bold(color.cyan(categoryLabel))} Scorers:`);
    for (const scorer of scorers) {
      p2.log.message(`  ${color.bold(scorer.name)} ${color.dim(`(${scorer.id})`)}
    ${color.dim(scorer.description)}
    `);
    }
  }
}

// src/commands/actions/list-scorers.ts
var origin5 = process.env.MASTRA_ANALYTICS_ORIGIN;
var listScorers = async (args) => {
  await analytics.trackCommandExecution({
    command: "scorers-list",
    args,
    execution: async () => {
      await listAllScorers();
    },
    origin: origin5
  });
};
var DevBundler = class extends Bundler {
  customEnvFile;
  constructor(customEnvFile) {
    super("Dev");
    this.customEnvFile = customEnvFile;
  }
  getEnvFiles() {
    const possibleFiles = [".env.development", ".env.local", ".env"];
    if (this.customEnvFile) {
      possibleFiles.unshift(this.customEnvFile);
    }
    try {
      const fileService = new FileService$1();
      const envFile = fileService.getFirstExistingFile(possibleFiles);
      return Promise.resolve([envFile]);
    } catch {
    }
    return Promise.resolve([]);
  }
  async prepare(outputDirectory) {
    await super.prepare(outputDirectory);
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const playgroundServePath = join(outputDirectory, this.outputDir, "playground");
    await fsExtra.copy(join(dirname(__dirname), "src/playground/dist"), playgroundServePath, {
      overwrite: true
    });
  }
  async watch(entryFile, outputDirectory, toolsPaths) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const envFiles = await this.getEnvFiles();
    let sourcemapEnabled = false;
    let transpilePackages = [];
    try {
      const bundlerOptions = await getBundlerOptions(entryFile, outputDirectory);
      sourcemapEnabled = !!bundlerOptions?.sourcemap;
      transpilePackages = bundlerOptions?.transpilePackages ?? [];
    } catch (error) {
      this.logger.debug("Failed to get bundler options, sourcemap will be disabled", { error });
    }
    const inputOptions = await getWatcherInputOptions(
      entryFile,
      "node",
      {
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development")
      },
      { sourcemap: sourcemapEnabled, transpilePackages }
    );
    const toolsInputOptions = await this.getToolsInputOptions(toolsPaths);
    const outputDir = join(outputDirectory, this.outputDir);
    await writeTelemetryConfig(entryFile, outputDir, this.logger);
    const mastraFolder = dirname(entryFile);
    const fileService = new FileService$1();
    const customInstrumentation = fileService.getFirstExistingFileOrUndefined([
      join(mastraFolder, "instrumentation.js"),
      join(mastraFolder, "instrumentation.ts"),
      join(mastraFolder, "instrumentation.mjs")
    ]);
    await this.writeInstrumentationFile(outputDir, customInstrumentation);
    await this.writePackageJson(outputDir, /* @__PURE__ */ new Map(), {});
    const copyPublic = this.copyPublic.bind(this);
    const watcher = await createWatcher(
      {
        ...inputOptions,
        logLevel: inputOptions.logLevel === "silent" ? "warn" : inputOptions.logLevel,
        onwarn: (warning) => {
          if (warning.code === "CIRCULAR_DEPENDENCY") {
            if (warning.ids?.[0]?.includes("node_modules")) {
              return;
            }
            this.logger.warn(`Circular dependency found:
	${warning.message.replace("Circular dependency: ", "")}`);
          }
        },
        plugins: [
          // @ts-ignore - types are good
          // eslint-disable-next-line @typescript-eslint/no-misused-promises
          ...inputOptions.plugins,
          {
            name: "env-watcher",
            buildStart() {
              for (const envFile of envFiles) {
                this.addWatchFile(envFile);
              }
            }
          },
          {
            name: "public-dir-watcher",
            buildStart() {
              this.addWatchFile(join(dirname(entryFile), "public"));
            },
            buildEnd() {
              return copyPublic(dirname(entryFile), outputDirectory);
            }
          },
          {
            name: "tools-watcher",
            async buildEnd() {
              const toolImports = [];
              const toolsExports = [];
              Array.from(Object.keys(toolsInputOptions || {})).filter((key) => key.startsWith("tools/")).forEach((key, index) => {
                const toolExport = `tool${index}`;
                toolImports.push(`import * as ${toolExport} from './${key}.mjs';`);
                toolsExports.push(toolExport);
              });
              await writeFile(
                join(outputDir, "tools.mjs"),
                `${toolImports.join("\n")}
        
                export const tools = [${toolsExports.join(", ")}]`
              );
            }
          }
        ],
        input: {
          index: join(__dirname, "templates", "dev.entry.js"),
          ...toolsInputOptions
        }
      },
      {
        dir: outputDir,
        sourcemap: sourcemapEnabled
      }
    );
    this.logger.info("Starting watcher...");
    return new Promise((resolve, reject) => {
      const cb = (event) => {
        if (event.code === "BUNDLE_END") {
          this.logger.info("Bundling finished, starting server...");
          watcher.off("event", cb);
          resolve(watcher);
        }
        if (event.code === "ERROR") {
          console.log(event);
          this.logger.error("Bundling failed, stopping watcher...");
          watcher.off("event", cb);
          reject(event);
        }
      };
      watcher.on("event", cb);
    });
  }
  async bundle() {
  }
};

// src/commands/dev/dev.ts
var currentServerProcess;
var isRestarting = false;
var ON_ERROR_MAX_RESTARTS = 3;
var startServer = async (dotMastraPath, port, env, startOptions = {}, errorRestartCount = 0) => {
  let serverIsReady = false;
  try {
    logger.info("[Mastra Dev] - Starting server...");
    const commands = [];
    if (startOptions.inspect) {
      commands.push("--inspect");
    }
    if (startOptions.inspectBrk) {
      commands.push("--inspect-brk");
    }
    if (startOptions.customArgs) {
      commands.push(...startOptions.customArgs);
    }
    if (!isWebContainer()) {
      const instrumentation = import.meta.resolve("@opentelemetry/instrumentation/hook.mjs");
      commands.push(
        `--import=${import.meta.resolve("mastra/telemetry-loader")}`,
        "--import=./instrumentation.mjs",
        `--import=${instrumentation}`
      );
    }
    commands.push("index.mjs");
    currentServerProcess = execa(process2.execPath, commands, {
      cwd: dotMastraPath,
      env: {
        NODE_ENV: "production",
        ...Object.fromEntries(env),
        MASTRA_DEV: "true",
        PORT: port.toString(),
        MASTRA_DEFAULT_STORAGE_URL: `file:${join(dotMastraPath, "..", "mastra.db")}`
      },
      stdio: ["inherit", "inherit", "inherit", "ipc"],
      reject: false
    });
    if (currentServerProcess?.exitCode && currentServerProcess?.exitCode !== 0) {
      if (!currentServerProcess) {
        throw new Error(`Server failed to start`);
      }
      throw new Error(
        `Server failed to start with error: ${currentServerProcess.stderr || currentServerProcess.stdout}`
      );
    }
    currentServerProcess.on("message", async (message) => {
      if (message?.type === "server-ready") {
        serverIsReady = true;
        try {
          await fetch(`http://localhost:${port}/__refresh`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            }
          });
        } catch {
          await new Promise((resolve) => setTimeout(resolve, 1500));
          try {
            await fetch(`http://localhost:${port}/__refresh`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              }
            });
          } catch {
          }
        }
      }
    });
  } catch (err) {
    const execaError = err;
    if (execaError.stderr) logger.error("Server error output:", { stderr: execaError.stderr });
    if (execaError.stdout) logger.debug("Server output:", { stdout: execaError.stdout });
    if (!serverIsReady) {
      throw err;
    }
    setTimeout(() => {
      if (!isRestarting) {
        errorRestartCount++;
        if (errorRestartCount > ON_ERROR_MAX_RESTARTS) {
          logger.error(`Server failed to start after ${ON_ERROR_MAX_RESTARTS} error attempts. Giving up.`);
          process2.exit(1);
        }
        logger.error(
          `Attempting to restart server after error... (Attempt ${errorRestartCount}/${ON_ERROR_MAX_RESTARTS})`
        );
        startServer(dotMastraPath, port, env, startOptions, errorRestartCount);
      }
    }, 1e3);
  }
};
async function rebundleAndRestart(dotMastraPath, port, bundler, startOptions = {}) {
  if (isRestarting) {
    return;
  }
  isRestarting = true;
  try {
    if (currentServerProcess) {
      logger.debug("Stopping current server...");
      currentServerProcess.kill("SIGINT");
    }
    const env = await bundler.loadEnvVars();
    await startServer(join(dotMastraPath, "output"), port, env, startOptions);
  } finally {
    isRestarting = false;
  }
}
async function dev({
  port,
  dir: dir2,
  root,
  tools,
  env,
  inspect,
  inspectBrk,
  customArgs
}) {
  const rootDir = root || process2.cwd();
  const mastraDir = dir2 ? dir2.startsWith("/") ? dir2 : join(process2.cwd(), dir2) : join(process2.cwd(), "src", "mastra");
  const dotMastraPath = join(rootDir, ".mastra");
  const defaultToolsPath = join(mastraDir, "tools/**/*.{js,ts}");
  const defaultToolsIgnorePaths = [
    `!${join(mastraDir, "tools/**/*.{test,spec}.{js,ts}")}`,
    `!${join(mastraDir, "tools/**/__tests__/**")}`
  ];
  const defaultTools = [defaultToolsPath, ...defaultToolsIgnorePaths];
  const discoveredTools = [defaultTools, ...tools ?? []];
  const startOptions = { inspect, inspectBrk, customArgs };
  const fileService = new FileService$1();
  const entryFile = fileService.getFirstExistingFile([join(mastraDir, "index.ts"), join(mastraDir, "index.js")]);
  const bundler = new DevBundler(env);
  bundler.__setLogger(logger);
  const serverOptions = await getServerOptions(entryFile, join(dotMastraPath, "output"));
  let portToUse = port ?? serverOptions?.port ?? process2.env.PORT;
  if (!portToUse || isNaN(Number(portToUse))) {
    const portList = Array.from({ length: 21 }, (_, i) => 4111 + i);
    portToUse = String(
      await getPort({
        port: portList
      })
    );
  }
  await bundler.prepare(dotMastraPath);
  const watcher = await bundler.watch(entryFile, dotMastraPath, discoveredTools);
  const loadedEnv = await bundler.loadEnvVars();
  for (const [key, value] of loadedEnv.entries()) {
    process2.env[key] = value;
  }
  await startServer(join(dotMastraPath, "output"), Number(portToUse), loadedEnv, startOptions);
  watcher.on("event", (event) => {
    if (event.code === "BUNDLE_END") {
      logger.info("[Mastra Dev] - Bundling finished, restarting server...");
      rebundleAndRestart(dotMastraPath, Number(portToUse), bundler, startOptions);
    }
  });
  process2.on("SIGINT", () => {
    logger.info("[Mastra Dev] - Stopping server...");
    if (currentServerProcess) {
      currentServerProcess.kill();
    }
    watcher.close().catch(() => {
    }).finally(() => {
      process2.exit(0);
    });
  });
}

// src/commands/actions/start-dev-server.ts
var startDevServer = async (args) => {
  analytics.trackCommand({
    command: "dev",
    origin: origin2
  });
  if (args?.port) {
    logger.warn("The --port option is deprecated. Use the server key in the Mastra instance instead.");
  }
  dev({
    port: args?.port ? parseInt(args.port) : null,
    dir: args?.dir,
    root: args?.root,
    tools: args?.tools ? args.tools.split(",") : [],
    env: args?.env,
    inspect: args?.inspect && !args?.inspectBrk,
    inspectBrk: args?.inspectBrk,
    customArgs: args?.customArgs ? args.customArgs.split(",") : []
  }).catch((err) => {
    logger.error(err.message);
  });
};
async function start(options = {}) {
  const outputDir = options.dir || ".mastra/output";
  const telemetry = options.telemetry ?? true;
  try {
    const outputPath = join(process.cwd(), outputDir);
    if (!fs.existsSync(outputPath)) {
      throw new Error(`Output directory ${outputPath} does not exist`);
    }
    const commands = [];
    if (telemetry && !isWebContainer()) {
      const instrumentation = "@opentelemetry/instrumentation/hook.mjs";
      commands.push("--import=./instrumentation.mjs", `--import=${instrumentation}`);
    }
    commands.push("index.mjs");
    const server = spawn("node", commands, {
      cwd: outputPath,
      stdio: "inherit",
      env: {
        ...process.env,
        NODE_ENV: "production"
      }
    });
    server.on("error", (err) => {
      logger.error(`Failed to start server: ${err.message}`);
      process.exit(1);
    });
    process.on("SIGINT", () => {
      server.kill("SIGINT");
      process.exit(0);
    });
    process.on("SIGTERM", () => {
      server.kill("SIGTERM");
      process.exit(0);
    });
  } catch (error) {
    logger.error(`Failed to start Mastra server: ${error.message}`);
    process.exit(1);
  }
}

// src/commands/actions/start-project.ts
var startProject = async (args) => {
  await analytics.trackCommandExecution({
    command: "start",
    args,
    execution: async () => {
      await start({
        dir: args.dir,
        telemetry: !args.noTelemetry
      });
    },
    origin: origin2
  });
};

// src/index.ts
var depsService = new DepsService();
var version = await depsService.getPackageVersion();
var analytics = new PosthogAnalytics({
  apiKey: "phc_SBLpZVAB6jmHOct9CABq3PF0Yn5FU3G2FgT4xUr2XrT",
  host: "https://us.posthog.com",
  version
});
setAnalytics(analytics);
var program = new Command();
var origin2 = process.env.MASTRA_ANALYTICS_ORIGIN;
program.name("mastra").version(`${version}`, "-v, --version").addHelpText(
  "before",
  `
${color.bold(color.cyan("Mastra"))} is a typescript framework for building AI applications, agents, and workflows.
`
).action(() => {
  program.help();
});
program.command("create [project-name]").description("Create a new Mastra project").option("--default", "Quick start with defaults(src, OpenAI, examples)").option("-c, --components <components>", "Comma-separated list of components (agents, tools, workflows)").option("-l, --llm <model-provider>", "Default model provider (openai, anthropic, groq, google, or cerebras))").option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").option("-n, --no-example", "Do not include example code").option("-t, --timeout [timeout]", "Configurable timeout for package installation, defaults to 60000 ms").option("-d, --dir <directory>", "Target directory for Mastra source code (default: src/)").option(
  "-p, --project-name <string>",
  "Project name that will be used in package.json and as the project directory name."
).option("-m, --mcp <editor>", "MCP Server for code editor (cursor, cursor-global, windsurf, vscode)").option(
  "--template [template-name]",
  "Create project from a template (use template name, public GitHub URL, or leave blank to select from list)"
).action(createProject);
program.command("init").description("Initialize Mastra in your project").option("--default", "Quick start with defaults(src, OpenAI, examples)").option("-d, --dir <directory>", "Directory for Mastra files to (defaults to src/)").option("-c, --components <components>", "Comma-separated list of components (agents, tools, workflows)").option("-l, --llm <model-provider>", "Default model provider (openai, anthropic, groq, google or cerebras))").option("-k, --llm-api-key <api-key>", "API key for the model provider").option("-e, --example", "Include example code").option("-n, --no-example", "Do not include example code").option("-m, --mcp <editor>", "MCP Server for code editor (cursor, cursor-global, windsurf, vscode)").action(initProject);
program.command("lint").description("Lint your Mastra project").option("-d, --dir <path>", "Path to your Mastra folder").option("-r, --root <path>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").action(lintProject);
program.command("dev").description("Start mastra server").option("-d, --dir <dir>", "Path to your mastra folder").option("-r, --root <root>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").option("-p, --port <port>", "deprecated: Port number for the development server (defaults to 4111)").option("-e, --env <env>", "Custom env file to include in the dev server").option("-i, --inspect", "Start the dev server in inspect mode").option("-b, --inspect-brk", "Start the dev server in inspect mode and break at the beginning of the script").option(
  "-c, --custom-args <args>",
  "Comma-separated list of custom arguments to pass to the dev server. IE: --experimental-transform-types"
).action(startDevServer);
program.command("build").description("Build your Mastra project").option("-d, --dir <path>", "Path to your Mastra Folder").option("-r, --root <path>", "Path to your root folder").option("-t, --tools <toolsDirs>", "Comma-separated list of paths to tool files to include").option("-e, --env <env>", "Custom env file to include in the build").action(buildProject);
program.command("deploy").description("Deploy your Mastra project").option("-d, --dir <path>", "Path to directory").action(deployProject);
program.command("start").description("Start your built Mastra application").option("-d, --dir <path>", "Path to your built Mastra output directory (default: .mastra/output)").option("-nt, --no-telemetry", "Disable telemetry on start").action(startProject);
var scorersCommand = program.command("scorers").description("Manage scorers for evaluating AI outputs");
scorersCommand.command("add [scorer-name]").description("Add a new scorer to your project").option("-d, --dir <path>", "Path to your Mastra directory (default: auto-detect)").action(addScorer);
scorersCommand.command("list").description("List available scorer templates").action(listScorers);
program.parse(process.argv);

export { analytics, origin2 as origin };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map