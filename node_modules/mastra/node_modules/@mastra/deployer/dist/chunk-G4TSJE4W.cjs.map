{"version":3,"sources":["../src/build/isNodeBuiltin.ts","../src/build/plugins/hono-alias.ts","../src/validator/validate.ts","../src/build/babel/remove-all-options-except.ts","../src/build/babel/remove-all-options-bundler.ts","../src/build/babel/remove-non-referenced-nodes.ts","../src/build/plugins/remove-unused-references.ts","../src/build/shared/extract-mastra-option.ts","../src/build/bundlerOptions.ts","../src/build/babel/check-config-export.ts","../src/build/analyze.ts"],"names":["builtinModules","fileURLToPath","nodeSpawn","dirname","babel","path","babel3","rollup","tsConfigPaths","esbuild","optimizeLodashImports","commonjs","json","babel4","result","virtual","removeDeployer","resolveFrom","packageDirectory","options","nodeResolve","o","join","writeFile","readFile","babel6","existsSync"],"mappings":"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","file":"chunk-G4TSJE4W.cjs","sourcesContent":["import { builtinModules } from 'node:module';\n\nexport function isNodeBuiltin(dep: string): boolean {\n  const [pkg] = dep.split('/');\n\n  return dep.startsWith('node:') || builtinModules.includes(dep) || builtinModules.includes(pkg!);\n}\n","import { fileURLToPath } from 'node:url';\nimport type { Plugin } from 'rollup';\n\n// hono is imported from deployer, so we need to resolve from here instead of the project root\nexport function aliasHono(): Plugin {\n  return {\n    name: 'hono-alias',\n    resolveId(id: string) {\n      if (!id.startsWith('@hono/') && !id.startsWith('hono/') && id !== 'hono' && id !== 'hono-openapi') {\n        return;\n      }\n\n      const path = import.meta.resolve(id);\n      return fileURLToPath(path);\n    },\n  } satisfies Plugin;\n}\n","import { spawn as nodeSpawn } from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport { dirname } from 'node:path';\n\n/**\n * Promisified version of Node.js spawn function\n *\n * @param command - The command to run\n * @param args - List of string arguments\n * @param options - Spawn options\n * @returns Promise that resolves with the exit code when the process completes\n */\nfunction spawn(command: string, args: string[] = [], options: SpawnOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const childProcess = nodeSpawn(command, args, {\n      // stdio: 'inherit',\n      ...options,\n    });\n\n    childProcess.on('error', error => {\n      reject(error);\n    });\n\n    let stderr = '';\n    childProcess.stderr?.on('data', message => {\n      stderr += message;\n    });\n\n    childProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(stderr));\n      }\n    });\n  });\n}\n\nexport function validate(file: string) {\n  return spawn(\n    'node',\n    [\n      '--import',\n      import.meta.resolve('@mastra/deployer/loader'),\n      '--input-type=module',\n      '-e',\n      `import('file://${file.replaceAll('\\\\', '/')}')`,\n    ],\n    {\n      cwd: dirname(file),\n    },\n  );\n}\n","import babel from '@babel/core';\nimport type { NodePath, types } from '@babel/core';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function removeAllOptionsFromMastraExcept(\n  result: { hasCustomConfig: boolean },\n  option: keyof MastraConfig,\n  logger?: IMastraLogger,\n) {\n  const t = babel.types;\n\n  return {\n    name: 'remove-all-except-' + option + '-config',\n    visitor: {\n      ExportNamedDeclaration: {\n        // remove all exports\n        exit(path) {\n          path.remove();\n        },\n      },\n\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        let mastraArgs = t.objectExpression([]);\n        if (t.isObjectExpression(path.node.arguments[0])) {\n          mastraArgs = path.node.arguments[0];\n        }\n\n        let telemetry = mastraArgs.properties.find(\n          // @ts-ignore\n          prop => prop.key.name === option,\n        );\n        let telemetryValue: types.Expression = t.objectExpression([]);\n\n        const programPath = path.scope.getProgramParent().path as NodePath<types.Program> | undefined;\n        if (!programPath) {\n          return;\n        }\n\n        if (telemetry && t.isObjectProperty(telemetry) && t.isExpression(telemetry.value)) {\n          result.hasCustomConfig = true;\n          telemetryValue = telemetry.value;\n\n          if (t.isIdentifier(telemetry.value) && telemetry.value.name === option) {\n            const telemetryBinding = state.file.scope.getBinding(option)!;\n\n            if (telemetryBinding && t.isVariableDeclarator(telemetryBinding.path.node)) {\n              const id = path.scope.generateUidIdentifier(option);\n\n              telemetryBinding.path.replaceWith(t.variableDeclarator(id, telemetryBinding.path.node.init!));\n              telemetryValue = id;\n            }\n          }\n        }\n\n        // add the deployer export\n        const exportDeclaration = t.exportNamedDeclaration(\n          t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), telemetryValue)]),\n          [],\n        );\n\n        programPath.node.body.push(exportDeclaration);\n      },\n\n      Program: {\n        exit(path) {\n          // Add a fallback export if no mastra configuration was found\n          const hasExport = path.node.body.some(\n            node => node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration',\n          );\n\n          if (!hasExport) {\n            if (logger) {\n              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:\nexport const mastra = new Mastra({\n  ${option}: <value>\n})\n\n`);\n            }\n\n            const fallbackExportDeclaration = t.exportNamedDeclaration(\n              t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),\n              [],\n            );\n            path.node.body.push(fallbackExportDeclaration);\n          }\n        },\n      },\n    },\n  } as babel.PluginObj;\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport { removeAllOptionsFromMastraExcept } from './remove-all-options-except';\n\nexport function removeAllOptionsExceptBundler(result: { hasCustomConfig: boolean }, logger?: IMastraLogger) {\n  return removeAllOptionsFromMastraExcept(result, 'bundler', logger);\n}\n","import babel from '@babel/core';\n\nexport function removeNonReferencedNodes() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-non-referenced-nodes',\n    visitor: {\n      Program(path) {\n        // Get the scope information\n        const scope = path.scope;\n\n        // Filter body to keep only referenced nodes\n        const currentBody = path.get('body');\n        const filteredBody = currentBody.filter(childPath => {\n          if (childPath.isExportDeclaration()) {\n            return true;\n          }\n\n          // For variable declarations, check if any declared variables are referenced\n          if (childPath.isVariableDeclaration()) {\n            return childPath.node.declarations.some(decl => {\n              if (!t.isIdentifier(decl.id)) {\n                return false;\n              }\n\n              const name = decl.id.name;\n              const binding = scope.getBinding(name);\n              // Keep if it has references or is exported\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // For function/class declarations, check if they're referenced\n          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {\n            if (!t.isIdentifier(childPath.node.id)) {\n              return false;\n            }\n\n            const name = childPath.node.id.name;\n            const binding = scope.getBinding(name);\n            return binding && (binding.referenced || binding.referencePaths.length > 0);\n          }\n\n          // For imports, check if any imported items are referenced\n          if (childPath.isImportDeclaration()) {\n            return childPath.node.specifiers.some(specifier => {\n              const importedName = specifier.local.name;\n              const binding = scope.getBinding(importedName);\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // Default to keeping other node types\n          return false;\n        });\n\n        // Replace the program body with filtered nodes\n        path.set(\n          'body',\n          filteredBody.map(p => p.node),\n        );\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport { removeNonReferencedNodes } from '../babel/remove-non-referenced-nodes';\n\nexport function recursiveRemoveNonReferencedNodes(code: string) {\n  return new Promise<{ code: string; map: any }>(async (resolve, reject) => {\n    babel.transform(\n      code,\n      {\n        babelrc: false,\n        configFile: false,\n        plugins: [removeNonReferencedNodes()],\n      },\n      (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n\n        // keep looping until the code is not changed\n        if (result && result.code! !== code) {\n          return recursiveRemoveNonReferencedNodes(result!.code!).then(resolve, reject);\n        }\n\n        resolve({\n          code: result!.code!,\n          map: result!.map!,\n        });\n      },\n    );\n  });\n}\n","import * as babel from '@babel/core';\nimport { rollup, type RollupOutput } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport commonjs from '@rollup/plugin-commonjs';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport { recursiveRemoveNonReferencedNodes } from '../plugins/remove-unused-references';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport { removeAllOptionsFromMastraExcept } from '../babel/remove-all-options-except';\nimport json from '@rollup/plugin-json';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\ntype Transformer = (\n  result: { hasCustomConfig: boolean },\n  logger?: IMastraLogger,\n) => ReturnType<typeof removeAllOptionsFromMastraExcept>;\n\nexport function extractMastraOptionBundler(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  result: {\n    hasCustomConfig: false;\n  },\n  logger?: IMastraLogger,\n) {\n  return rollup({\n    logLevel: 'silent',\n    input: {\n      [`${name}-config`]: entryFile,\n    },\n    treeshake: 'smallest',\n    plugins: [\n      tsConfigPaths(),\n      // transpile typescript to something we understand\n      esbuild(),\n      optimizeLodashImports(),\n      commonjs({\n        extensions: ['.js', '.ts'],\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      json(),\n      {\n        name: `extract-${name}-config`,\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return new Promise((resolve, reject) => {\n            babel.transform(\n              code,\n              {\n                babelrc: false,\n                configFile: false,\n                filename: id,\n                plugins: [transformer(result, logger)],\n              },\n              (err, result) => {\n                if (err) {\n                  return reject(err);\n                }\n\n                resolve({\n                  code: result!.code!,\n                  map: result!.map!,\n                });\n              },\n            );\n          });\n        },\n      },\n      // let esbuild remove all unused imports\n      esbuild(),\n      {\n        name: 'cleanup',\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return recursiveRemoveNonReferencedNodes(code);\n        },\n      },\n      // let esbuild remove it once more\n      esbuild(),\n    ],\n  });\n}\n\nexport async function extractMastraOption<T>(\n  name: string,\n  entryFile: string,\n  transformer: Transformer,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<{\n  bundleOutput: RollupOutput;\n  getConfig: () => Promise<T>;\n} | null> {\n  const result = {\n    hasCustomConfig: false,\n  } as const;\n  const bundler = await extractMastraOptionBundler(name, entryFile, transformer, result, logger);\n\n  const output = await bundler.write({\n    dir: outputDir,\n    format: 'es',\n    entryFileNames: '[name].mjs',\n  });\n\n  if (result.hasCustomConfig) {\n    const configPath = `${outputDir}/${name}-config.mjs`;\n\n    return {\n      bundleOutput: output,\n      getConfig: () => import(`file:${configPath}`).then(m => m[name] as T),\n    };\n  }\n\n  return null;\n}\n","import { removeAllOptionsExceptBundler } from './babel/remove-all-options-bundler';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function getBundlerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('bundler', entryFile, removeAllOptionsExceptBundler, result);\n}\n\nexport async function getBundlerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['bundler'] | null> {\n  const result = await extractMastraOption<Config['bundler']>(\n    'bundler',\n    entryFile,\n    removeAllOptionsExceptBundler,\n    outputDir,\n    logger,\n  );\n\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n","import type { PluginObj } from '@babel/core';\nimport babel from '@babel/core';\n\nexport function checkConfigExport(result: { hasValidConfig: boolean }): PluginObj {\n  const t = babel.types;\n  // Track which local variable names are assigned to `new Mastra()`\n  const mastraVars = new Set<string>();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const decl = path.node.declaration;\n        // 1) export const mastra = new Mastra(...)\n        if (t.isVariableDeclaration(decl)) {\n          const varDecl = decl.declarations[0];\n          if (\n            t.isIdentifier(varDecl?.id, { name: 'mastra' }) &&\n            t.isNewExpression(varDecl.init) &&\n            t.isIdentifier(varDecl.init.callee, { name: 'Mastra' })\n          ) {\n            result.hasValidConfig = true;\n          }\n        }\n        /**\n         * 2) export { foo as mastra }\n         * 3) export { mastra }\n         * 4) export { mastra, foo }\n         */\n        if (Array.isArray(path.node.specifiers)) {\n          for (const spec of path.node.specifiers) {\n            if (\n              t.isExportSpecifier(spec) &&\n              t.isIdentifier(spec.exported, { name: 'mastra' }) &&\n              t.isIdentifier(spec.local) &&\n              mastraVars.has(spec.local.name)\n            ) {\n              result.hasValidConfig = true;\n            }\n          }\n        }\n      },\n      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`\n      VariableDeclaration(path) {\n        for (const decl of path.node.declarations) {\n          if (\n            t.isIdentifier(decl.id) &&\n            t.isNewExpression(decl.init) &&\n            t.isIdentifier(decl.init.callee, { name: 'Mastra' })\n          ) {\n            mastraVars.add(decl.id.name);\n          }\n        }\n      },\n    },\n  };\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport * as babel from '@babel/core';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport virtual from '@rollup/plugin-virtual';\nimport { existsSync } from 'node:fs';\nimport { readFile } from 'node:fs/promises';\nimport { fileURLToPath } from 'node:url';\nimport { rollup, type OutputAsset, type OutputChunk, type Plugin } from 'rollup';\nimport { esbuild } from './plugins/esbuild';\nimport { isNodeBuiltin } from './isNodeBuiltin';\nimport { aliasHono } from './plugins/hono-alias';\nimport { removeDeployer } from './plugins/remove-deployer';\nimport { dirname, join } from 'node:path';\nimport { validate } from '../validator/validate';\nimport { tsConfigPaths } from './plugins/tsconfig-paths';\nimport { writeFile } from 'node:fs/promises';\nimport { getBundlerOptions } from './bundlerOptions';\nimport resolveFrom from 'resolve-from';\nimport { packageDirectory } from 'package-directory';\nimport { checkConfigExport } from './babel/check-config-export';\n\n// TODO: Make thie extendable or find a rollup plugin that can do this\nconst globalExternals = [\n  'pino',\n  'pino-pretty',\n  '@libsql/client',\n  'pg',\n  'libsql',\n  'jsdom',\n  'sqlite3',\n  'fastembed',\n  'nodemailer',\n  '#tools',\n];\n\nfunction findExternalImporter(module: OutputChunk, external: string, allOutputs: OutputChunk[]): OutputChunk | null {\n  const capturedFiles = new Set();\n\n  for (const id of module.imports) {\n    if (id === external) {\n      return module;\n    } else {\n      if (id.endsWith('.mjs')) {\n        capturedFiles.add(id);\n      }\n    }\n  }\n\n  for (const file of capturedFiles) {\n    const nextModule = allOutputs.find(o => o.fileName === file);\n    if (nextModule) {\n      const importer = findExternalImporter(nextModule, external, allOutputs);\n\n      if (importer) {\n        return importer;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if a path is relative without relying on `isAbsolute()` as we want to allow package names (e.g. `@pkg/name`)\n */\nfunction isRelativePath(id: string): boolean {\n  return id === '.' || id === '..' || id.startsWith('./') || id.startsWith('../');\n}\n\n/**\n * Analyzes the entry file to identify dependencies that need optimization.\n * This is the first step of the bundle analysis process.\n *\n * @param entry - The entry file path or content\n * @param mastraEntry - The mastra entry point\n * @param isVirtualFile - Whether the entry is a virtual file (content string) or a file path\n * @param platform - Target platform (node or browser)\n * @param logger - Logger instance for debugging\n * @returns Map of dependencies to optimize with their exported bindings\n */\nasync function analyze(\n  entry: string,\n  mastraEntry: string,\n  isVirtualFile: boolean,\n  platform: 'node' | 'browser',\n  logger: IMastraLogger,\n  sourcemapEnabled: boolean = false,\n) {\n  logger.info('Analyzing dependencies...');\n  let virtualPlugin = null;\n  if (isVirtualFile) {\n    virtualPlugin = virtual({\n      '#entry': entry,\n    });\n    entry = '#entry';\n  }\n\n  const normalizedMastraEntry = mastraEntry.replaceAll('\\\\', '/');\n  const optimizerBundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: isVirtualFile ? '#entry' : entry,\n    treeshake: 'smallest',\n    preserveSymlinks: true,\n    plugins: [\n      virtualPlugin,\n      tsConfigPaths(),\n      {\n        name: 'custom-alias-resolver',\n        resolveId(id: string) {\n          if (id === '#server') {\n            return fileURLToPath(import.meta.resolve('@mastra/deployer/server')).replaceAll('\\\\', '/');\n          }\n          if (id === '#mastra') {\n            return normalizedMastraEntry;\n          }\n          if (id.startsWith('@mastra/server')) {\n            return fileURLToPath(import.meta.resolve(id));\n          }\n\n          // Tools is generated dependency, we don't want it to be handled by the bundler but instead read from disk at runtime\n          if (id === '#tools') {\n            return {\n              id: '#tools',\n              external: true,\n            };\n          }\n        },\n      } satisfies Plugin,\n      json(),\n      esbuild(),\n      commonjs({\n        strictRequires: 'debug',\n        ignoreTryCatch: false,\n        transformMixedEsModules: true,\n        extensions: ['.js', '.ts'],\n      }),\n      removeDeployer(normalizedMastraEntry, { sourcemap: sourcemapEnabled }),\n      esbuild(),\n    ].filter(Boolean),\n  });\n\n  const { output } = await optimizerBundler.generate({\n    format: 'esm',\n    inlineDynamicImports: true,\n  });\n\n  await optimizerBundler.close();\n\n  const depsToOptimize = new Map(Object.entries(output[0].importedBindings));\n  for (const dep of depsToOptimize.keys()) {\n    if (isNodeBuiltin(dep)) {\n      depsToOptimize.delete(dep);\n    }\n  }\n\n  for (const o of output) {\n    if (o.type !== 'chunk') {\n      continue;\n    }\n\n    // Tools is generated dependency, we don't want our analyzer to handle it\n    const dynamicImports = o.dynamicImports.filter(d => d !== '#tools');\n    if (!dynamicImports.length) {\n      continue;\n    }\n\n    for (const dynamicImport of dynamicImports) {\n      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {\n        depsToOptimize.set(dynamicImport, ['*']);\n      }\n    }\n  }\n\n  return depsToOptimize;\n}\n\n/**\n * Bundles vendor dependencies identified in the analysis step.\n * Creates virtual modules for each dependency and bundles them using rollup.\n *\n * @param depsToOptimize - Map of dependencies with their exports from analyze step\n * @param outputDir - Directory where bundled files will be written\n * @param logger - Logger instance for debugging\n * @returns Object containing bundle output and reference map for validation\n */\nexport async function bundleExternals(\n  depsToOptimize: Map<string, string[]>,\n  outputDir: string,\n  logger: IMastraLogger,\n  options?: {\n    externals?: string[];\n    transpilePackages?: string[];\n    isDev?: boolean;\n  },\n) {\n  logger.info('Optimizing dependencies...');\n  logger.debug(\n    `${Array.from(depsToOptimize.keys())\n      .map(key => `- ${key}`)\n      .join('\\n')}`,\n  );\n\n  const { externals: customExternals = [], transpilePackages = [] } = options || {};\n  const allExternals = [...globalExternals, ...customExternals];\n  const reverseVirtualReferenceMap = new Map<string, string>();\n  const virtualDependencies = new Map();\n  for (const [dep, exports] of depsToOptimize.entries()) {\n    const name = dep.replaceAll('/', '-');\n    reverseVirtualReferenceMap.set(name, dep);\n\n    const virtualFile: string[] = [];\n    let exportStringBuilder = [];\n    for (const local of exports) {\n      if (local === '*') {\n        virtualFile.push(`export * from '${dep}';`);\n      } else if (local === 'default') {\n        virtualFile.push(`export { default } from '${dep}';`);\n      } else {\n        exportStringBuilder.push(local);\n      }\n    }\n\n    if (exportStringBuilder.length > 0) {\n      virtualFile.push(`export { ${exportStringBuilder.join(', ')} } from '${dep}';`);\n    }\n\n    virtualDependencies.set(dep, {\n      name,\n      virtual: virtualFile.join('\\n'),\n    });\n  }\n\n  const transpilePackagesMap = new Map<string, string>();\n  for (const pkg of transpilePackages) {\n    const entryPoint = dirname(resolveFrom(outputDir, pkg));\n    const dir = await packageDirectory({\n      cwd: entryPoint,\n    });\n    if (dir) {\n      transpilePackagesMap.set(pkg, dir);\n    }\n  }\n\n  const bundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: Array.from(virtualDependencies.entries()).reduce(\n      (acc, [dep, virtualDep]) => {\n        acc[virtualDep.name] = `#virtual-${dep}`;\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n    // this dependency breaks the build, so we need to exclude it\n    // TODO actually fix this so we don't need to exclude it\n    external: allExternals,\n    treeshake: 'smallest',\n    plugins: [\n      virtual(\n        Array.from(virtualDependencies.entries()).reduce(\n          (acc, [dep, virtualDep]) => {\n            acc[`#virtual-${dep}`] = virtualDep.virtual;\n            return acc;\n          },\n          {} as Record<string, string>,\n        ),\n      ),\n      options?.isDev\n        ? ({\n            name: 'external-resolver',\n            async resolveId(id, importer, options) {\n              const pathsToTranspile = [...transpilePackagesMap.values()];\n              if (importer && pathsToTranspile.some(p => importer?.startsWith(p)) && !isRelativePath(id)) {\n                const resolved = await this.resolve(id, importer, { skipSelf: true, ...options });\n\n                return {\n                  ...resolved,\n                  external: true,\n                };\n              }\n\n              return null;\n            },\n          } as Plugin)\n        : null,\n      transpilePackagesMap.size\n        ? esbuild({\n            format: 'esm',\n            include: [...transpilePackagesMap.values()].map(p => {\n              // Match files from transpilePackages but exclude any nested node_modules\n              // Escapes regex special characters in the path and uses negative lookahead to avoid node_modules\n              // generated by cursor\n              return new RegExp(`^${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n            }),\n          })\n        : null,\n      commonjs({\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      nodeResolve({\n        preferBuiltins: true,\n        exportConditions: ['node'],\n      }),\n      // hono is imported from deployer, so we need to resolve from here instead of the project root\n      aliasHono(),\n      json(),\n    ].filter(Boolean),\n  });\n\n  const { output } = await bundler.write({\n    format: 'esm',\n    dir: outputDir,\n    entryFileNames: '[name].mjs',\n    chunkFileNames: '[name].mjs',\n    hoistTransitiveImports: false,\n  });\n  const moduleResolveMap = {} as Record<string, Record<string, string>>;\n  const filteredChunks = output.filter(o => o.type === 'chunk');\n\n  for (const o of filteredChunks.filter(o => o.isEntry || o.isDynamicEntry)) {\n    for (const external of allExternals) {\n      if (external === '#tools') {\n        continue;\n      }\n\n      const importer = findExternalImporter(o, external, filteredChunks);\n\n      if (importer) {\n        const fullPath = join(outputDir, importer.fileName);\n        moduleResolveMap[fullPath] = moduleResolveMap[fullPath] || {};\n        if (importer.moduleIds.length) {\n          moduleResolveMap[fullPath][external] = importer.moduleIds[importer.moduleIds.length - 1]?.startsWith(\n            '\\x00virtual:#virtual',\n          )\n            ? importer.moduleIds[importer.moduleIds.length - 2]!\n            : importer.moduleIds[importer.moduleIds.length - 1]!;\n        }\n      }\n    }\n  }\n\n  await writeFile(join(outputDir, 'module-resolve-map.json'), JSON.stringify(moduleResolveMap, null, 2));\n\n  await bundler.close();\n\n  return { output, reverseVirtualReferenceMap, usedExternals: moduleResolveMap };\n}\n\n/**\n * Validates the bundled output by attempting to import each generated module.\n * Tracks invalid chunks and external dependencies that couldn't be bundled.\n *\n * @param output - Bundle output from rollup\n * @param reverseVirtualReferenceMap - Map to resolve virtual module names back to original deps\n * @param outputDir - Directory containing the bundled files\n * @param logger - Logger instance for debugging\n * @returns Analysis result containing invalid chunks and dependency mappings\n */\nasync function validateOutput(\n  {\n    output,\n    reverseVirtualReferenceMap,\n    usedExternals,\n    outputDir,\n  }: {\n    output: (OutputChunk | OutputAsset)[];\n    reverseVirtualReferenceMap: Map<string, string>;\n    usedExternals: Record<string, Record<string, string>>;\n    outputDir: string;\n  },\n  logger: IMastraLogger,\n) {\n  const result = {\n    invalidChunks: new Set<string>(),\n    dependencies: new Map<string, string>(),\n    externalDependencies: new Set<string>(),\n  };\n\n  // we should resolve the version of the deps\n  for (const deps of Object.values(usedExternals)) {\n    for (const dep of Object.keys(deps)) {\n      result.externalDependencies.add(dep);\n    }\n  }\n\n  for (const file of output) {\n    if (file.type === 'asset') {\n      continue;\n    }\n\n    try {\n      logger.debug(`Validating if ${file.fileName} is a valid module.`);\n      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n        result.dependencies.set(reverseVirtualReferenceMap.get(file.name)!, file.fileName);\n      }\n\n      if (!file.isDynamicEntry && file.isEntry) {\n        // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n        await validate(join(outputDir, file.fileName));\n      }\n    } catch (err) {\n      result.invalidChunks.add(file.fileName);\n      if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n        const reference = reverseVirtualReferenceMap.get(file.name)!;\n        const dep = reference.startsWith('@') ? reference.split('/').slice(0, 2).join('/') : reference.split('/')[0];\n\n        result.externalDependencies.add(dep!);\n      }\n\n      // we might need this on other projects but not sure so let's keep it commented out for now\n      // console.log(file.fileName, file.isEntry, file.isDynamicEntry, err);\n      // result.invalidChunks.add(file.fileName);\n      // const externalImports = excludeInternalDeps(file.imports.filter(file => !internalFiles.has(file)));\n      // externalImports.push(...excludeInternalDeps(file.dynamicImports.filter(file => !internalFiles.has(file))));\n      // for (const externalImport of externalImports) {\n      //   result.externalDependencies.add(externalImport);\n      // }\n\n      // if (reverseVirtualReferenceMap.has(file.name)) {\n      //   result.externalDependencies.add(reverseVirtualReferenceMap.get(file.name)!);\n      // }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Main bundle analysis function that orchestrates the three-step process:\n * 1. Analyze dependencies\n * 2. Bundle dependencies modules\n * 3. Validate generated bundles\n *\n * This helps identify which dependencies need to be externalized vs bundled.\n */\nexport async function analyzeBundle(\n  entries: string[],\n  mastraEntry: string,\n  outputDir: string,\n  platform: 'node' | 'browser',\n  logger: IMastraLogger,\n  sourcemapEnabled: boolean = false,\n) {\n  const mastraConfig = await readFile(mastraEntry, 'utf-8');\n  const mastraConfigResult = {\n    hasValidConfig: false,\n  } as const;\n\n  await babel.transformAsync(mastraConfig, {\n    filename: mastraEntry,\n    presets: [import.meta.resolve('@babel/preset-typescript')],\n    plugins: [checkConfigExport(mastraConfigResult)],\n  });\n\n  if (!mastraConfigResult.hasValidConfig) {\n    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:\nexport const mastra = new Mastra({\n  // your options\n})\n  \nIf you think your configuration is valid, please open an issue.`);\n  }\n\n  const depsToOptimize = new Map<string, string[]>();\n  for (const entry of entries) {\n    const isVirtualFile = entry.includes('\\n') || !existsSync(entry);\n    const analyzeResult = await analyze(entry, mastraEntry, isVirtualFile, platform, logger, sourcemapEnabled);\n\n    for (const [dep, exports] of analyzeResult.entries()) {\n      if (depsToOptimize.has(dep)) {\n        // Merge with existing exports if dependency already exists\n        const existingExports = depsToOptimize.get(dep)!;\n        depsToOptimize.set(dep, [...new Set([...existingExports, ...exports])]);\n      } else {\n        depsToOptimize.set(dep, exports);\n      }\n    }\n  }\n  const bundlerOptions = await getBundlerOptions(mastraEntry, outputDir);\n\n  const { output, reverseVirtualReferenceMap, usedExternals } = await bundleExternals(\n    depsToOptimize,\n    outputDir,\n    logger,\n    bundlerOptions ?? undefined,\n  );\n  const result = await validateOutput({ output, reverseVirtualReferenceMap, usedExternals, outputDir }, logger);\n\n  return result;\n}\n"]}