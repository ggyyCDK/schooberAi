{"version":3,"sources":["../src/vector/filter.ts","../src/vector/sql-builder.ts","../src/vector/index.ts","../src/storage/domains/legacy-evals/index.ts","../src/storage/domains/memory/index.ts","../src/storage/domains/utils.ts","../src/storage/domains/operations/index.ts","../src/storage/domains/scores/index.ts","../src/storage/domains/traces/index.ts","../src/storage/domains/workflows/index.ts","../src/storage/index.ts","../src/vector/prompt.ts"],"names":["result","conditions","operator","operatorValue","MastraError","ErrorDomain","ErrorCategory","parseSqlIdentifier","TABLE_WORKFLOW_SNAPSHOT","createClient"],"mappings":"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","file":"index.js","sourcesContent":["import { BaseFilterTranslator } from '@mastra/core/vector/filter';\nimport type { VectorFilter, OperatorSupport, OperatorValueMap, VectorFieldValue } from '@mastra/core/vector/filter';\n\ntype LibSQLOperatorValueMap = Omit<\n  OperatorValueMap,\n  '$regex' | '$options' | '$in' | '$all' | '$nin' | '$eq' | '$ne'\n> & {\n  $size: number;\n  $contains: VectorFieldValue | Record<string, unknown>;\n  $all: VectorFieldValue;\n  $in: VectorFieldValue;\n  $nin: VectorFieldValue;\n  $eq: VectorFieldValue;\n  $ne: VectorFieldValue;\n};\nexport type LibSQLVectorFilter = VectorFilter<keyof LibSQLOperatorValueMap, LibSQLOperatorValueMap>;\n\n/**\n * Translates MongoDB-style filters to LibSQL compatible filters.\n *\n * Key differences from MongoDB:\n *\n * Logical Operators ($and, $or, $nor):\n * - Can be used at the top level or nested within fields\n * - Can take either a single condition or an array of conditions\n *\n */\nexport class LibSQLFilterTranslator extends BaseFilterTranslator<LibSQLVectorFilter> {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      regex: [],\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: LibSQLVectorFilter): LibSQLVectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: LibSQLVectorFilter, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Direct regex pattern format is not supported in LibSQL');\n    }\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    // Handle regex\n    // TODO: Look more into regex support for LibSQL\n    // if (node instanceof RegExp) {\n    //   return withPath(this.translateRegexPattern(node.source, node.flags));\n    // }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    // if ('$options' in node && !('$regex' in node)) {\n    //   throw new Error('$options is not valid without $regex');\n    // }\n\n    // TODO: Look more into regex support for LibSQL\n    // // Handle special regex object format\n    // if ('$regex' in node) {\n    //   const options = (node as any).$options || '';\n    //   return withPath(this.translateRegexPattern(node.$regex, options));\n    // }\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      // // Skip options as they're handled with $regex\n      // if (key === '$options') continue;\n\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: LibSQLVectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  // TODO: Look more into regex support for LibSQL\n  // private translateRegexPattern(pattern: string, options: string = ''): any {\n  //   if (!options) return { $regex: pattern };\n\n  //   const flags = options\n  //     .split('')\n  //     .filter(f => 'imsux'.includes(f))\n  //     .join('');\n\n  //   return {\n  //     $regex: pattern,\n  //     $options: flags,\n  //   };\n  // }\n}\n","import type { InValue } from '@libsql/client';\nimport { parseFieldKey } from '@mastra/core/utils';\nimport type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n} from '@mastra/core/vector/filter';\nimport type { LibSQLVectorFilter } from './filter';\n\ntype OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | '$size';\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: () => any;\n};\n\ntype OperatorFn = (key: string, value?: any) => FilterOperator;\n\n// Helper functions to create operators\nconst createBasicOperator = (symbol: string) => {\n  return (key: string, value: any): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `CASE \n        WHEN ? IS NULL THEN json_extract(metadata, ${jsonPath}) IS ${symbol === '=' ? '' : 'NOT'} NULL\n        ELSE json_extract(metadata, ${jsonPath}) ${symbol} ?\n      END`,\n      needsValue: true,\n      transformValue: () => {\n        // Return the values directly, not in an object\n        return [value, value];\n      },\n    };\n  };\n};\nconst createNumericOperator = (symbol: string) => {\n  return (key: string): FilterOperator => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `CAST(json_extract(metadata, ${jsonPath}) AS NUMERIC) ${symbol} ?`,\n      needsValue: true,\n    };\n  };\n};\n\nconst validateJsonArray = (key: string) => {\n  const jsonPath = getJsonPath(key);\n  return `json_valid(json_extract(metadata, ${jsonPath}))\n   AND json_type(json_extract(metadata, ${jsonPath})) = 'array'`;\n};\n\nconst pattern = /json_extract\\(metadata, '\\$\\.(?:\"[^\"]*\"(?:\\.\"[^\"]*\")*|[^']+)'\\)/g;\n\nfunction buildElemMatchConditions(value: any) {\n  const conditions = Object.entries(value).map(([field, fieldValue]) => {\n    if (field.startsWith('$')) {\n      // Direct operators on array elements ($in, $gt, etc)\n      const { sql, values } = buildCondition('elem.value', { [field]: fieldValue }, '');\n      // Replace the metadata path with elem.value\n      const elemSql = sql.replace(pattern, 'elem.value');\n      return { sql: elemSql, values };\n    } else if (typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {\n      // Nested field with operators (count: { $gt: 20 })\n      const { sql, values } = buildCondition(field, fieldValue, '');\n      // Replace the field path with elem.value path\n      const jsonPath = parseJsonPathKey(field);\n      const elemSql = sql.replace(pattern, `json_extract(elem.value, '$.${jsonPath}')`);\n      return { sql: elemSql, values };\n    } else {\n      const jsonPath = parseJsonPathKey(field);\n      // Simple field equality (warehouse: 'A')\n      return {\n        sql: `json_extract(elem.value, '$.${jsonPath}') = ?`,\n        values: [fieldValue],\n      };\n    }\n  });\n\n  return conditions;\n}\n\n// Define all filter operators\nconst FILTER_OPERATORS: Record<OperatorType, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 0', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n\n  $nin: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    const arr = Array.isArray(value) ? value : [value];\n    if (arr.length === 0) {\n      return { sql: '1 = 1', needsValue: true, transformValue: () => [] };\n    }\n    const paramPlaceholders = arr.map(() => '?').join(',');\n    return {\n      sql: `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT 1 FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n            WHERE elem.value IN (SELECT value FROM json_each(?))\n          )\n        ELSE json_extract(metadata, ${jsonPath}) NOT IN (${paramPlaceholders})\n      END\n    )`,\n      needsValue: true,\n      transformValue: () => [JSON.stringify(arr), ...arr],\n    };\n  },\n  $all: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    let sql: string;\n    const arrayValue = Array.isArray(value) ? value : [value];\n\n    if (arrayValue.length === 0) {\n      // If the array is empty, always return false (no matches)\n      sql = '1 = 0';\n    } else {\n      sql = `(\n      CASE\n        WHEN ${validateJsonArray(key)} THEN\n          NOT EXISTS (\n            SELECT value\n            FROM json_each(?)\n            WHERE value NOT IN (\n              SELECT value\n              FROM json_each(json_extract(metadata, ${jsonPath}))\n            )\n          )\n        ELSE FALSE\n      END\n    )`;\n    }\n\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (arrayValue.length === 0) {\n          return [];\n        }\n        return [JSON.stringify(arrayValue)];\n      },\n    };\n  },\n  $elemMatch: (key: string, value: any) => {\n    const jsonPath = getJsonPath(key);\n    if (typeof value !== 'object' || Array.isArray(value)) {\n      throw new Error('$elemMatch requires an object with conditions');\n    }\n\n    // For nested object conditions\n    const conditions = buildElemMatchConditions(value);\n\n    return {\n      sql: `(\n        CASE\n          WHEN ${validateJsonArray(key)} THEN\n            EXISTS (\n              SELECT 1\n              FROM json_each(json_extract(metadata, ${jsonPath})) as elem\n              WHERE ${conditions.map(c => c.sql).join(' AND ')}\n            )\n          ELSE FALSE\n        END\n      )`,\n      needsValue: true,\n      transformValue: () => conditions.flatMap(c => c.values),\n    };\n  },\n\n  // Element Operators\n  $exists: (key: string) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) IS NOT NULL`,\n      needsValue: false,\n    };\n  },\n\n  // Logical Operators\n  $and: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $or: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: (key: string) => ({\n    sql: `NOT (${key})`,\n    needsValue: false,\n  }),\n  $size: (key: string, paramIndex: number) => {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `(\n    CASE\n      WHEN json_type(json_extract(metadata, ${jsonPath})) = 'array' THEN \n        json_array_length(json_extract(metadata, ${jsonPath})) = $${paramIndex}\n      ELSE FALSE\n    END\n  )`,\n      needsValue: true,\n    };\n  },\n  //   /**\n  //    * Regex Operators\n  //    * Supports case insensitive and multiline\n  //    */\n  //   $regex: (key: string): FilterOperator => ({\n  //     sql: `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"') = ?`,\n  //     needsValue: true,\n  //     transformValue: (value: any) => {\n  //       const pattern = typeof value === 'object' ? value.$regex : value;\n  //       const options = typeof value === 'object' ? value.$options || '' : '';\n  //       let sql = `json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`;\n\n  //       // Handle multiline\n  //       //   if (options.includes('m')) {\n  //       //     sql = `REPLACE(${sql}, CHAR(10), '\\n')`;\n  //       //   }\n\n  //       //       let finalPattern = pattern;\n  //       // if (options) {\n  //       //   finalPattern = `(\\\\?${options})${pattern}`;\n  //       // }\n\n  //       //   // Handle case insensitivity\n  //       //   if (options.includes('i')) {\n  //       //     sql = `LOWER(${sql}) REGEXP LOWER(?)`;\n  //       //   } else {\n  //       //     sql = `${sql} REGEXP ?`;\n  //       //   }\n\n  //       if (options.includes('m')) {\n  //         sql = `EXISTS (\n  //         SELECT 1\n  //         FROM json_each(\n  //           json_array(\n  //             ${sql},\n  //             REPLACE(${sql}, CHAR(10), CHAR(13))\n  //           )\n  //         ) as lines\n  //         WHERE lines.value REGEXP ?\n  //       )`;\n  //       } else {\n  //         sql = `${sql} REGEXP ?`;\n  //       }\n\n  //       // Handle case insensitivity\n  //       if (options.includes('i')) {\n  //         sql = sql.replace('REGEXP ?', 'REGEXP LOWER(?)');\n  //         sql = sql.replace('value REGEXP', 'LOWER(value) REGEXP');\n  //       }\n\n  //       // Handle extended - allows whitespace and comments in pattern\n  //       if (options.includes('x')) {\n  //         // Remove whitespace and comments from pattern\n  //         const cleanPattern = pattern.replace(/\\s+|#.*$/gm, '');\n  //         return {\n  //           sql,\n  //           values: [cleanPattern],\n  //         };\n  //       }\n\n  //       return {\n  //         sql,\n  //         values: [pattern],\n  //       };\n  //     },\n  //   }),\n  $contains: (key: string, value: any) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    let sql;\n    if (Array.isArray(value)) {\n      sql = `(\n        SELECT ${validateJsonArray(jsonPathKey)}\n        AND EXISTS (\n          SELECT 1\n          FROM json_each(json_extract(metadata, '$.\"${jsonPathKey}\"')) as m\n          WHERE m.value IN (SELECT value FROM json_each(?))\n        )\n      )`;\n    } else if (typeof value === 'string') {\n      sql = `lower(json_extract(metadata, '$.\"${jsonPathKey}\"')) LIKE '%' || lower(?) || '%' ESCAPE '\\\\'`;\n    } else {\n      sql = `json_extract(metadata, '$.\"${jsonPathKey}\"') = ?`;\n    }\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () => {\n        if (Array.isArray(value)) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'object' && value !== null) {\n          return [JSON.stringify(value)];\n        }\n        if (typeof value === 'string') {\n          return [escapeLikePattern(value)];\n        }\n        return [value];\n      },\n    };\n  },\n  /**\n   * $objectContains: True JSON containment for advanced use (deep sub-object match).\n   * Usage: { field: { $objectContains: { ...subobject } } }\n   */\n  // $objectContains: (key: string) => ({\n  //   sql: '', // Will be overridden by transformValue\n  //   needsValue: true,\n  //   transformValue: (value: any) => ({\n  //     sql: `json_type(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')) = 'object'\n  //         AND json_patch(json_extract(metadata, '$.\"${toJsonPathKey(key)}\"'), ?) = json_extract(metadata, '$.\"${toJsonPathKey(key)}\"')`,\n  //     values: [JSON.stringify(value)],\n  //   }),\n  // }),\n};\n\ninterface FilterResult {\n  sql: string;\n  values: InValue[];\n}\n\nfunction isFilterResult(obj: any): obj is FilterResult {\n  return obj && typeof obj === 'object' && typeof obj.sql === 'string' && Array.isArray(obj.values);\n}\n\nconst parseJsonPathKey = (key: string) => {\n  const parsedKey = parseFieldKey(key);\n  // Only add quotes around path segments if they contain dots\n  if (parsedKey.includes('.')) {\n    return parsedKey\n      .split('.')\n      .map(segment => `\"${segment}\"`)\n      .join('.');\n  }\n  return parsedKey;\n};\n\n// Helper to generate the correct JSON path format for LibSQL\nconst getJsonPath = (key: string) => {\n  const jsonPathKey = parseJsonPathKey(key);\n  // Always use quotes for consistency\n  return `'$.${jsonPathKey}'`;\n};\n\nfunction escapeLikePattern(str: string): string {\n  return str.replace(/([%_\\\\])/g, '\\\\$1');\n}\n\nexport function buildFilterQuery(filter: LibSQLVectorFilter): FilterResult {\n  if (!filter) {\n    return { sql: '', values: [] };\n  }\n\n  const values: InValue[] = [];\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => {\n      const condition = buildCondition(key, value, '');\n      values.push(...condition.values);\n      return condition.sql;\n    })\n    .join(' AND ');\n\n  return {\n    sql: conditions ? `WHERE ${conditions}` : '',\n    values,\n  };\n}\n\nfunction buildCondition(key: string, value: any, parentPath: string): FilterResult {\n  // Handle logical operators ($and/$or)\n  if (['$and', '$or', '$not', '$nor'].includes(key)) {\n    return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n  }\n\n  // If condition is not a FilterCondition object, assume it's an equality check\n  if (!value || typeof value !== 'object') {\n    const jsonPath = getJsonPath(key);\n    return {\n      sql: `json_extract(metadata, ${jsonPath}) = ?`,\n      values: [value],\n    };\n  }\n\n  //TODO: Add regex support\n  //   if ('$regex' in value) {\n  //     return handleRegexOperator(key, value);\n  //   }\n\n  // Handle operator conditions\n  return handleOperator(key, value);\n}\n\n// function handleRegexOperator(key: string, value: any): FilterResult {\n//   const operatorFn = FILTER_OPERATORS['$regex']!;\n//   const operatorResult = operatorFn(key, value);\n//   const transformed = operatorResult.transformValue ? operatorResult.transformValue(value) : value;\n\n//   return {\n//     sql: transformed.sql,\n//     values: transformed.values,\n//   };\n// }\n\nfunction handleLogicalOperator(\n  key: '$and' | '$or' | '$not' | '$nor',\n  value: LibSQLVectorFilter[] | LibSQLVectorFilter,\n  parentPath: string,\n): FilterResult {\n  // Handle empty conditions\n  if (!value || (Array.isArray(value) && value.length === 0)) {\n    switch (key) {\n      case '$and':\n      case '$nor':\n        return { sql: 'true', values: [] };\n      case '$or':\n        return { sql: 'false', values: [] };\n      case '$not':\n        throw new Error('$not operator cannot be empty');\n      default:\n        return { sql: 'true', values: [] };\n    }\n  }\n\n  if (key === '$not') {\n    // For top-level $not\n    const entries = Object.entries(value);\n    const conditions = entries.map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key));\n    return {\n      sql: `NOT (${conditions.map(c => c.sql).join(' AND ')})`,\n      values: conditions.flatMap(c => c.values),\n    };\n  }\n\n  const values: InValue[] = [];\n  const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n  const conditions = Array.isArray(value)\n    ? value.map(f => {\n        const entries = !!f ? Object.entries(f) : [];\n        return entries.map(([k, v]) => buildCondition(k, v, key));\n      })\n    : [buildCondition(key, value, parentPath)];\n\n  const joined = conditions\n    .flat()\n    .map(c => {\n      values.push(...c.values);\n      return c.sql;\n    })\n    .join(` ${joinOperator} `);\n\n  return {\n    sql: key === '$nor' ? `NOT (${joined})` : `(${joined})`,\n    values,\n  };\n}\n\nfunction handleOperator(key: string, value: any): FilterResult {\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    const entries = Object.entries(value);\n    const results = entries.map(([operator, operatorValue]) =>\n      operator === '$not'\n        ? {\n            sql: `NOT (${Object.entries(operatorValue as Record<string, any>)\n              .map(([op, val]) => processOperator(key, op as OperatorType, val).sql)\n              .join(' AND ')})`,\n            values: Object.entries(operatorValue as Record<string, any>).flatMap(\n              ([op, val]) => processOperator(key, op as OperatorType, val).values,\n            ),\n          }\n        : processOperator(key, operator as OperatorType, operatorValue),\n    );\n\n    return {\n      sql: `(${results.map(r => r.sql).join(' AND ')})`,\n      values: results.flatMap(r => r.values),\n    };\n  }\n\n  // Handle single operator\n  const [[operator, operatorValue] = []] = Object.entries(value);\n  return processOperator(key, operator as OperatorType, operatorValue);\n}\n\nconst processOperator = (key: string, operator: OperatorType, operatorValue: any): FilterResult => {\n  if (!operator.startsWith('$') || !FILTER_OPERATORS[operator]) {\n    throw new Error(`Invalid operator: ${operator}`);\n  }\n  const operatorFn = FILTER_OPERATORS[operator]!;\n  const operatorResult = operatorFn(key, operatorValue);\n\n  if (!operatorResult.needsValue) {\n    return { sql: operatorResult.sql, values: [] };\n  }\n\n  const transformed = operatorResult.transformValue ? operatorResult.transformValue() : operatorValue;\n\n  if (isFilterResult(transformed)) {\n    return transformed;\n  }\n\n  return {\n    sql: operatorResult.sql,\n    values: Array.isArray(transformed) ? transformed : [transformed],\n  };\n};\n","import { createClient } from '@libsql/client';\nimport type { Client as TursoClient, InValue } from '@libsql/client';\n\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { MastraVector } from '@mastra/core/vector';\nimport type {\n  IndexStats,\n  QueryResult,\n  QueryVectorParams,\n  CreateIndexParams,\n  UpsertVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n  DeleteVectorParams,\n  UpdateVectorParams,\n} from '@mastra/core/vector';\nimport type { LibSQLVectorFilter } from './filter';\nimport { LibSQLFilterTranslator } from './filter';\nimport { buildFilterQuery } from './sql-builder';\n\ninterface LibSQLQueryVectorParams extends QueryVectorParams<LibSQLVectorFilter> {\n  minScore?: number;\n}\n\nexport interface LibSQLVectorConfig {\n  connectionUrl: string;\n  authToken?: string;\n  syncUrl?: string;\n  syncInterval?: number;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries?: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs?: number;\n}\n\nexport class LibSQLVector extends MastraVector<LibSQLVectorFilter> {\n  private turso: TursoClient;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  constructor({\n    connectionUrl,\n    authToken,\n    syncUrl,\n    syncInterval,\n    maxRetries = 5,\n    initialBackoffMs = 100,\n  }: LibSQLVectorConfig) {\n    super();\n\n    this.turso = createClient({\n      url: connectionUrl,\n      syncUrl: syncUrl,\n      authToken,\n      syncInterval,\n    });\n    this.maxRetries = maxRetries;\n    this.initialBackoffMs = initialBackoffMs;\n\n    if (connectionUrl.includes(`file:`) || connectionUrl.includes(`:memory:`)) {\n      this.turso\n        .execute('PRAGMA journal_mode=WAL;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n      this.turso\n        .execute('PRAGMA busy_timeout = 5000;')\n        .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n        .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout=5000.', err));\n    }\n  }\n\n  private async executeWriteOperationWithRetry<T>(operation: () => Promise<T>, isTransaction = false): Promise<T> {\n    let attempts = 0;\n    let backoff = this.initialBackoffMs;\n    while (attempts < this.maxRetries) {\n      try {\n        return await operation();\n      } catch (error: any) {\n        if (\n          error.code === 'SQLITE_BUSY' ||\n          (error.message && error.message.toLowerCase().includes('database is locked'))\n        ) {\n          attempts++;\n          if (attempts >= this.maxRetries) {\n            this.logger.error(\n              `LibSQLVector: Operation failed after ${this.maxRetries} attempts due to: ${error.message}`,\n              error,\n            );\n            throw error;\n          }\n          this.logger.warn(\n            `LibSQLVector: Attempt ${attempts} failed due to ${isTransaction ? 'transaction ' : ''}database lock. Retrying in ${backoff}ms...`,\n          );\n          await new Promise(resolve => setTimeout(resolve, backoff));\n          backoff *= 2;\n        } else {\n          throw error;\n        }\n      }\n    }\n    throw new Error('LibSQLVector: Max retries reached, but no error was re-thrown from the loop.');\n  }\n\n  transformFilter(filter?: LibSQLVectorFilter) {\n    const translator = new LibSQLFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query({\n    indexName,\n    queryVector,\n    topK = 10,\n    filter,\n    includeVector = false,\n    minScore = -1, // Default to -1 to include all results (cosine similarity ranges from -1 to 1)\n  }: LibSQLQueryVectorParams): Promise<QueryResult[]> {\n    try {\n      if (!Number.isInteger(topK) || topK <= 0) {\n        throw new Error('topK must be a positive integer');\n      }\n      if (!Array.isArray(queryVector) || !queryVector.every(x => typeof x === 'number' && Number.isFinite(x))) {\n        throw new Error('queryVector must be an array of finite numbers');\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_QUERY_INVALID_ARGS',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n\n      const vectorStr = `[${queryVector.join(',')}]`;\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);\n      filterValues.push(minScore);\n      filterValues.push(topK);\n\n      const query = `\n      WITH vector_scores AS (\n        SELECT\n          vector_id as id,\n          (1-vector_distance_cos(embedding, '${vectorStr}')) as score,\n          metadata\n          ${includeVector ? ', vector_extract(embedding) as embedding' : ''}\n        FROM ${parsedIndexName}\n        ${filterQuery}\n      )\n      SELECT *\n      FROM vector_scores\n      WHERE score > ?\n      ORDER BY score DESC\n      LIMIT ?`;\n\n      const result = await this.turso.execute({\n        sql: query,\n        args: filterValues,\n      });\n\n      return result.rows.map(({ id, score, metadata, embedding }) => ({\n        id: id as string,\n        score: score as number,\n        metadata: JSON.parse((metadata as string) ?? '{}'),\n        ...(includeVector && embedding && { vector: JSON.parse(embedding as string) }),\n      }));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_QUERY_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  public upsert(args: UpsertVectorParams): Promise<string[]> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doUpsert(args), true);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_UPSERT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  private async doUpsert({ indexName, vectors, metadata, ids }: UpsertVectorParams): Promise<string[]> {\n    const tx = await this.turso.transaction('write');\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n      for (let i = 0; i < vectors.length; i++) {\n        const query = `\n            INSERT INTO ${parsedIndexName} (vector_id, embedding, metadata)\n            VALUES (?, vector32(?), ?)\n            ON CONFLICT(vector_id) DO UPDATE SET\n              embedding = vector32(?),\n              metadata = ?\n          `;\n        await tx.execute({\n          sql: query,\n          args: [\n            vectorIds[i] as InValue,\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n          ],\n        });\n      }\n      await tx.commit();\n      return vectorIds;\n    } catch (error) {\n      !tx.closed && (await tx.rollback());\n      if (error instanceof Error && error.message?.includes('dimensions are different')) {\n        const match = error.message.match(/dimensions are different: (\\d+) != (\\d+)/);\n        if (match) {\n          const [, actual, expected] = match;\n          throw new Error(\n            `Vector dimension mismatch: Index \"${indexName}\" expects ${expected} dimensions but got ${actual} dimensions. ` +\n              `Either use a matching embedding model or delete and recreate the index with the new dimension.`,\n          );\n        }\n      }\n      throw error;\n    }\n  }\n\n  public createIndex(args: CreateIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doCreateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_CREATE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName, dimension: args.dimension },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doCreateIndex({ indexName, dimension }: CreateIndexParams): Promise<void> {\n    if (!Number.isInteger(dimension) || dimension <= 0) {\n      throw new Error('Dimension must be a positive integer');\n    }\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `\n          CREATE TABLE IF NOT EXISTS ${parsedIndexName} (\n            id SERIAL PRIMARY KEY,\n            vector_id TEXT UNIQUE NOT NULL,\n            embedding F32_BLOB(${dimension}),\n            metadata TEXT DEFAULT '{}'\n          );\n        `,\n      args: [],\n    });\n    await this.turso.execute({\n      sql: `\n          CREATE INDEX IF NOT EXISTS ${parsedIndexName}_vector_idx\n          ON ${parsedIndexName} (libsql_vector_idx(embedding))\n        `,\n      args: [],\n    });\n  }\n\n  public deleteIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_DELETE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DROP TABLE IF EXISTS ${parsedIndexName}`,\n      args: [],\n    });\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const vectorTablesQuery = `\n        SELECT name FROM sqlite_master \n        WHERE type='table' \n        AND sql LIKE '%F32_BLOB%';\n      `;\n      const result = await this.turso.execute({\n        sql: vectorTablesQuery,\n        args: [],\n      });\n      return result.rows.map(row => row.name as string);\n    } catch (error: any) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_LIST_INDEXES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Retrieves statistics about a vector index.\n   *\n   * @param {string} indexName - The name of the index to describe\n   * @returns A promise that resolves to the index statistics including dimension, count and metric\n   */\n  async describeIndex({ indexName }: DescribeIndexParams): Promise<IndexStats> {\n    try {\n      const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n      // Get table info including column info\n      const tableInfoQuery = `\n        SELECT sql \n        FROM sqlite_master \n        WHERE type='table' \n        AND name = ?;\n      `;\n      const tableInfo = await this.turso.execute({\n        sql: tableInfoQuery,\n        args: [parsedIndexName],\n      });\n\n      if (!tableInfo.rows[0]?.sql) {\n        throw new Error(`Table ${parsedIndexName} not found`);\n      }\n\n      // Extract dimension from F32_BLOB definition\n      const dimension = parseInt((tableInfo.rows[0].sql as string).match(/F32_BLOB\\((\\d+)\\)/)?.[1] || '0');\n\n      // Get row count\n      const countQuery = `\n        SELECT COUNT(*) as count\n        FROM ${parsedIndexName};\n      `;\n      const countResult = await this.turso.execute({\n        sql: countQuery,\n        args: [],\n      });\n\n      // LibSQL only supports cosine similarity currently\n      const metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine';\n\n      return {\n        dimension,\n        count: (countResult?.rows?.[0]?.count as number) ?? 0,\n        metric,\n      };\n    } catch (e: any) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_DESCRIBE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName },\n        },\n        e,\n      );\n    }\n  }\n\n  /**\n   * Updates a vector by its ID with the provided vector and/or metadata.\n   *\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  public updateVector(args: UpdateVectorParams): Promise<void> {\n    return this.executeWriteOperationWithRetry(() => this.doUpdateVector(args));\n  }\n\n  private async doUpdateVector({ indexName, id, update }: UpdateVectorParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    const updates = [];\n    const args: InValue[] = [];\n\n    if (update.vector) {\n      updates.push('embedding = vector32(?)');\n      args.push(JSON.stringify(update.vector));\n    }\n\n    if (update.metadata) {\n      updates.push('metadata = ?');\n      args.push(JSON.stringify(update.metadata));\n    }\n\n    if (updates.length === 0) {\n      throw new MastraError({\n        id: 'LIBSQL_VECTOR_UPDATE_VECTOR_INVALID_ARGS',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        details: { indexName, id },\n        text: 'No updates provided',\n      });\n    }\n    args.push(id);\n    const query = `\n        UPDATE ${parsedIndexName}\n        SET ${updates.join(', ')}\n        WHERE vector_id = ?;\n      `;\n\n    try {\n      await this.turso.execute({\n        sql: query,\n        args,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_UPDATE_VECTOR_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, id },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes a vector by its ID.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   * @throws Will throw an error if the deletion operation fails.\n   */\n  public deleteVector(args: DeleteVectorParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this.doDeleteVector(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_DELETE_VECTOR_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName, id: args.id },\n        },\n        error,\n      );\n    }\n  }\n\n  private async doDeleteVector({ indexName, id }: DeleteVectorParams): Promise<void> {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    await this.turso.execute({\n      sql: `DELETE FROM ${parsedIndexName} WHERE vector_id = ?`,\n      args: [id],\n    });\n  }\n\n  public truncateIndex(args: DeleteIndexParams): Promise<void> {\n    try {\n      return this.executeWriteOperationWithRetry(() => this._doTruncateIndex(args));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_VECTOR_TRUNCATE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName: args.indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  private async _doTruncateIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    await this.turso.execute({\n      sql: `DELETE FROM ${parseSqlIdentifier(indexName, 'index name')}`,\n      args: [],\n    });\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MetricResult, TestInfo } from '@mastra/core/eval';\nimport { LegacyEvalsStorage, TABLE_EVALS } from '@mastra/core/storage';\nimport type { PaginationArgs, PaginationInfo, EvalRow } from '@mastra/core/storage';\n\nfunction transformEvalRow(row: Record<string, any>): EvalRow {\n  const resultValue = JSON.parse(row.result as string);\n  const testInfoValue = row.test_info ? JSON.parse(row.test_info as string) : undefined;\n\n  if (!resultValue || typeof resultValue !== 'object' || !('score' in resultValue)) {\n    throw new Error(`Invalid MetricResult format: ${JSON.stringify(resultValue)}`);\n  }\n\n  return {\n    input: row.input as string,\n    output: row.output as string,\n    result: resultValue as MetricResult,\n    agentName: row.agent_name as string,\n    metricName: row.metric_name as string,\n    instructions: row.instructions as string,\n    testInfo: testInfoValue as TestInfo,\n    globalRunId: row.global_run_id as string,\n    runId: row.run_id as string,\n    createdAt: row.created_at as string,\n  };\n}\n\nexport class LegacyEvalsLibSQL extends LegacyEvalsStorage {\n  private client: Client;\n  constructor({ client }: { client: Client }) {\n    super();\n    this.client = client;\n  }\n\n  /** @deprecated use getEvals instead */\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    try {\n      const baseQuery = `SELECT * FROM ${TABLE_EVALS} WHERE agent_name = ?`;\n      const typeCondition =\n        type === 'test'\n          ? \" AND test_info IS NOT NULL AND test_info->>'testPath' IS NOT NULL\"\n          : type === 'live'\n            ? \" AND (test_info IS NULL OR test_info->>'testPath' IS NULL)\"\n            : '';\n\n      const result = await this.client.execute({\n        sql: `${baseQuery}${typeCondition} ORDER BY created_at DESC`,\n        args: [agentName],\n      });\n\n      return result.rows?.map(row => transformEvalRow(row)) ?? [];\n    } catch (error) {\n      // Handle case where table doesn't exist yet\n      if (error instanceof Error && error.message.includes('no such table')) {\n        return [];\n      }\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_EVALS_BY_AGENT_NAME_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { agentName },\n        },\n        error,\n      );\n    }\n  }\n\n  async getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs = {},\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    const { agentName, type, page = 0, perPage = 100, dateRange } = options;\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n\n    const conditions: string[] = [];\n    const queryParams: InValue[] = [];\n\n    if (agentName) {\n      conditions.push(`agent_name = ?`);\n      queryParams.push(agentName);\n    }\n\n    if (type === 'test') {\n      conditions.push(`(test_info IS NOT NULL AND json_extract(test_info, '$.testPath') IS NOT NULL)`);\n    } else if (type === 'live') {\n      conditions.push(`(test_info IS NULL OR json_extract(test_info, '$.testPath') IS NULL)`);\n    }\n\n    if (fromDate) {\n      conditions.push(`created_at >= ?`);\n      queryParams.push(fromDate.toISOString());\n    }\n\n    if (toDate) {\n      conditions.push(`created_at <= ?`);\n      queryParams.push(toDate.toISOString());\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const countResult = await this.client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_EVALS} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      const currentOffset = page * perPage;\n      const hasMore = currentOffset + perPage < total;\n\n      if (total === 0) {\n        return {\n          evals: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataResult = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_EVALS} ${whereClause} ORDER BY created_at DESC LIMIT ? OFFSET ?`,\n        args: [...queryParams, perPage, currentOffset],\n      });\n\n      return {\n        evals: dataResult.rows?.map(row => transformEvalRow(row)) ?? [],\n        total,\n        page,\n        perPage,\n        hasMore,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_EVALS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { parseSqlIdentifier } from '@mastra/core';\nimport type { MastraMessageContentV2 } from '@mastra/core/agent';\nimport { MessageList } from '@mastra/core/agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MastraMessageV1, MastraMessageV2, StorageThreadType } from '@mastra/core/memory';\nimport type {\n  PaginationInfo,\n  StorageGetMessagesArg,\n  StorageResourceType,\n  ThreadSortOptions,\n} from '@mastra/core/storage';\nimport {\n  MemoryStorage,\n  resolveMessageLimit,\n  TABLE_MESSAGES,\n  TABLE_RESOURCES,\n  TABLE_THREADS,\n} from '@mastra/core/storage';\nimport type { StoreOperationsLibSQL } from '../operations';\n\nexport class MemoryLibSQL extends MemoryStorage {\n  private client: Client;\n  private operations: StoreOperationsLibSQL;\n  constructor({ client, operations }: { client: Client; operations: StoreOperationsLibSQL }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n  }\n\n  private parseRow(row: any): MastraMessageV2 {\n    let content = row.content;\n    try {\n      content = JSON.parse(row.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    const result = {\n      id: row.id,\n      content,\n      role: row.role,\n      createdAt: new Date(row.createdAt as string),\n      threadId: row.thread_id,\n      resourceId: row.resourceId,\n    } as MastraMessageV2;\n    if (row.type && row.type !== `v2`) result.type = row.type;\n    return result;\n  }\n\n  private async _getIncludedMessages({\n    threadId,\n    selectBy,\n  }: {\n    threadId: string;\n    selectBy: StorageGetMessagesArg['selectBy'];\n  }) {\n    const include = selectBy?.include;\n    if (!include) return null;\n\n    const unionQueries: string[] = [];\n    const params: any[] = [];\n\n    for (const inc of include) {\n      const { id, withPreviousMessages = 0, withNextMessages = 0 } = inc;\n      // if threadId is provided, use it, otherwise use threadId from args\n      const searchId = inc.threadId || threadId;\n      unionQueries.push(\n        `\n                SELECT * FROM (\n                  WITH numbered_messages AS (\n                    SELECT\n                      id, content, role, type, \"createdAt\", thread_id, \"resourceId\",\n                      ROW_NUMBER() OVER (ORDER BY \"createdAt\" ASC) as row_num\n                    FROM \"${TABLE_MESSAGES}\"\n                    WHERE thread_id = ?\n                  ),\n                  target_positions AS (\n                    SELECT row_num as target_pos\n                    FROM numbered_messages\n                    WHERE id = ?\n                  )\n                  SELECT DISTINCT m.*\n                  FROM numbered_messages m\n                  CROSS JOIN target_positions t\n                  WHERE m.row_num BETWEEN (t.target_pos - ?) AND (t.target_pos + ?)\n                ) \n                `, // Keep ASC for final sorting after fetching context\n      );\n      params.push(searchId, id, withPreviousMessages, withNextMessages);\n    }\n    const finalQuery = unionQueries.join(' UNION ALL ') + ' ORDER BY \"createdAt\" ASC';\n    const includedResult = await this.client.execute({ sql: finalQuery, args: params });\n    const includedRows = includedResult.rows?.map(row => this.parseRow(row));\n    const seen = new Set<string>();\n    const dedupedRows = includedRows.filter(row => {\n      if (seen.has(row.id)) return false;\n      seen.add(row.id);\n      return true;\n    });\n    return dedupedRows;\n  }\n\n  /**\n   * @deprecated use getMessagesPaginated instead for paginated results.\n   */\n  public async getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  public async getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  public async getMessages({\n    threadId,\n    selectBy,\n    format,\n  }: StorageGetMessagesArg & {\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    try {\n      const messages: MastraMessageV2[] = [];\n      const limit = resolveMessageLimit({ last: selectBy?.last, defaultLimit: 40 });\n      if (selectBy?.include?.length) {\n        const includeMessages = await this._getIncludedMessages({ threadId, selectBy });\n        if (includeMessages) {\n          messages.push(...includeMessages);\n        }\n      }\n\n      const excludeIds = messages.map(m => m.id);\n      const remainingSql = `\n        SELECT \n          id, \n          content, \n          role, \n          type,\n          \"createdAt\", \n          thread_id,\n          \"resourceId\"\n        FROM \"${TABLE_MESSAGES}\"\n        WHERE thread_id = ?\n        ${excludeIds.length ? `AND id NOT IN (${excludeIds.map(() => '?').join(', ')})` : ''}\n        ORDER BY \"createdAt\" DESC\n        LIMIT ?\n      `;\n      const remainingArgs = [threadId, ...(excludeIds.length ? excludeIds : []), limit];\n      const remainingResult = await this.client.execute({ sql: remainingSql, args: remainingArgs });\n      if (remainingResult.rows) {\n        messages.push(...remainingResult.rows.map((row: any) => this.parseRow(row)));\n      }\n      messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n      const list = new MessageList().add(messages, 'memory');\n      if (format === `v2`) return list.get.all.v2();\n      return list.get.all.v1();\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  public async getMessagesPaginated(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }> {\n    const { threadId, format, selectBy } = args;\n    const { page = 0, perPage: perPageInput, dateRange } = selectBy?.pagination || {};\n    const perPage =\n      perPageInput !== undefined ? perPageInput : resolveMessageLimit({ last: selectBy?.last, defaultLimit: 40 });\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n\n    const messages: MastraMessageV2[] = [];\n\n    if (selectBy?.include?.length) {\n      try {\n        const includeMessages = await this._getIncludedMessages({ threadId, selectBy });\n        if (includeMessages) {\n          messages.push(...includeMessages);\n        }\n      } catch (error) {\n        throw new MastraError(\n          {\n            id: 'LIBSQL_STORE_GET_MESSAGES_PAGINATED_GET_INCLUDE_MESSAGES_FAILED',\n            domain: ErrorDomain.STORAGE,\n            category: ErrorCategory.THIRD_PARTY,\n            details: { threadId },\n          },\n          error,\n        );\n      }\n    }\n\n    try {\n      const currentOffset = page * perPage;\n\n      const conditions: string[] = [`thread_id = ?`];\n      const queryParams: InValue[] = [threadId];\n\n      if (fromDate) {\n        conditions.push(`\"createdAt\" >= ?`);\n        queryParams.push(fromDate.toISOString());\n      }\n      if (toDate) {\n        conditions.push(`\"createdAt\" <= ?`);\n        queryParams.push(toDate.toISOString());\n      }\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      const countResult = await this.client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_MESSAGES} ${whereClause}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0 && messages.length === 0) {\n        return {\n          messages: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const excludeIds = messages.map(m => m.id);\n      const excludeIdsParam = excludeIds.map((_, idx) => `$${idx + queryParams.length + 1}`).join(', ');\n\n      const dataResult = await this.client.execute({\n        sql: `SELECT id, content, role, type, \"createdAt\", \"resourceId\", \"thread_id\" FROM ${TABLE_MESSAGES} ${whereClause} ${excludeIds.length ? `AND id NOT IN (${excludeIdsParam})` : ''} ORDER BY \"createdAt\" DESC LIMIT ? OFFSET ?`,\n        args: [...queryParams, ...excludeIds, perPage, currentOffset],\n      });\n\n      messages.push(...(dataResult.rows || []).map((row: any) => this.parseRow(row)));\n\n      const messagesToReturn =\n        format === 'v1'\n          ? new MessageList().add(messages, 'memory').get.all.v1()\n          : new MessageList().add(messages, 'memory').get.all.v2();\n\n      return {\n        messages: messagesToReturn,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + messages.length < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_MESSAGES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      return { messages: [], total: 0, page, perPage, hasMore: false };\n    }\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages({\n    messages,\n    format,\n  }:\n    | { messages: MastraMessageV1[]; format?: undefined | 'v1' }\n    | { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    if (messages.length === 0) return messages;\n\n    try {\n      const threadId = messages[0]?.threadId;\n      if (!threadId) {\n        throw new Error('Thread ID is required');\n      }\n\n      // Prepare batch statements for all messages\n      const batchStatements = messages.map(message => {\n        const time = message.createdAt || new Date();\n        if (!message.threadId) {\n          throw new Error(\n            `Expected to find a threadId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        if (!message.resourceId) {\n          throw new Error(\n            `Expected to find a resourceId for message, but couldn't find one. An unexpected error has occurred.`,\n          );\n        }\n        return {\n          sql: `INSERT INTO \"${TABLE_MESSAGES}\" (id, thread_id, content, role, type, \"createdAt\", \"resourceId\") \n                  VALUES (?, ?, ?, ?, ?, ?, ?)\n                  ON CONFLICT(id) DO UPDATE SET\n                    thread_id=excluded.thread_id,\n                    content=excluded.content,\n                    role=excluded.role,\n                    type=excluded.type,\n                    \"resourceId\"=excluded.\"resourceId\"\n                `,\n          args: [\n            message.id,\n            message.threadId!,\n            typeof message.content === 'object' ? JSON.stringify(message.content) : message.content,\n            message.role,\n            message.type || 'v2',\n            time instanceof Date ? time.toISOString() : time,\n            message.resourceId,\n          ],\n        };\n      });\n\n      const now = new Date().toISOString();\n      batchStatements.push({\n        sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n        args: [now, threadId],\n      });\n\n      // Execute in batches to avoid potential limitations\n      const BATCH_SIZE = 50; // Safe batch size for libsql\n\n      // Separate message statements from thread update\n      const messageStatements = batchStatements.slice(0, -1);\n      const threadUpdateStatement = batchStatements[batchStatements.length - 1];\n\n      // Process message statements in batches\n      for (let i = 0; i < messageStatements.length; i += BATCH_SIZE) {\n        const batch = messageStatements.slice(i, i + BATCH_SIZE);\n        if (batch.length > 0) {\n          await this.client.batch(batch, 'write');\n        }\n      }\n\n      // Execute thread update separately\n      if (threadUpdateStatement) {\n        await this.client.execute(threadUpdateStatement);\n      }\n\n      const list = new MessageList().add(messages, 'memory');\n      if (format === `v2`) return list.get.all.v2();\n      return list.get.all.v1();\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_SAVE_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraMessageV2, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraMessageV2[]> {\n    if (messages.length === 0) {\n      return [];\n    }\n\n    const messageIds = messages.map(m => m.id);\n    const placeholders = messageIds.map(() => '?').join(',');\n\n    const selectSql = `SELECT * FROM ${TABLE_MESSAGES} WHERE id IN (${placeholders})`;\n    const existingResult = await this.client.execute({ sql: selectSql, args: messageIds });\n    const existingMessages: MastraMessageV2[] = existingResult.rows.map(row => this.parseRow(row));\n\n    if (existingMessages.length === 0) {\n      return [];\n    }\n\n    const batchStatements = [];\n    const threadIdsToUpdate = new Set<string>();\n    const columnMapping: Record<string, string> = {\n      threadId: 'thread_id',\n    };\n\n    for (const existingMessage of existingMessages) {\n      const updatePayload = messages.find(m => m.id === existingMessage.id);\n      if (!updatePayload) continue;\n\n      const { id, ...fieldsToUpdate } = updatePayload;\n      if (Object.keys(fieldsToUpdate).length === 0) continue;\n\n      threadIdsToUpdate.add(existingMessage.threadId!);\n      if (updatePayload.threadId && updatePayload.threadId !== existingMessage.threadId) {\n        threadIdsToUpdate.add(updatePayload.threadId);\n      }\n\n      const setClauses = [];\n      const args: InValue[] = [];\n      const updatableFields = { ...fieldsToUpdate };\n\n      // Special handling for the 'content' field to merge instead of overwrite\n      if (updatableFields.content) {\n        const newContent = {\n          ...existingMessage.content,\n          ...updatableFields.content,\n          // Deep merge metadata if it exists on both\n          ...(existingMessage.content?.metadata && updatableFields.content.metadata\n            ? {\n                metadata: {\n                  ...existingMessage.content.metadata,\n                  ...updatableFields.content.metadata,\n                },\n              }\n            : {}),\n        };\n        setClauses.push(`${parseSqlIdentifier('content', 'column name')} = ?`);\n        args.push(JSON.stringify(newContent));\n        delete updatableFields.content;\n      }\n\n      for (const key in updatableFields) {\n        if (Object.prototype.hasOwnProperty.call(updatableFields, key)) {\n          const dbKey = columnMapping[key] || key;\n          setClauses.push(`${parseSqlIdentifier(dbKey, 'column name')} = ?`);\n          let value = updatableFields[key as keyof typeof updatableFields];\n\n          if (typeof value === 'object' && value !== null) {\n            value = JSON.stringify(value);\n          }\n          args.push(value as InValue);\n        }\n      }\n\n      if (setClauses.length === 0) continue;\n\n      args.push(id);\n\n      const sql = `UPDATE ${TABLE_MESSAGES} SET ${setClauses.join(', ')} WHERE id = ?`;\n      batchStatements.push({ sql, args });\n    }\n\n    if (batchStatements.length === 0) {\n      return existingMessages;\n    }\n\n    const now = new Date().toISOString();\n    for (const threadId of threadIdsToUpdate) {\n      if (threadId) {\n        batchStatements.push({\n          sql: `UPDATE ${TABLE_THREADS} SET updatedAt = ? WHERE id = ?`,\n          args: [now, threadId],\n        });\n      }\n    }\n\n    await this.client.batch(batchStatements, 'write');\n\n    const updatedResult = await this.client.execute({ sql: selectSql, args: messageIds });\n    return updatedResult.rows.map(row => this.parseRow(row));\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    try {\n      // Process in batches to avoid SQL parameter limits\n      const BATCH_SIZE = 100;\n      const threadIds = new Set<string>();\n\n      // Use a transaction to ensure consistency\n      const tx = await this.client.transaction('write');\n\n      try {\n        for (let i = 0; i < messageIds.length; i += BATCH_SIZE) {\n          const batch = messageIds.slice(i, i + BATCH_SIZE);\n          const placeholders = batch.map(() => '?').join(',');\n\n          // Get thread IDs for this batch\n          const result = await tx.execute({\n            sql: `SELECT DISTINCT thread_id FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n\n          result.rows?.forEach(row => {\n            if (row.thread_id) threadIds.add(row.thread_id as string);\n          });\n\n          // Delete messages in this batch\n          await tx.execute({\n            sql: `DELETE FROM \"${TABLE_MESSAGES}\" WHERE id IN (${placeholders})`,\n            args: batch,\n          });\n        }\n\n        // Update thread timestamps within the transaction\n        if (threadIds.size > 0) {\n          const now = new Date().toISOString();\n          for (const threadId of threadIds) {\n            await tx.execute({\n              sql: `UPDATE \"${TABLE_THREADS}\" SET \"updatedAt\" = ? WHERE id = ?`,\n              args: [now, threadId],\n            });\n          }\n        }\n\n        // Commit the transaction\n        await tx.commit();\n      } catch (error) {\n        // Rollback on error\n        await tx.rollback();\n        throw error;\n      }\n\n      // TODO: Delete from vector store if semantic recall is enabled\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_DELETE_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: messageIds.join(', ') },\n        },\n        error,\n      );\n    }\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    const result = await this.operations.load<StorageResourceType>({\n      tableName: TABLE_RESOURCES,\n      keys: { id: resourceId },\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      ...result,\n      // Ensure workingMemory is always returned as a string, even if auto-parsed as JSON\n      workingMemory:\n        result.workingMemory && typeof result.workingMemory === 'object'\n          ? JSON.stringify(result.workingMemory)\n          : result.workingMemory,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n      createdAt: new Date(result.createdAt),\n      updatedAt: new Date(result.updatedAt),\n    };\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    console.log('resource', resource);\n    await this.operations.insert({\n      tableName: TABLE_RESOURCES,\n      record: {\n        ...resource,\n        metadata: JSON.stringify(resource.metadata),\n      },\n    });\n\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    const existingResource = await this.getResourceById({ resourceId });\n\n    if (!existingResource) {\n      // Create new resource if it doesn't exist\n      const newResource: StorageResourceType = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n      return this.saveResource({ resource: newResource });\n    }\n\n    const updatedResource = {\n      ...existingResource,\n      workingMemory: workingMemory !== undefined ? workingMemory : existingResource.workingMemory,\n      metadata: {\n        ...existingResource.metadata,\n        ...metadata,\n      },\n      updatedAt: new Date(),\n    };\n\n    const updates: string[] = [];\n    const values: InValue[] = [];\n\n    if (workingMemory !== undefined) {\n      updates.push('workingMemory = ?');\n      values.push(workingMemory);\n    }\n\n    if (metadata) {\n      updates.push('metadata = ?');\n      values.push(JSON.stringify(updatedResource.metadata));\n    }\n\n    updates.push('updatedAt = ?');\n    values.push(updatedResource.updatedAt.toISOString());\n\n    values.push(resourceId);\n\n    await this.client.execute({\n      sql: `UPDATE ${TABLE_RESOURCES} SET ${updates.join(', ')} WHERE id = ?`,\n      args: values,\n    });\n\n    return updatedResource;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    try {\n      const result = await this.operations.load<\n        Omit<StorageThreadType, 'createdAt' | 'updatedAt'> & { createdAt: string; updatedAt: string }\n      >({\n        tableName: TABLE_THREADS,\n        keys: { id: threadId },\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      return {\n        ...result,\n        metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n        createdAt: new Date(result.createdAt),\n        updatedAt: new Date(result.updatedAt),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_THREAD_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * @deprecated use getThreadsByResourceIdPaginated instead for paginated results.\n   */\n  public async getThreadsByResourceId(args: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    const resourceId = args.resourceId;\n    const orderBy = this.castThreadOrderBy(args.orderBy);\n    const sortDirection = this.castThreadSortDirection(args.sortDirection);\n\n    try {\n      const baseQuery = `FROM ${TABLE_THREADS} WHERE resourceId = ?`;\n      const queryParams: InValue[] = [resourceId];\n\n      const mapRowToStorageThreadType = (row: any): StorageThreadType => ({\n        id: row.id as string,\n        resourceId: row.resourceId as string,\n        title: row.title as string,\n        createdAt: new Date(row.createdAt as string), // Convert string to Date\n        updatedAt: new Date(row.updatedAt as string), // Convert string to Date\n        metadata: typeof row.metadata === 'string' ? JSON.parse(row.metadata) : row.metadata,\n      });\n\n      // Non-paginated path\n      const result = await this.client.execute({\n        sql: `SELECT * ${baseQuery} ORDER BY ${orderBy} ${sortDirection}`,\n        args: queryParams,\n      });\n\n      if (!result.rows) {\n        return [];\n      }\n      return result.rows.map(mapRowToStorageThreadType);\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_THREADS_BY_RESOURCE_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { resourceId },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      return [];\n    }\n  }\n\n  public async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    const { resourceId, page = 0, perPage = 100 } = args;\n    const orderBy = this.castThreadOrderBy(args.orderBy);\n    const sortDirection = this.castThreadSortDirection(args.sortDirection);\n\n    try {\n      const baseQuery = `FROM ${TABLE_THREADS} WHERE resourceId = ?`;\n      const queryParams: InValue[] = [resourceId];\n\n      const mapRowToStorageThreadType = (row: any): StorageThreadType => ({\n        id: row.id as string,\n        resourceId: row.resourceId as string,\n        title: row.title as string,\n        createdAt: new Date(row.createdAt as string), // Convert string to Date\n        updatedAt: new Date(row.updatedAt as string), // Convert string to Date\n        metadata: typeof row.metadata === 'string' ? JSON.parse(row.metadata) : row.metadata,\n      });\n\n      const currentOffset = page * perPage;\n\n      const countResult = await this.client.execute({\n        sql: `SELECT COUNT(*) as count ${baseQuery}`,\n        args: queryParams,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          threads: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataResult = await this.client.execute({\n        sql: `SELECT * ${baseQuery} ORDER BY ${orderBy} ${sortDirection} LIMIT ? OFFSET ?`,\n        args: [...queryParams, perPage, currentOffset],\n      });\n\n      const threads = (dataResult.rows || []).map(mapRowToStorageThreadType);\n\n      return {\n        threads,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + threads.length < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_THREADS_BY_RESOURCE_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { resourceId },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      return { threads: [], total: 0, page, perPage, hasMore: false };\n    }\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    try {\n      await this.operations.insert({\n        tableName: TABLE_THREADS,\n        record: {\n          ...thread,\n          metadata: JSON.stringify(thread.metadata),\n        },\n      });\n\n      return thread;\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'LIBSQL_STORE_SAVE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId: thread.id },\n        },\n        error,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n      throw mastraError;\n    }\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const thread = await this.getThreadById({ threadId: id });\n    if (!thread) {\n      throw new MastraError({\n        id: 'LIBSQL_STORE_UPDATE_THREAD_FAILED_THREAD_NOT_FOUND',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread ${id} not found`,\n        details: {\n          status: 404,\n          threadId: id,\n        },\n      });\n    }\n\n    const updatedThread = {\n      ...thread,\n      title,\n      metadata: {\n        ...thread.metadata,\n        ...metadata,\n      },\n    };\n\n    try {\n      await this.client.execute({\n        sql: `UPDATE ${TABLE_THREADS} SET title = ?, metadata = ? WHERE id = ?`,\n        args: [title, JSON.stringify(updatedThread.metadata), id],\n      });\n\n      return updatedThread;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_UPDATE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          text: `Failed to update thread ${id}`,\n          details: { threadId: id },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    // Delete messages for this thread (manual step)\n    try {\n      await this.client.execute({\n        sql: `DELETE FROM ${TABLE_MESSAGES} WHERE thread_id = ?`,\n        args: [threadId],\n      });\n      await this.client.execute({\n        sql: `DELETE FROM ${TABLE_THREADS} WHERE id = ?`,\n        args: [threadId],\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_DELETE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { threadId },\n        },\n        error,\n      );\n    }\n    // TODO: Need to check if CASCADE is enabled so that messages will be automatically deleted due to CASCADE constraint\n  }\n}\n","import type { InValue } from '@libsql/client';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { TABLE_NAMES } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\n\nexport function createExecuteWriteOperationWithRetry({\n  logger,\n  maxRetries,\n  initialBackoffMs,\n}: {\n  logger: IMastraLogger;\n  maxRetries: number;\n  initialBackoffMs: number;\n}) {\n  return async function executeWriteOperationWithRetry<T>(\n    operationFn: () => Promise<T>,\n    operationDescription: string,\n  ): Promise<T> {\n    let retries = 0;\n\n    while (true) {\n      try {\n        return await operationFn();\n      } catch (error: any) {\n        if (\n          error.message &&\n          (error.message.includes('SQLITE_BUSY') || error.message.includes('database is locked')) &&\n          retries < maxRetries\n        ) {\n          retries++;\n          const backoffTime = initialBackoffMs * Math.pow(2, retries - 1);\n          logger.warn(\n            `LibSQLStore: Encountered SQLITE_BUSY during ${operationDescription}. Retrying (${retries}/${maxRetries}) in ${backoffTime}ms...`,\n          );\n          await new Promise(resolve => setTimeout(resolve, backoffTime));\n        } else {\n          logger.error(`LibSQLStore: Error during ${operationDescription} after ${retries} retries: ${error}`);\n          throw error;\n        }\n      }\n    }\n  };\n}\n\nexport function prepareStatement({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): {\n  sql: string;\n  args: InValue[];\n} {\n  const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n  const columns = Object.keys(record).map(col => parseSqlIdentifier(col, 'column name'));\n  const values = Object.values(record).map(v => {\n    if (typeof v === `undefined`) {\n      // returning an undefined value will cause libsql to throw\n      return null;\n    }\n    if (v instanceof Date) {\n      return v.toISOString();\n    }\n    return typeof v === 'object' ? JSON.stringify(v) : v;\n  });\n  const placeholders = values.map(() => '?').join(', ');\n\n  return {\n    sql: `INSERT OR REPLACE INTO ${parsedTableName} (${columns.join(', ')}) VALUES (${placeholders})`,\n    args: values,\n  };\n}\n","import type { Client } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { TABLE_WORKFLOW_SNAPSHOT, StoreOperations } from '@mastra/core/storage';\nimport type { StorageColumn, TABLE_NAMES } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { createExecuteWriteOperationWithRetry, prepareStatement } from '../utils';\n\nexport class StoreOperationsLibSQL extends StoreOperations {\n  private client: Client;\n  /**\n   * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n   * @default 5\n   */\n  maxRetries: number;\n  /**\n   * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n   * The backoff time will double with each retry (exponential backoff).\n   * @default 100\n   */\n  initialBackoffMs: number;\n\n  constructor({\n    client,\n    maxRetries,\n    initialBackoffMs,\n  }: {\n    client: Client;\n    maxRetries?: number;\n    initialBackoffMs?: number;\n  }) {\n    super();\n    this.client = client;\n\n    this.maxRetries = maxRetries ?? 5;\n    this.initialBackoffMs = initialBackoffMs ?? 100;\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    const result = await this.client.execute({\n      sql: `PRAGMA table_info(${table})`,\n    });\n    return (await result.rows)?.some((row: any) => row.name === column);\n  }\n\n  private getCreateTableSQL(tableName: TABLE_NAMES, schema: Record<string, StorageColumn>): string {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    const columns = Object.entries(schema).map(([name, col]) => {\n      const parsedColumnName = parseSqlIdentifier(name, 'column name');\n      let type = col.type.toUpperCase();\n      if (type === 'TEXT') type = 'TEXT';\n      if (type === 'TIMESTAMP') type = 'TEXT'; // Store timestamps as ISO strings\n      // if (type === 'BIGINT') type = 'INTEGER';\n\n      const nullable = col.nullable ? '' : 'NOT NULL';\n      const primaryKey = col.primaryKey ? 'PRIMARY KEY' : '';\n\n      return `${parsedColumnName} ${type} ${nullable} ${primaryKey}`.trim();\n    });\n\n    // For workflow_snapshot table, create a composite primary key\n    if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n      const stmnt = `CREATE TABLE IF NOT EXISTS ${parsedTableName} (\n                    ${columns.join(',\\n')},\n                    PRIMARY KEY (workflow_name, run_id)\n                )`;\n      return stmnt;\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${parsedTableName} (${columns.join(', ')})`;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      this.logger.debug(`Creating database table`, { tableName, operation: 'schema init' });\n      const sql = this.getCreateTableSQL(tableName, schema);\n      await this.client.execute(sql);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_CREATE_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'bigint':\n        return 'INTEGER'; // SQLite uses INTEGER for all integer sizes\n      case 'jsonb':\n        return 'TEXT'; // Store JSON as TEXT in SQLite\n      default:\n        return super.getSqlType(type);\n    }\n  }\n\n  private async doInsert({\n    tableName,\n    record,\n  }: {\n    tableName: TABLE_NAMES;\n    record: Record<string, any>;\n  }): Promise<void> {\n    await this.client.execute(\n      prepareStatement({\n        tableName,\n        record,\n      }),\n    );\n  }\n\n  public insert(args: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    const executeWriteOperationWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    });\n    return executeWriteOperationWithRetry(() => this.doInsert(args), `insert into table ${args.tableName}`);\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    const parsedKeys = Object.keys(keys).map(key => parseSqlIdentifier(key, 'column name'));\n\n    const conditions = parsedKeys.map(key => `${key} = ?`).join(' AND ');\n    const values = Object.values(keys);\n\n    const result = await this.client.execute({\n      sql: `SELECT * FROM ${parsedTableName} WHERE ${conditions} ORDER BY createdAt DESC LIMIT 1`,\n      args: values,\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    // Checks whether the string looks like a JSON object ({}) or array ([])\n    // If the string starts with { or [, it assumes it's JSON and parses it\n    // Otherwise, it just returns, preventing unintended number conversions\n    const parsed = Object.fromEntries(\n      Object.entries(row || {}).map(([k, v]) => {\n        try {\n          return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n        } catch {\n          return [k, v];\n        }\n      }),\n    );\n\n    return parsed as R;\n  }\n\n  private async doBatchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void> {\n    if (records.length === 0) return;\n    const batchStatements = records.map(r => prepareStatement({ tableName, record: r }));\n    await this.client.batch(batchStatements, 'write');\n  }\n\n  public batchInsert(args: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    const executeWriteOperationWithRetry = createExecuteWriteOperationWithRetry({\n      logger: this.logger,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    });\n\n    return executeWriteOperationWithRetry(\n      () => this.doBatchInsert(args),\n      `batch insert into table ${args.tableName}`,\n    ).catch(error => {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_BATCH_INSERT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName: args.tableName,\n          },\n        },\n        error,\n      );\n    });\n  }\n\n  /**\n   * Alters table schema to add columns if they don't exist\n   * @param tableName Name of the table\n   * @param schema Schema of the table\n   * @param ifNotExists Array of column names to add if they don't exist\n   */\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n\n    try {\n      // 1. Get existing columns using PRAGMA\n      const pragmaQuery = `PRAGMA table_info(${parsedTableName})`;\n      const result = await this.client.execute(pragmaQuery);\n      const existingColumnNames = new Set(result.rows.map((row: any) => row.name.toLowerCase()));\n\n      // 2. Add missing columns\n      for (const columnName of ifNotExists) {\n        if (!existingColumnNames.has(columnName.toLowerCase()) && schema[columnName]) {\n          const columnDef = schema[columnName];\n          const sqlType = this.getSqlType(columnDef.type); // ensure this exists or implement\n          const nullable = columnDef.nullable === false ? 'NOT NULL' : '';\n          // In SQLite, you must provide a DEFAULT if adding a NOT NULL column to a non-empty table\n          const defaultValue = columnDef.nullable === false ? this.getDefaultValue(columnDef.type) : '';\n          const alterSql =\n            `ALTER TABLE ${parsedTableName} ADD COLUMN \"${columnName}\" ${sqlType} ${nullable} ${defaultValue}`.trim();\n\n          await this.client.execute(alterSql);\n          this.logger?.debug?.(`Added column ${columnName} to table ${parsedTableName}`);\n        }\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_ALTER_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    try {\n      await this.client.execute(`DELETE FROM ${parsedTableName}`);\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: 'LIBSQL_STORE_CLEAR_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        e,\n      );\n      this.logger?.trackException?.(mastraError);\n      this.logger?.error?.(mastraError.toString());\n    }\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    const parsedTableName = parseSqlIdentifier(tableName, 'table name');\n    try {\n      await this.client.execute(`DROP TABLE IF EXISTS ${parsedTableName}`);\n    } catch (e) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_DROP_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        e,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { ScoreRowData } from '@mastra/core/scores';\nimport { TABLE_SCORERS, ScoresStorage } from '@mastra/core/storage';\nimport type { PaginationInfo, StoragePagination } from '@mastra/core/storage';\nimport type { StoreOperationsLibSQL } from '../operations';\n\nexport class ScoresLibSQL extends ScoresStorage {\n  private operations: StoreOperationsLibSQL;\n  private client: Client;\n  constructor({ client, operations }: { client: Client; operations: StoreOperationsLibSQL }) {\n    super();\n    this.operations = operations;\n    this.client = client;\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const result = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_SCORERS} WHERE runId = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [runId, pagination.perPage + 1, pagination.page * pagination.perPage],\n      });\n      return {\n        scores: result.rows?.slice(0, pagination.perPage).map(row => this.transformScoreRow(row)) ?? [],\n        pagination: {\n          total: result.rows?.length ?? 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: result.rows?.length > pagination.perPage,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_SCORES_BY_RUN_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const conditions: string[] = [];\n      const queryParams: InValue[] = [];\n\n      if (scorerId) {\n        conditions.push(`scorerId = ?`);\n        queryParams.push(scorerId);\n      }\n\n      if (entityId) {\n        conditions.push(`entityId = ?`);\n        queryParams.push(entityId);\n      }\n\n      if (entityType) {\n        conditions.push(`entityType = ?`);\n        queryParams.push(entityType);\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      const result = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_SCORERS} ${whereClause} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [...queryParams, pagination.perPage + 1, pagination.page * pagination.perPage],\n      });\n\n      return {\n        scores: result.rows?.slice(0, pagination.perPage).map(row => this.transformScoreRow(row)) ?? [],\n        pagination: {\n          total: result.rows?.length ?? 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: result.rows?.length > pagination.perPage,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_SCORES_BY_SCORER_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  private transformScoreRow(row: Record<string, any>): ScoreRowData {\n    const scorerValue = JSON.parse(row.scorer ?? '{}');\n    const inputValue = JSON.parse(row.input ?? '{}');\n    const outputValue = JSON.parse(row.output ?? '{}');\n    const additionalLLMContextValue = row.additionalLLMContext ? JSON.parse(row.additionalLLMContext) : null;\n    const runtimeContextValue = row.runtimeContext ? JSON.parse(row.runtimeContext) : null;\n    const metadataValue = row.metadata ? JSON.parse(row.metadata) : null;\n    const entityValue = row.entity ? JSON.parse(row.entity) : null;\n    const preprocessStepResultValue = row.preprocessStepResult ? JSON.parse(row.preprocessStepResult) : null;\n    const analyzeStepResultValue = row.analyzeStepResult ? JSON.parse(row.analyzeStepResult) : null;\n\n    return {\n      id: row.id,\n      traceId: row.traceId,\n      runId: row.runId,\n      scorer: scorerValue,\n      score: row.score,\n      reason: row.reason,\n      preprocessStepResult: preprocessStepResultValue,\n      analyzeStepResult: analyzeStepResultValue,\n      analyzePrompt: row.analyzePrompt,\n      preprocessPrompt: row.preprocessPrompt,\n      generateScorePrompt: row.generateScorePrompt,\n      generateReasonPrompt: row.generateReasonPrompt,\n      metadata: metadataValue,\n      input: inputValue,\n      output: outputValue,\n      additionalContext: additionalLLMContextValue,\n      runtimeContext: runtimeContextValue,\n      entityType: row.entityType,\n      entity: entityValue,\n      entityId: row.entityId,\n      scorerId: row.scorerId,\n      source: row.source,\n      resourceId: row.resourceId,\n      threadId: row.threadId,\n      createdAt: row.createdAt,\n      updatedAt: row.updatedAt,\n    };\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    const result = await this.client.execute({\n      sql: `SELECT * FROM ${TABLE_SCORERS} WHERE id = ?`,\n      args: [id],\n    });\n    return result.rows?.[0] ? this.transformScoreRow(result.rows[0]) : null;\n  }\n\n  async saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }> {\n    try {\n      const id = crypto.randomUUID();\n\n      await this.operations.insert({\n        tableName: TABLE_SCORERS,\n        record: {\n          id,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          ...score,\n        },\n      });\n\n      const scoreFromDb = await this.getScoreById({ id });\n      return { score: scoreFromDb! };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_SAVE_SCORE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const result = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_SCORERS} WHERE entityId = ? AND entityType = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?`,\n        args: [entityId, entityType, pagination.perPage + 1, pagination.page * pagination.perPage],\n      });\n      return {\n        scores: result.rows?.slice(0, pagination.perPage).map(row => this.transformScoreRow(row)) ?? [],\n        pagination: {\n          total: result.rows?.length ?? 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: result.rows?.length > pagination.perPage,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_SCORES_BY_ENTITY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { TABLE_TRACES, TracesStorage, safelyParseJSON } from '@mastra/core/storage';\nimport type { StorageGetTracesArg, StorageGetTracesPaginatedArg, PaginationInfo } from '@mastra/core/storage';\nimport type { Trace } from '@mastra/core/telemetry';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport type { StoreOperationsLibSQL } from '../operations';\n\nexport class TracesLibSQL extends TracesStorage {\n  private client: Client;\n  private operations: StoreOperationsLibSQL;\n\n  constructor({ client, operations }: { client: Client; operations: StoreOperationsLibSQL }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n  }\n\n  async getTraces(args: StorageGetTracesArg): Promise<Trace[]> {\n    if (args.fromDate || args.toDate) {\n      (args as any).dateRange = {\n        start: args.fromDate,\n        end: args.toDate,\n      };\n    }\n    try {\n      const result = await this.getTracesPaginated(args);\n      return result.traces;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_TRACES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    const { name, scope, page = 0, perPage = 100, attributes, filters, dateRange } = args;\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n    const currentOffset = page * perPage;\n\n    const queryArgs: InValue[] = [];\n    const conditions: string[] = [];\n\n    if (name) {\n      conditions.push('name LIKE ?');\n      queryArgs.push(`${name}%`);\n    }\n    if (scope) {\n      conditions.push('scope = ?');\n      queryArgs.push(scope);\n    }\n    if (attributes) {\n      Object.entries(attributes).forEach(([key, value]) => {\n        conditions.push(`json_extract(attributes, '$.${key}') = ?`);\n        queryArgs.push(value);\n      });\n    }\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        conditions.push(`${parseSqlIdentifier(key, 'filter key')} = ?`);\n        queryArgs.push(value);\n      });\n    }\n    if (fromDate) {\n      conditions.push('createdAt >= ?');\n      queryArgs.push(fromDate.toISOString());\n    }\n    if (toDate) {\n      conditions.push('createdAt <= ?');\n      queryArgs.push(toDate.toISOString());\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const countResult = await this.client.execute({\n        sql: `SELECT COUNT(*) as count FROM ${TABLE_TRACES} ${whereClause}`,\n        args: queryArgs,\n      });\n      const total = Number(countResult.rows?.[0]?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          traces: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataResult = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_TRACES} ${whereClause} ORDER BY \"startTime\" DESC LIMIT ? OFFSET ?`,\n        args: [...queryArgs, perPage, currentOffset],\n      });\n\n      const traces =\n        dataResult.rows?.map(\n          row =>\n            ({\n              id: row.id,\n              parentSpanId: row.parentSpanId,\n              traceId: row.traceId,\n              name: row.name,\n              scope: row.scope,\n              kind: row.kind,\n              status: safelyParseJSON(row.status),\n              events: safelyParseJSON(row.events),\n              links: safelyParseJSON(row.links),\n              attributes: safelyParseJSON(row.attributes),\n              startTime: row.startTime,\n              endTime: row.endTime,\n              other: safelyParseJSON(row.other),\n              createdAt: row.createdAt,\n            }) as Trace,\n        ) ?? [];\n\n      return {\n        traces,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + traces.length < total,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_TRACES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchTraceInsert({ records }: { records: Record<string, any>[] }): Promise<void> {\n    this.logger.debug('Batch inserting traces', { count: records.length });\n    await this.operations.batchInsert({\n      tableName: TABLE_TRACES,\n      records,\n    });\n  }\n}\n","import type { Client, InValue } from '@libsql/client';\nimport type { WorkflowRun, WorkflowRuns, WorkflowRunState } from '@mastra/core';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { TABLE_WORKFLOW_SNAPSHOT, WorkflowsStorage } from '@mastra/core/storage';\nimport type { StoreOperationsLibSQL } from '../operations';\n\nfunction parseWorkflowRun(row: Record<string, any>): WorkflowRun {\n  let parsedSnapshot: WorkflowRunState | string = row.snapshot as string;\n  if (typeof parsedSnapshot === 'string') {\n    try {\n      parsedSnapshot = JSON.parse(row.snapshot as string) as WorkflowRunState;\n    } catch (e) {\n      // If parsing fails, return the raw snapshot string\n      console.warn(`Failed to parse snapshot for workflow ${row.workflow_name}: ${e}`);\n    }\n  }\n  return {\n    workflowName: row.workflow_name as string,\n    runId: row.run_id as string,\n    snapshot: parsedSnapshot,\n    resourceId: row.resourceId as string,\n    createdAt: new Date(row.createdAt as string),\n    updatedAt: new Date(row.updatedAt as string),\n  };\n}\n\nexport class WorkflowsLibSQL extends WorkflowsStorage {\n  operations: StoreOperationsLibSQL;\n  client: Client;\n  constructor({ operations, client }: { operations: StoreOperationsLibSQL; client: Client }) {\n    super();\n    this.operations = operations;\n    this.client = client;\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    snapshot: WorkflowRunState;\n  }) {\n    const data = {\n      workflow_name: workflowName,\n      run_id: runId,\n      snapshot,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    this.logger.debug('Persisting workflow snapshot', { workflowName, runId, data });\n    await this.operations.insert({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      record: data,\n    });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const d = await this.operations.load<{ snapshot: WorkflowRunState }>({\n      tableName: TABLE_WORKFLOW_SNAPSHOT,\n      keys: { workflow_name: workflowName, run_id: runId },\n    });\n\n    return d ? d.snapshot : null;\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const conditions: string[] = [];\n    const args: (string | number)[] = [];\n\n    if (runId) {\n      conditions.push('run_id = ?');\n      args.push(runId);\n    }\n\n    if (workflowName) {\n      conditions.push('workflow_name = ?');\n      args.push(workflowName);\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const result = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause}`,\n        args,\n      });\n\n      if (!result.rows?.[0]) {\n        return null;\n      }\n\n      return parseWorkflowRun(result.rows[0]);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_WORKFLOW_RUN_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    try {\n      const conditions: string[] = [];\n      const args: InValue[] = [];\n\n      if (workflowName) {\n        conditions.push('workflow_name = ?');\n        args.push(workflowName);\n      }\n\n      if (fromDate) {\n        conditions.push('createdAt >= ?');\n        args.push(fromDate.toISOString());\n      }\n\n      if (toDate) {\n        conditions.push('createdAt <= ?');\n        args.push(toDate.toISOString());\n      }\n\n      if (resourceId) {\n        const hasResourceId = await this.operations.hasColumn(TABLE_WORKFLOW_SNAPSHOT, 'resourceId');\n        if (hasResourceId) {\n          conditions.push('resourceId = ?');\n          args.push(resourceId);\n        } else {\n          console.warn(`[${TABLE_WORKFLOW_SNAPSHOT}] resourceId column not found. Skipping resourceId filter.`);\n        }\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      let total = 0;\n      // Only get total count when using pagination\n      if (limit !== undefined && offset !== undefined) {\n        const countResult = await this.client.execute({\n          sql: `SELECT COUNT(*) as count FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause}`,\n          args,\n        });\n        total = Number(countResult.rows?.[0]?.count ?? 0);\n      }\n\n      // Get results\n      const result = await this.client.execute({\n        sql: `SELECT * FROM ${TABLE_WORKFLOW_SNAPSHOT} ${whereClause} ORDER BY createdAt DESC${limit !== undefined && offset !== undefined ? ` LIMIT ? OFFSET ?` : ''}`,\n        args: limit !== undefined && offset !== undefined ? [...args, limit, offset] : args,\n      });\n\n      const runs = (result.rows || []).map(row => parseWorkflowRun(row));\n\n      // Use runs.length as total when not paginating\n      return { runs, total: total || runs.length };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'LIBSQL_STORE_GET_WORKFLOW_RUNS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import { createClient } from '@libsql/client';\nimport type { Client } from '@libsql/client';\nimport type { MastraMessageContentV2, MastraMessageV2 } from '@mastra/core/agent';\nimport type { MastraMessageV1, StorageThreadType } from '@mastra/core/memory';\nimport type { ScoreRowData } from '@mastra/core/scores';\nimport { MastraStorage } from '@mastra/core/storage';\nimport type {\n  EvalRow,\n  PaginationArgs,\n  PaginationInfo,\n  StorageColumn,\n  StoragePagination,\n  StorageGetMessagesArg,\n  StorageResourceType,\n  TABLE_NAMES,\n  WorkflowRun,\n  WorkflowRuns,\n  StorageGetTracesArg,\n  StorageDomains,\n  ThreadSortOptions,\n} from '@mastra/core/storage';\n\nimport type { Trace } from '@mastra/core/telemetry';\nimport type { WorkflowRunState } from '@mastra/core/workflows';\nimport { LegacyEvalsLibSQL } from './domains/legacy-evals';\nimport { MemoryLibSQL } from './domains/memory';\nimport { StoreOperationsLibSQL } from './domains/operations';\nimport { ScoresLibSQL } from './domains/scores';\nimport { TracesLibSQL } from './domains/traces';\nimport { WorkflowsLibSQL } from './domains/workflows';\n\nexport type LibSQLConfig =\n  | {\n      url: string;\n      authToken?: string;\n      /**\n       * Maximum number of retries for write operations if an SQLITE_BUSY error occurs.\n       * @default 5\n       */\n      maxRetries?: number;\n      /**\n       * Initial backoff time in milliseconds for retrying write operations on SQLITE_BUSY.\n       * The backoff time will double with each retry (exponential backoff).\n       * @default 100\n       */\n      initialBackoffMs?: number;\n    }\n  | {\n      client: Client;\n      maxRetries?: number;\n      initialBackoffMs?: number;\n    };\n\nexport class LibSQLStore extends MastraStorage {\n  private client: Client;\n  private readonly maxRetries: number;\n  private readonly initialBackoffMs: number;\n\n  stores: StorageDomains;\n\n  constructor(config: LibSQLConfig) {\n    super({ name: `LibSQLStore` });\n\n    this.maxRetries = config.maxRetries ?? 5;\n    this.initialBackoffMs = config.initialBackoffMs ?? 100;\n\n    if ('url' in config) {\n      // need to re-init every time for in memory dbs or the tables might not exist\n      if (config.url.endsWith(':memory:')) {\n        this.shouldCacheInit = false;\n      }\n\n      this.client = createClient({\n        url: config.url,\n        ...(config.authToken ? { authToken: config.authToken } : {}),\n      });\n\n      // Set PRAGMAs for better concurrency, especially for file-based databases\n      if (config.url.startsWith('file:') || config.url.includes(':memory:')) {\n        this.client\n          .execute('PRAGMA journal_mode=WAL;')\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA journal_mode=WAL set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA journal_mode=WAL.', err));\n        this.client\n          .execute('PRAGMA busy_timeout = 5000;') // 5 seconds\n          .then(() => this.logger.debug('LibSQLStore: PRAGMA busy_timeout=5000 set.'))\n          .catch(err => this.logger.warn('LibSQLStore: Failed to set PRAGMA busy_timeout.', err));\n      }\n    } else {\n      this.client = config.client;\n    }\n\n    const operations = new StoreOperationsLibSQL({\n      client: this.client,\n      maxRetries: this.maxRetries,\n      initialBackoffMs: this.initialBackoffMs,\n    });\n\n    const scores = new ScoresLibSQL({ client: this.client, operations });\n    const traces = new TracesLibSQL({ client: this.client, operations });\n    const workflows = new WorkflowsLibSQL({ client: this.client, operations });\n    const memory = new MemoryLibSQL({ client: this.client, operations });\n    const legacyEvals = new LegacyEvalsLibSQL({ client: this.client });\n\n    this.stores = {\n      operations,\n      scores,\n      traces,\n      workflows,\n      memory,\n      legacyEvals,\n    };\n  }\n\n  public get supports() {\n    return {\n      selectByIncludeResourceScope: true,\n      resourceWorkingMemory: true,\n      hasColumn: true,\n      createTable: true,\n      deleteMessages: true,\n    };\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    await this.stores.operations.createTable({ tableName, schema });\n  }\n\n  /**\n   * Alters table schema to add columns if they don't exist\n   * @param tableName Name of the table\n   * @param schema Schema of the table\n   * @param ifNotExists Array of column names to add if they don't exist\n   */\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    await this.stores.operations.alterTable({ tableName, schema, ifNotExists });\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.clearTable({ tableName });\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    await this.stores.operations.dropTable({ tableName });\n  }\n\n  public insert(args: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    return this.stores.operations.insert(args);\n  }\n\n  public batchInsert(args: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    return this.stores.operations.batchInsert(args);\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    return this.stores.operations.load({ tableName, keys });\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.stores.memory.getThreadById({ threadId });\n  }\n\n  /**\n   * @deprecated use getThreadsByResourceIdPaginated instead for paginated results.\n   */\n  public async getThreadsByResourceId(args: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    return this.stores.memory.getThreadsByResourceId(args);\n  }\n\n  public async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    return this.stores.memory.getThreadsByResourceIdPaginated(args);\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    return this.stores.memory.saveThread({ thread });\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    return this.stores.memory.updateThread({ id, title, metadata });\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    return this.stores.memory.deleteThread({ threadId });\n  }\n\n  /**\n   * @deprecated use getMessagesPaginated instead for paginated results.\n   */\n  public async getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  public async getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  public async getMessages({\n    threadId,\n    selectBy,\n    format,\n  }: StorageGetMessagesArg & {\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    return this.stores.memory.getMessages({ threadId, selectBy, format });\n  }\n\n  public async getMessagesPaginated(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }> {\n    return this.stores.memory.getMessagesPaginated(args);\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    return this.stores.memory.saveMessages(args);\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraMessageV2, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraMessageV2[]> {\n    return this.stores.memory.updateMessages({ messages });\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    return this.stores.memory.deleteMessages(messageIds);\n  }\n\n  /** @deprecated use getEvals instead */\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    return this.stores.legacyEvals.getEvalsByAgentName(agentName, type);\n  }\n\n  async getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs = {},\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    return this.stores.legacyEvals.getEvals(options);\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.stores.scores.getScoreById({ id });\n  }\n\n  async saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }> {\n    return this.stores.scores.saveScore(score);\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    scorerId: string;\n    entityId?: string;\n    entityType?: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByScorerId({ scorerId, entityId, entityType, pagination });\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByRunId({ runId, pagination });\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByEntityId({ entityId, entityType, pagination });\n  }\n\n  /**\n   * TRACES\n   */\n\n  /**\n   * @deprecated use getTracesPaginated instead.\n   */\n  async getTraces(args: StorageGetTracesArg): Promise<Trace[]> {\n    return this.stores.traces.getTraces(args);\n  }\n\n  async getTracesPaginated(args: StorageGetTracesArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    return this.stores.traces.getTracesPaginated(args);\n  }\n\n  async batchTraceInsert(args: { records: Record<string, any>[] }): Promise<void> {\n    return this.stores.traces.batchTraceInsert(args);\n  }\n\n  /**\n   * WORKFLOWS\n   */\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    return this.stores.workflows.persistWorkflowSnapshot({ workflowName, runId, snapshot });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    return this.stores.workflows.loadWorkflowSnapshot({ workflowName, runId });\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    return this.stores.workflows.getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId });\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    return this.stores.workflows.getWorkflowRunById({ runId, workflowName });\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    return this.stores.memory.getResourceById({ resourceId });\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    return this.stores.memory.saveResource({ resource });\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    return this.stores.memory.updateResource({ resourceId, workingMemory, metadata });\n  }\n}\n\nexport { LibSQLStore as DefaultStorage };\n","/**\n * Vector store specific prompt that details supported operators and examples.\n * This prompt helps users construct valid filters for LibSQL Vector.\n */\nexport const LIBSQL_PROMPT = `When querying LibSQL Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Direct RegExp patterns will throw an error\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Basic operators handle array values as JSON strings\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$contains\": \"value\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 50 }, \"inStock\": true } } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n"]}