{"version":3,"sources":["../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":[],"mappings":";;;AAKO,IAAM,OAAN,MAKP;AAAA,EACE,EAAA;AAAA,EACA,WAAA;AAAA,EACA,WAAA;AAAA,EACA,YAAA;AAAA,EACA,OAAA;AAAA,EACA,MAAA;AAAA,EAEA,YAAY,IAAA,EAAmD;AAC7D,IAAA,IAAA,CAAK,KAAK,IAAA,CAAK,EAAA;AACf,IAAA,IAAA,CAAK,cAAc,IAAA,CAAK,WAAA;AACxB,IAAA,IAAA,CAAK,cAAc,IAAA,CAAK,WAAA;AACxB,IAAA,IAAA,CAAK,eAAe,IAAA,CAAK,YAAA;AACzB,IAAA,IAAA,CAAK,UAAU,IAAA,CAAK,OAAA;AACpB,IAAA,IAAA,CAAK,SAAS,IAAA,CAAK,MAAA;AAAA,EACrB;AACF;AAEO,SAAS,WAUd,IAAA,EASwC;AACxC,EAAA,OAAO,IAAI,KAAK,IAAI,CAAA;AACtB;;;ACxCO,SAAS,aAAa,IAAA,EAA0C;AAErE,EAAA,OAAO,CAAC,EAAE,IAAA,IAAQ,EAAE,IAAA,YAAgB,SAAS,YAAA,IAAgB,IAAA,CAAA;AAC/D","file":"chunk-H65GI7JY.cjs","sourcesContent":["import type { z } from 'zod';\n\nimport type { Mastra } from '../mastra';\nimport type { ToolAction, ToolExecutionContext } from './types';\n\nexport class Tool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n> implements ToolAction<TSchemaIn, TSchemaOut, TContext>\n{\n  id: string;\n  description: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'];\n  mastra?: Mastra;\n\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TContext>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.execute = opts.execute;\n    this.mastra = opts.mastra;\n  }\n}\n\nexport function createTool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n  TExecute extends ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'] = ToolAction<\n    TSchemaIn,\n    TSchemaOut,\n    TContext\n  >['execute'],\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TContext> & {\n    execute?: TExecute;\n  },\n): [TSchemaIn, TSchemaOut, TExecute] extends [z.ZodSchema, z.ZodSchema, Function]\n  ? Tool<TSchemaIn, TSchemaOut, TContext> & {\n      inputSchema: TSchemaIn;\n      outputSchema: TSchemaOut;\n      execute: (context: TContext) => Promise<any>;\n    }\n  : Tool<TSchemaIn, TSchemaOut, TContext> {\n  return new Tool(opts) as any;\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !!(tool && !(tool instanceof Tool) && 'parameters' in tool);\n}\n"]}