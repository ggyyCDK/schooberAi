{"version":3,"sources":["../src/agent/message-list/prompt/attachments-to-parts.ts","../src/agent/message-list/prompt/convert-to-mastra-v1.ts","../src/agent/message-list/prompt/data-content.ts","../src/agent/message-list/index.ts"],"names":["processBlock","content","toolInvocations","i","z","convertUint8ArrayToBase64","convertToCoreMessages","uiMessage","MastraError","randomUUID","isUiMessage","isCoreMessage"],"mappings":"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","file":"chunk-OFZZZ22B.cjs","sourcesContent":["import type { Attachment } from '@ai-sdk/ui-utils';\nimport type { FilePart, ImagePart, TextPart } from 'ai';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url.toString(), mimeType: attachment.contentType });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error('If the attachment is not an image, it must specify a content type');\n          }\n\n          parts.push({\n            type: 'file',\n            data: url.toString(),\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: attachment.url,\n            mimeType: attachment.contentType,\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'file',\n            data: attachment.url,\n            mimeType: attachment.contentType,\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error('If the attachment is not an image or text, it must specify a content type');\n          }\n\n          parts.push({\n            type: 'file',\n            data: attachment.url,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n","/**\n * This file is an adaptation of https://github.com/vercel/ai/blob/e14c066bf4d02c5ee2180c56a01fa0e5216bc582/packages/ai/core/prompt/convert-to-core-messages.ts\n * But has been modified to work with Mastra storage adapter messages (MastraMessageV1)\n */\nimport type { AssistantContent, ToolResultPart } from 'ai';\nimport type { MastraMessageV1 } from '../../../memory/types';\nimport type { MastraMessageContentV2, MastraMessageV2 } from '../../message-list';\nimport { attachmentsToParts } from './attachments-to-parts';\n\nconst makePushOrCombine = (v1Messages: MastraMessageV1[]) => {\n  // Track how many times each ID has been used to create unique IDs for split messages\n  const idUsageCount = new Map<string, number>();\n\n  // Pattern to detect if an ID already has our split suffix\n  const SPLIT_SUFFIX_PATTERN = /__split-\\d+$/;\n\n  return (msg: MastraMessageV1) => {\n    const previousMessage = v1Messages.at(-1);\n    if (\n      msg.role === previousMessage?.role &&\n      Array.isArray(previousMessage.content) &&\n      Array.isArray(msg.content) &&\n      // we were creating new messages for tool calls before and not appending to the assistant message\n      // so don't append here so everything works as before\n      (msg.role !== `assistant` || (msg.role === `assistant` && msg.content.at(-1)?.type !== `tool-call`))\n    ) {\n      for (const part of msg.content) {\n        // @ts-ignore needs type gymnastics? msg.content and previousMessage.content are the same type here since both are arrays\n        // I'm not sure what's adding `never` to the union but this code definitely works..\n        previousMessage.content.push(part);\n      }\n    } else {\n      // When pushing a new message, check if we need to deduplicate the ID\n      let baseId = msg.id;\n\n      // Check if this ID already has a split suffix and extract the base ID\n      const hasSplitSuffix = SPLIT_SUFFIX_PATTERN.test(baseId);\n      if (hasSplitSuffix) {\n        // This ID already has a split suffix, don't add another one\n        v1Messages.push(msg);\n        return;\n      }\n\n      const currentCount = idUsageCount.get(baseId) || 0;\n\n      // If we've seen this ID before, append our unique split suffix\n      if (currentCount > 0) {\n        msg.id = `${baseId}__split-${currentCount}`;\n      }\n\n      // Increment the usage count for this base ID\n      idUsageCount.set(baseId, currentCount + 1);\n\n      v1Messages.push(msg);\n    }\n  };\n};\nexport function convertToV1Messages(messages: Array<MastraMessageV2>) {\n  const v1Messages: MastraMessageV1[] = [];\n  const pushOrCombine = makePushOrCombine(v1Messages);\n\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    if (!message?.content) continue;\n    const { content, experimental_attachments: inputAttachments = [], parts: inputParts } = message.content;\n    const { role } = message;\n\n    const fields = {\n      id: message.id,\n      createdAt: message.createdAt,\n      resourceId: message.resourceId!,\n      threadId: message.threadId!,\n    };\n\n    const experimental_attachments = [...inputAttachments];\n    const parts: typeof inputParts = [];\n    for (const part of inputParts) {\n      if (part.type === 'file') {\n        experimental_attachments.push({\n          url: part.data,\n          contentType: part.mimeType,\n        });\n      } else {\n        parts.push(part);\n      }\n    }\n\n    switch (role) {\n      case 'user': {\n        if (parts == null) {\n          const userContent = experimental_attachments\n            ? [{ type: 'text', text: content || '' }, ...attachmentsToParts(experimental_attachments)]\n            : { type: 'text', text: content || '' };\n          pushOrCombine({\n            role: 'user',\n            ...fields,\n            type: 'text',\n            // @ts-ignore\n            content: userContent,\n          });\n        } else {\n          const textParts = message.content.parts\n            .filter(part => part.type === 'text')\n            .map(part => ({\n              type: 'text' as const,\n              text: part.text,\n            }));\n\n          const userContent = experimental_attachments\n            ? [...textParts, ...attachmentsToParts(experimental_attachments)]\n            : textParts;\n          pushOrCombine({\n            role: 'user',\n            ...fields,\n            type: 'text',\n            content:\n              Array.isArray(userContent) &&\n              userContent.length === 1 &&\n              userContent[0]?.type === `text` &&\n              typeof content !== `undefined`\n                ? content\n                : userContent,\n          });\n        }\n        break;\n      }\n\n      case 'assistant': {\n        if (message.content.parts != null) {\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block: MastraMessageContentV2['parts'] = [];\n\n          function processBlock() {\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              switch (part.type) {\n                case 'file':\n                case 'text': {\n                  content.push(part);\n                  break;\n                }\n                case 'reasoning': {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case 'text':\n                        content.push({\n                          type: 'reasoning' as const,\n                          text: detail.text,\n                          signature: detail.signature,\n                        });\n                        break;\n                      case 'redacted':\n                        content.push({\n                          type: 'redacted-reasoning' as const,\n                          data: detail.data,\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case 'tool-invocation':\n                  // Skip updateWorkingMemory tool calls as they should not be visible in history\n                  if (part.toolInvocation.toolName !== 'updateWorkingMemory') {\n                    content.push({\n                      type: 'tool-call' as const,\n                      toolCallId: part.toolInvocation.toolCallId,\n                      toolName: part.toolInvocation.toolName,\n                      args: part.toolInvocation.args,\n                    });\n                  }\n                  break;\n              }\n            }\n\n            pushOrCombine({\n              role: 'assistant',\n              ...fields,\n              type: content.some(c => c.type === `tool-call`) ? 'tool-call' : 'text',\n              // content: content,\n              content:\n                typeof content !== `string` &&\n                Array.isArray(content) &&\n                content.length === 1 &&\n                content[0]?.type === `text`\n                  ? message?.content?.content || content\n                  : content,\n            });\n\n            // check if there are tool invocations with results in the block\n            const stepInvocations = block\n              .filter(part => `type` in part && part.type === 'tool-invocation')\n              .map(part => part.toolInvocation)\n              .filter(ti => ti.toolName !== 'updateWorkingMemory');\n\n            // Only create tool-result message if there are actual results\n            const invocationsWithResults = stepInvocations.filter(ti => ti.state === 'result' && 'result' in ti);\n\n            if (invocationsWithResults.length > 0) {\n              pushOrCombine({\n                role: 'tool',\n                ...fields,\n                type: 'tool-result',\n                content: invocationsWithResults.map((toolInvocation): ToolResultPart => {\n                  const { toolCallId, toolName, result } = toolInvocation;\n                  return {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result,\n                  };\n                }),\n              });\n            }\n\n            // updates for next block\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          }\n\n          for (const part of message.content.parts) {\n            switch (part.type) {\n              case 'text': {\n                if (blockHasToolInvocations) {\n                  processBlock(); // text must come after tool invocations\n                }\n                block.push(part);\n                break;\n              }\n              case 'file':\n              case 'reasoning': {\n                block.push(part);\n                break;\n              }\n              case 'tool-invocation': {\n                // If we have non-tool content (text/file/reasoning) in the block, process it first\n                const hasNonToolContent = block.some(\n                  p => p.type === 'text' || p.type === 'file' || p.type === 'reasoning',\n                );\n                if (hasNonToolContent || (part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n\n          processBlock();\n\n          // Check if there are toolInvocations that weren't processed from parts\n          const toolInvocations = message.content.toolInvocations;\n          if (toolInvocations && toolInvocations.length > 0) {\n            // Find tool invocations that weren't already processed from parts\n            const processedToolCallIds = new Set<string>();\n            for (const part of message.content.parts) {\n              if (part.type === 'tool-invocation' && part.toolInvocation.toolCallId) {\n                processedToolCallIds.add(part.toolInvocation.toolCallId);\n              }\n            }\n\n            const unprocessedToolInvocations = toolInvocations.filter(\n              ti => !processedToolCallIds.has(ti.toolCallId) && ti.toolName !== 'updateWorkingMemory',\n            );\n\n            if (unprocessedToolInvocations.length > 0) {\n              // Group by step, handling undefined steps\n              const invocationsByStep = new Map<number, typeof unprocessedToolInvocations>();\n\n              for (const inv of unprocessedToolInvocations) {\n                const step = inv.step ?? 0;\n                if (!invocationsByStep.has(step)) {\n                  invocationsByStep.set(step, []);\n                }\n                invocationsByStep.get(step)!.push(inv);\n              }\n\n              // Process each step\n              const sortedSteps = Array.from(invocationsByStep.keys()).sort((a, b) => a - b);\n\n              for (const step of sortedSteps) {\n                const stepInvocations = invocationsByStep.get(step)!;\n\n                // Create tool-call message for all invocations (calls and results)\n                pushOrCombine({\n                  role: 'assistant',\n                  ...fields,\n                  type: 'tool-call',\n                  content: [\n                    ...stepInvocations.map(({ toolCallId, toolName, args }) => ({\n                      type: 'tool-call' as const,\n                      toolCallId,\n                      toolName,\n                      args,\n                    })),\n                  ],\n                });\n\n                // Only create tool-result message if there are actual results\n                const invocationsWithResults = stepInvocations.filter(ti => ti.state === 'result' && 'result' in ti);\n\n                if (invocationsWithResults.length > 0) {\n                  pushOrCombine({\n                    role: 'tool',\n                    ...fields,\n                    type: 'tool-result',\n                    content: invocationsWithResults.map((toolInvocation): ToolResultPart => {\n                      const { toolCallId, toolName, result } = toolInvocation;\n                      return {\n                        type: 'tool-result',\n                        toolCallId,\n                        toolName,\n                        result,\n                      };\n                    }),\n                  });\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n        const toolInvocations = message.content.toolInvocations;\n\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          pushOrCombine({ role: 'assistant', ...fields, content: content || '', type: 'text' });\n          break;\n        }\n\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n\n        for (let i = 0; i <= maxStep; i++) {\n          const stepInvocations = toolInvocations.filter(\n            toolInvocation => (toolInvocation.step ?? 0) === i && toolInvocation.toolName !== 'updateWorkingMemory',\n          );\n\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n\n          // assistant message with tool calls\n          pushOrCombine({\n            role: 'assistant',\n            ...fields,\n            type: 'tool-call',\n            content: [\n              ...(isLastMessage && content && i === 0 ? [{ type: 'text' as const, text: content }] : []),\n              ...stepInvocations.map(({ toolCallId, toolName, args }) => ({\n                type: 'tool-call' as const,\n                toolCallId,\n                toolName,\n                args,\n              })),\n            ],\n          });\n\n          // Only create tool-result message if there are actual results\n          const invocationsWithResults = stepInvocations.filter(ti => ti.state === 'result' && 'result' in ti);\n\n          if (invocationsWithResults.length > 0) {\n            pushOrCombine({\n              role: 'tool',\n              ...fields,\n              type: 'tool-result',\n              content: invocationsWithResults.map((toolInvocation): ToolResultPart => {\n                const { toolCallId, toolName, result } = toolInvocation;\n                return {\n                  type: 'tool-result',\n                  toolCallId,\n                  toolName,\n                  result,\n                };\n              }),\n            });\n          }\n        }\n\n        if (content && !isLastMessage) {\n          pushOrCombine({ role: 'assistant', ...fields, type: 'text', content: content || '' });\n        }\n\n        break;\n      }\n    }\n  }\n\n  return v1Messages;\n}\n","import { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer => globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n","import { randomUUID } from 'crypto';\nimport { convertToCoreMessages } from 'ai';\nimport type { CoreMessage, CoreSystemMessage, IDGenerator, Message, ToolInvocation, UIMessage } from 'ai';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../../error';\nimport type { MastraMessageV1 } from '../../memory';\nimport { isCoreMessage, isUiMessage } from '../../utils';\nimport { convertToV1Messages } from './prompt/convert-to-mastra-v1';\nimport { convertDataContentToBase64String } from './prompt/data-content';\n\nexport type MastraMessageContentV2 = {\n  format: 2; // format 2 === UIMessage in AI SDK v4\n  // TODO: When we bump to AI SDK v5 and make \"format: 3\" we might need to inline these types with a copy/paste\n  parts: UIMessage['parts'];\n  experimental_attachments?: UIMessage['experimental_attachments'];\n  content?: UIMessage['content'];\n  toolInvocations?: UIMessage['toolInvocations'];\n  reasoning?: UIMessage['reasoning'];\n  annotations?: UIMessage['annotations'];\n  metadata?: Record<string, unknown>;\n};\n\nexport type MastraMessageV2 = {\n  id: string;\n  content: MastraMessageContentV2;\n  role: 'user' | 'assistant';\n  createdAt: Date;\n  threadId?: string;\n  resourceId?: string;\n  type?: string;\n};\n\n// Extend UIMessage to include optional metadata field\nexport type UIMessageWithMetadata = UIMessage & {\n  metadata?: Record<string, unknown>;\n};\n\nexport type MessageInput =\n  | UIMessage\n  | UIMessageWithMetadata\n  | Message\n  | MastraMessageV1\n  | CoreMessage\n  | MastraMessageV2;\ntype MessageSource = 'memory' | 'response' | 'user' | 'system' | 'context';\ntype MemoryInfo = { threadId: string; resourceId?: string };\n\nexport class MessageList {\n  private messages: MastraMessageV2[] = [];\n\n  // passed in by dev in input or context\n  private systemMessages: CoreSystemMessage[] = [];\n  // passed in by us for a specific purpose, eg memory system message\n  private taggedSystemMessages: Record<string, CoreSystemMessage[]> = {};\n\n  private memoryInfo: null | MemoryInfo = null;\n\n  // used to filter this.messages by how it was added: input/response/memory\n  private memoryMessages = new Set<MastraMessageV2>();\n  private newUserMessages = new Set<MastraMessageV2>();\n  private newResponseMessages = new Set<MastraMessageV2>();\n  private userContextMessages = new Set<MastraMessageV2>();\n\n  private memoryMessagesPersisted = new Set<MastraMessageV2>();\n  private newUserMessagesPersisted = new Set<MastraMessageV2>();\n  private newResponseMessagesPersisted = new Set<MastraMessageV2>();\n  private userContextMessagesPersisted = new Set<MastraMessageV2>();\n\n  private generateMessageId?: IDGenerator;\n  private _agentNetworkAppend = false;\n\n  constructor({\n    threadId,\n    resourceId,\n    generateMessageId,\n    // @ts-ignore Flag for agent network messages\n    _agentNetworkAppend,\n  }: { threadId?: string; resourceId?: string; generateMessageId?: IDGenerator } = {}) {\n    if (threadId) {\n      this.memoryInfo = { threadId, resourceId };\n    }\n    this.generateMessageId = generateMessageId;\n    this._agentNetworkAppend = _agentNetworkAppend || false;\n  }\n\n  public add(messages: string | string[] | MessageInput | MessageInput[], messageSource: MessageSource) {\n    if (!messages) return this;\n    for (const message of Array.isArray(messages) ? messages : [messages]) {\n      this.addOne(\n        typeof message === `string`\n          ? {\n              role: 'user',\n              content: message,\n            }\n          : message,\n        messageSource,\n      );\n    }\n    return this;\n  }\n  public getLatestUserContent(): string | null {\n    const currentUserMessages = this.all.core().filter(m => m.role === 'user');\n    const content = currentUserMessages.at(-1)?.content;\n    if (!content) return null;\n    return MessageList.coreContentToString(content);\n  }\n  public get get() {\n    return {\n      all: this.all,\n      remembered: this.remembered,\n      input: this.input,\n      response: this.response,\n    };\n  }\n  public get getPersisted() {\n    return {\n      remembered: this.rememberedPersisted,\n      input: this.inputPersisted,\n      taggedSystemMessages: this.taggedSystemMessages,\n      response: this.responsePersisted,\n    };\n  }\n  public get clear() {\n    return {\n      input: {\n        v2: () => {\n          const userMessages = Array.from(this.newUserMessages);\n          this.messages = this.messages.filter(m => !this.newUserMessages.has(m));\n          this.newUserMessages.clear();\n          return userMessages;\n        },\n      },\n    };\n  }\n  private all = {\n    v2: () => this.messages,\n    v1: () => convertToV1Messages(this.messages),\n    ui: () => this.messages.map(MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.all.ui()),\n    prompt: () => {\n      const coreMessages = this.all.core();\n\n      // Some LLM providers will throw an error if the first message is a tool call.\n\n      const messages = [...this.systemMessages, ...Object.values(this.taggedSystemMessages).flat(), ...coreMessages];\n\n      const needsDefaultUserMessage = !messages.length || messages[0]?.role === 'assistant';\n\n      if (needsDefaultUserMessage) {\n        const defaultMessage: CoreMessage = {\n          role: 'user',\n          content: '.',\n        };\n\n        messages.unshift(defaultMessage);\n      }\n\n      return messages;\n    },\n  };\n  private remembered = {\n    v2: () => this.messages.filter(m => this.memoryMessages.has(m)),\n    v1: () => convertToV1Messages(this.remembered.v2()),\n    ui: () => this.remembered.v2().map(MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.remembered.ui()),\n  };\n  private rememberedPersisted = {\n    v2: () => this.messages.filter(m => this.memoryMessagesPersisted.has(m)),\n    v1: () => convertToV1Messages(this.rememberedPersisted.v2()),\n    ui: () => this.rememberedPersisted.v2().map(MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.rememberedPersisted.ui()),\n  };\n  private input = {\n    v2: () => this.messages.filter(m => this.newUserMessages.has(m)),\n    v1: () => convertToV1Messages(this.input.v2()),\n    ui: () => this.input.v2().map(MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.input.ui()),\n  };\n  private inputPersisted = {\n    v2: () => this.messages.filter(m => this.newUserMessagesPersisted.has(m)),\n    v1: () => convertToV1Messages(this.inputPersisted.v2()),\n    ui: () => this.inputPersisted.v2().map(MessageList.toUIMessage),\n    core: () => this.convertToCoreMessages(this.inputPersisted.ui()),\n  };\n  private response = {\n    v2: () => this.messages.filter(m => this.newResponseMessages.has(m)),\n  };\n  private responsePersisted = {\n    v2: () => this.messages.filter(m => this.newResponseMessagesPersisted.has(m)),\n    ui: () => this.responsePersisted.v2().map(MessageList.toUIMessage),\n  };\n  public drainUnsavedMessages(): MastraMessageV2[] {\n    const messages = this.messages.filter(m => this.newUserMessages.has(m) || this.newResponseMessages.has(m));\n    this.newUserMessages.clear();\n    this.newResponseMessages.clear();\n    return messages;\n  }\n  public getEarliestUnsavedMessageTimestamp(): number | undefined {\n    const unsavedMessages = this.messages.filter(m => this.newUserMessages.has(m) || this.newResponseMessages.has(m));\n    if (unsavedMessages.length === 0) return undefined;\n    // Find the earliest createdAt among unsaved messages\n    return Math.min(...unsavedMessages.map(m => new Date(m.createdAt).getTime()));\n  }\n\n  public getSystemMessages(tag?: string): CoreMessage[] {\n    if (tag) {\n      return this.taggedSystemMessages[tag] || [];\n    }\n    return this.systemMessages;\n  }\n  public addSystem(messages: CoreSystemMessage | CoreSystemMessage[] | string | string[] | null, tag?: string) {\n    if (!messages) return this;\n    for (const message of Array.isArray(messages) ? messages : [messages]) {\n      this.addOneSystem(message, tag);\n    }\n    return this;\n  }\n\n  private convertToCoreMessages(messages: UIMessage[]): CoreMessage[] {\n    return convertToCoreMessages(this.sanitizeUIMessages(messages));\n  }\n  private sanitizeUIMessages(messages: UIMessage[]): UIMessage[] {\n    const msgs = messages\n      .map(m => {\n        if (m.parts.length === 0) return false;\n        const safeParts = m.parts.filter(\n          p =>\n            p.type !== `tool-invocation` ||\n            // calls and partial-calls should be updated to be results at this point\n            // if they haven't we can't send them back to the llm and need to remove them.\n            (p.toolInvocation.state !== `call` && p.toolInvocation.state !== `partial-call`),\n        );\n\n        // fully remove this message if it has an empty parts array after stripping out incomplete tool calls.\n        if (!safeParts.length) return false;\n\n        const sanitized = {\n          ...m,\n          parts: safeParts,\n        };\n\n        // ensure toolInvocations are also updated to only show results\n        if (`toolInvocations` in m && m.toolInvocations) {\n          sanitized.toolInvocations = m.toolInvocations.filter(t => t.state === `result`);\n        }\n\n        return sanitized;\n      })\n      .filter((m): m is UIMessage => Boolean(m));\n    return msgs;\n  }\n  private addOneSystem(message: CoreSystemMessage | string, tag?: string) {\n    if (typeof message === `string`) message = { role: 'system', content: message };\n    if (tag && !this.isDuplicateSystem(message, tag)) {\n      this.taggedSystemMessages[tag] ||= [];\n      this.taggedSystemMessages[tag].push(message);\n    } else if (!this.isDuplicateSystem(message)) {\n      this.systemMessages.push(message);\n    }\n  }\n  private isDuplicateSystem(message: CoreSystemMessage, tag?: string) {\n    if (tag) {\n      if (!this.taggedSystemMessages[tag]) return false;\n      return this.taggedSystemMessages[tag].some(\n        m => MessageList.cacheKeyFromContent(m.content) === MessageList.cacheKeyFromContent(message.content),\n      );\n    }\n    return this.systemMessages.some(\n      m => MessageList.cacheKeyFromContent(m.content) === MessageList.cacheKeyFromContent(message.content),\n    );\n  }\n  private static toUIMessage(m: MastraMessageV2): UIMessageWithMetadata {\n    const experimentalAttachments: UIMessage['experimental_attachments'] = m.content.experimental_attachments\n      ? [...m.content.experimental_attachments]\n      : [];\n    const contentString =\n      typeof m.content.content === `string` && m.content.content !== ''\n        ? m.content.content\n        : m.content.parts.reduce((prev, part) => {\n            if (part.type === `text`) {\n              // return only the last text part like AI SDK does\n              return part.text;\n            }\n            return prev;\n          }, '');\n\n    const parts: MastraMessageContentV2['parts'] = [];\n    if (m.content.parts.length) {\n      for (const part of m.content.parts) {\n        if (part.type === `file`) {\n          experimentalAttachments.push({\n            contentType: part.mimeType,\n            url: part.data,\n          });\n        } else if (\n          part.type === 'tool-invocation' &&\n          (part.toolInvocation.state === 'call' || part.toolInvocation.state === 'partial-call')\n        ) {\n          // Filter out tool invocations with call or partial-call states\n          continue;\n        } else {\n          parts.push(part);\n        }\n      }\n    }\n\n    if (parts.length === 0 && experimentalAttachments.length > 0) {\n      // make sure we have atleast one part so this message doesn't get removed when converting to core message\n      parts.push({ type: 'text', text: '' });\n    }\n\n    if (m.role === `user`) {\n      const uiMessage: UIMessageWithMetadata = {\n        id: m.id,\n        role: m.role,\n        content: m.content.content || contentString,\n        createdAt: m.createdAt,\n        parts,\n        experimental_attachments: experimentalAttachments,\n      };\n      // Preserve metadata if present\n      if (m.content.metadata) {\n        uiMessage.metadata = m.content.metadata;\n      }\n      return uiMessage;\n    } else if (m.role === `assistant`) {\n      const uiMessage: UIMessageWithMetadata = {\n        id: m.id,\n        role: m.role,\n        content: m.content.content || contentString,\n        createdAt: m.createdAt,\n        parts,\n        reasoning: undefined,\n        toolInvocations:\n          `toolInvocations` in m.content ? m.content.toolInvocations?.filter(t => t.state === 'result') : undefined,\n      };\n      // Preserve metadata if present\n      if (m.content.metadata) {\n        uiMessage.metadata = m.content.metadata;\n      }\n      return uiMessage;\n    }\n\n    const uiMessage: UIMessageWithMetadata = {\n      id: m.id,\n      role: m.role,\n      content: m.content.content || contentString,\n      createdAt: m.createdAt,\n      parts,\n      experimental_attachments: experimentalAttachments,\n    };\n    // Preserve metadata if present\n    if (m.content.metadata) {\n      uiMessage.metadata = m.content.metadata;\n    }\n    return uiMessage;\n  }\n  private getMessageById(id: string) {\n    return this.messages.find(m => m.id === id);\n  }\n  private shouldReplaceMessage(message: MastraMessageV2): { exists: boolean; shouldReplace?: boolean; id?: string } {\n    if (!this.messages.length) return { exists: false };\n\n    if (!(`id` in message) || !message?.id) {\n      return { exists: false };\n    }\n\n    const existingMessage = this.getMessageById(message.id);\n    if (!existingMessage) return { exists: false };\n\n    return {\n      exists: true,\n      shouldReplace: !MessageList.messagesAreEqual(existingMessage, message),\n      id: existingMessage.id,\n    };\n  }\n  private addOne(message: MessageInput, messageSource: MessageSource) {\n    if (\n      (!(`content` in message) ||\n        (!message.content &&\n          // allow empty strings\n          typeof message.content !== 'string')) &&\n      (!(`parts` in message) || !message.parts)\n    ) {\n      throw new MastraError({\n        id: 'INVALID_MESSAGE_CONTENT',\n        domain: ErrorDomain.AGENT,\n        category: ErrorCategory.USER,\n        text: `Message with role \"${message.role}\" must have either a 'content' property (string or array) or a 'parts' property (array) that is not empty, null, or undefined. Received message: ${JSON.stringify(message, null, 2)}`,\n        details: {\n          role: message.role as string,\n          messageSource,\n          hasContent: 'content' in message,\n          hasParts: 'parts' in message,\n        },\n      });\n    }\n\n    if (message.role === `system` && MessageList.isVercelCoreMessage(message)) return this.addSystem(message);\n    if (message.role === `system`) {\n      throw new MastraError({\n        id: 'INVALID_SYSTEM_MESSAGE_FORMAT',\n        domain: ErrorDomain.AGENT,\n        category: ErrorCategory.USER,\n        text: `Invalid system message format. System messages must be CoreMessage format with 'role' and 'content' properties. The content should be a string or valid content array.`,\n        details: {\n          messageSource,\n          receivedMessage: JSON.stringify(message, null, 2),\n        },\n      });\n    }\n\n    const messageV2 = this.inputToMastraMessageV2(message, messageSource);\n\n    const { exists, shouldReplace, id } = this.shouldReplaceMessage(messageV2);\n\n    const latestMessage = this.messages.at(-1);\n\n    if (messageSource === `memory`) {\n      for (const existingMessage of this.messages) {\n        // don't double store any messages\n        if (MessageList.messagesAreEqual(existingMessage, messageV2)) {\n          return;\n        }\n      }\n    }\n    // If the last message is an assistant message and the new message is also an assistant message, merge them together and update tool calls with results\n    const shouldAppendToLastAssistantMessage =\n      latestMessage?.role === 'assistant' &&\n      messageV2.role === 'assistant' &&\n      latestMessage.threadId === messageV2.threadId &&\n      // If the message is from memory, don't append to the last assistant message\n      messageSource !== 'memory';\n    // This flag is for agent network messages. We should change the agent network formatting and remove this flag after.\n    const appendNetworkMessage =\n      (this._agentNetworkAppend && latestMessage && !this.memoryMessages.has(latestMessage)) ||\n      !this._agentNetworkAppend;\n    if (shouldAppendToLastAssistantMessage && appendNetworkMessage) {\n      latestMessage.createdAt = messageV2.createdAt || latestMessage.createdAt;\n\n      // Used for mapping indexes for messageV2 parts to corresponding indexes in latestMessage\n      const toolResultAnchorMap = new Map<number, number>();\n      const partsToAdd = new Map<number, MastraMessageContentV2['parts'][number]>();\n\n      for (const [index, part] of messageV2.content.parts.entries()) {\n        // If the incoming part is a tool-invocation result, find the corresponding call in the latest message\n        if (part.type === 'tool-invocation') {\n          const existingCallPart = [...latestMessage.content.parts]\n            .reverse()\n            .find(p => p.type === 'tool-invocation' && p.toolInvocation.toolCallId === part.toolInvocation.toolCallId);\n\n          const existingCallToolInvocation = !!existingCallPart && existingCallPart.type === 'tool-invocation';\n\n          if (existingCallToolInvocation) {\n            if (part.toolInvocation.state === 'result') {\n              // Update the existing tool-call part with the result\n              existingCallPart.toolInvocation = {\n                ...existingCallPart.toolInvocation,\n                step: part.toolInvocation.step,\n                state: 'result',\n                result: part.toolInvocation.result,\n                args: {\n                  ...existingCallPart.toolInvocation.args,\n                  ...part.toolInvocation.args,\n                },\n              };\n              if (!latestMessage.content.toolInvocations) {\n                latestMessage.content.toolInvocations = [];\n              }\n              const toolInvocationIndex = latestMessage.content.toolInvocations.findIndex(\n                t => t.toolCallId === existingCallPart.toolInvocation.toolCallId,\n              );\n              if (toolInvocationIndex === -1) {\n                latestMessage.content.toolInvocations.push(existingCallPart.toolInvocation);\n              } else {\n                latestMessage.content.toolInvocations[toolInvocationIndex] = existingCallPart.toolInvocation;\n              }\n            }\n            // Map the index of the tool call in messageV2 to the index of the tool call in latestMessage\n            const existingIndex = latestMessage.content.parts.findIndex(p => p === existingCallPart);\n            toolResultAnchorMap.set(index, existingIndex);\n            // Otherwise we do nothing, as we're not updating the tool call\n          } else {\n            partsToAdd.set(index, part);\n          }\n        } else {\n          partsToAdd.set(index, part);\n        }\n      }\n      this.addPartsToLatestMessage({\n        latestMessage,\n        messageV2,\n        anchorMap: toolResultAnchorMap,\n        partsToAdd,\n      });\n      if (latestMessage.createdAt.getTime() < messageV2.createdAt.getTime()) {\n        latestMessage.createdAt = messageV2.createdAt;\n      }\n      if (!latestMessage.content.content && messageV2.content.content) {\n        latestMessage.content.content = messageV2.content.content;\n      }\n      if (\n        latestMessage.content.content &&\n        messageV2.content.content &&\n        latestMessage.content.content !== messageV2.content.content\n      ) {\n        // Match what AI SDK does - content string is always the latest text part.\n        latestMessage.content.content = messageV2.content.content;\n      }\n\n      // If latest message gets appended to, it should be added to the proper source\n      this.pushMessageToSource(latestMessage, messageSource);\n    }\n    // Else the last message and this message are not both assistant messages OR an existing message has been updated and should be replaced. add a new message to the array or update an existing one.\n    else {\n      let existingIndex = -1;\n      if (shouldReplace) {\n        existingIndex = this.messages.findIndex(m => m.id === id);\n      }\n      const existingMessage = existingIndex !== -1 && this.messages[existingIndex];\n\n      if (shouldReplace && existingMessage) {\n        this.messages[existingIndex] = messageV2;\n      } else if (!exists) {\n        this.messages.push(messageV2);\n      }\n\n      this.pushMessageToSource(messageV2, messageSource);\n    }\n\n    // make sure messages are always stored in order of when they were created!\n    this.messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n    return this;\n  }\n\n  private pushMessageToSource(messageV2: MastraMessageV2, messageSource: MessageSource) {\n    if (messageSource === `memory`) {\n      this.memoryMessages.add(messageV2);\n      this.memoryMessagesPersisted.add(messageV2);\n    } else if (messageSource === `response`) {\n      this.newResponseMessages.add(messageV2);\n      this.newResponseMessagesPersisted.add(messageV2);\n    } else if (messageSource === `user`) {\n      this.newUserMessages.add(messageV2);\n      this.newUserMessagesPersisted.add(messageV2);\n    } else if (messageSource === `context`) {\n      this.userContextMessages.add(messageV2);\n      this.userContextMessagesPersisted.add(messageV2);\n    } else {\n      throw new Error(`Missing message source for message ${messageV2}`);\n    }\n  }\n\n  /**\n   * Pushes a new message part to the latest message.\n   * @param latestMessage - The latest message to push the part to.\n   * @param newMessage - The new message to push the part from.\n   * @param part - The part to push.\n   * @param insertAt - The index at which to insert the part. Optional.\n   */\n  private pushNewMessagePart({\n    latestMessage,\n    newMessage,\n    part,\n    insertAt, // optional\n  }: {\n    latestMessage: MastraMessageV2;\n    newMessage: MastraMessageV2;\n    part: MastraMessageContentV2['parts'][number];\n    insertAt?: number;\n  }) {\n    const partKey = MessageList.cacheKeyFromParts([part]);\n    const latestPartCount = latestMessage.content.parts.filter(\n      p => MessageList.cacheKeyFromParts([p]) === partKey,\n    ).length;\n    const newPartCount = newMessage.content.parts.filter(p => MessageList.cacheKeyFromParts([p]) === partKey).length;\n    // If the number of parts in the latest message is less than the number of parts in the new message, insert the part\n    if (latestPartCount < newPartCount) {\n      if (typeof insertAt === 'number') {\n        latestMessage.content.parts.splice(insertAt, 0, part);\n      } else {\n        latestMessage.content.parts.push(part);\n      }\n    }\n  }\n\n  /**\n   * Upserts parts of messageV2 into latestMessage based on the anchorMap.\n   * This is used when appending a message to the last assistant message to ensure that parts are inserted in the correct order.\n   * @param latestMessage - The latest message to upsert parts into.\n   * @param messageV2 - The message to upsert parts from.\n   * @param anchorMap - The anchor map to use for upserting parts.\n   */\n  private addPartsToLatestMessage({\n    latestMessage,\n    messageV2,\n    anchorMap,\n    partsToAdd,\n  }: {\n    latestMessage: MastraMessageV2;\n    messageV2: MastraMessageV2;\n    anchorMap: Map<number, number>;\n    partsToAdd: Map<number, MastraMessageContentV2['parts'][number]>;\n  }) {\n    // Walk through messageV2, inserting any part not present at the canonical position\n    for (let i = 0; i < messageV2.content.parts.length; ++i) {\n      const part = messageV2.content.parts[i];\n      if (!part) continue;\n      const key = MessageList.cacheKeyFromParts([part]);\n      const partToAdd = partsToAdd.get(i);\n      if (!key || !partToAdd) continue;\n      if (anchorMap.size > 0) {\n        if (anchorMap.has(i)) continue; // skip anchors\n        // Find left anchor in messageV2\n        const leftAnchorV2 = [...anchorMap.keys()].filter(idx => idx < i).pop() ?? -1;\n        // Find right anchor in messageV2\n        const rightAnchorV2 = [...anchorMap.keys()].find(idx => idx > i) ?? -1;\n\n        // Map to latestMessage\n        const leftAnchorLatest = leftAnchorV2 !== -1 ? anchorMap.get(leftAnchorV2)! : 0;\n\n        // Compute offset from anchor\n        const offset = leftAnchorV2 === -1 ? i : i - leftAnchorV2;\n\n        // Insert at proportional position\n        const insertAt = leftAnchorLatest + offset;\n\n        const rightAnchorLatest =\n          rightAnchorV2 !== -1 ? anchorMap.get(rightAnchorV2)! : latestMessage.content.parts.length;\n\n        if (\n          insertAt >= 0 &&\n          insertAt <= rightAnchorLatest &&\n          !latestMessage.content.parts\n            .slice(insertAt, rightAnchorLatest)\n            .some(p => MessageList.cacheKeyFromParts([p]) === MessageList.cacheKeyFromParts([part]))\n        ) {\n          this.pushNewMessagePart({\n            latestMessage,\n            newMessage: messageV2,\n            part,\n            insertAt,\n          });\n          for (const [v2Idx, latestIdx] of anchorMap.entries()) {\n            if (latestIdx >= insertAt) {\n              anchorMap.set(v2Idx, latestIdx + 1);\n            }\n          }\n        }\n      } else {\n        this.pushNewMessagePart({\n          latestMessage,\n          newMessage: messageV2,\n          part,\n        });\n      }\n    }\n  }\n\n  private inputToMastraMessageV2(message: MessageInput, messageSource: MessageSource): MastraMessageV2 {\n    if (\n      // we can't throw if the threadId doesn't match and this message came from memory\n      // this is because per-user semantic recall can retrieve messages from other threads\n      messageSource !== `memory` &&\n      `threadId` in message &&\n      message.threadId &&\n      this.memoryInfo &&\n      message.threadId !== this.memoryInfo.threadId\n    ) {\n      throw new Error(\n        `Received input message with wrong threadId. Input ${message.threadId}, expected ${this.memoryInfo.threadId}`,\n      );\n    }\n\n    if (\n      `resourceId` in message &&\n      message.resourceId &&\n      this.memoryInfo?.resourceId &&\n      message.resourceId !== this.memoryInfo.resourceId\n    ) {\n      throw new Error(\n        `Received input message with wrong resourceId. Input ${message.resourceId}, expected ${this.memoryInfo.resourceId}`,\n      );\n    }\n\n    if (MessageList.isMastraMessageV1(message)) {\n      return this.mastraMessageV1ToMastraMessageV2(message, messageSource);\n    }\n    if (MessageList.isMastraMessageV2(message)) {\n      return this.hydrateMastraMessageV2Fields(message);\n    }\n    if (MessageList.isVercelCoreMessage(message)) {\n      return this.vercelCoreMessageToMastraMessageV2(message, messageSource);\n    }\n    if (MessageList.isVercelUIMessage(message)) {\n      return this.vercelUIMessageToMastraMessageV2(message, messageSource);\n    }\n\n    throw new Error(`Found unhandled message ${JSON.stringify(message)}`);\n  }\n\n  private lastCreatedAt?: number;\n  // this makes sure messages added in order will always have a date atleast 1ms apart.\n  private generateCreatedAt(messageSource: MessageSource, start?: Date | number): Date {\n    start = start instanceof Date ? start : start ? new Date(start) : undefined;\n\n    if (start && !this.lastCreatedAt) {\n      this.lastCreatedAt = start.getTime();\n      return start;\n    }\n\n    if (start && messageSource === `memory`) {\n      // we don't want to modify start time if the message came from memory or we may accidentally re-order old messages\n      return start;\n    }\n\n    const now = new Date();\n    const nowTime = start?.getTime() || now.getTime();\n    // find the latest createdAt in all stored messages\n    const lastTime = this.messages.reduce((p, m) => {\n      if (m.createdAt.getTime() > p) return m.createdAt.getTime();\n      return p;\n    }, this.lastCreatedAt || 0);\n\n    // make sure our new message is created later than the latest known message time\n    // it's expected that messages are added to the list in order if they don't have a createdAt date on them\n    if (nowTime <= lastTime) {\n      const newDate = new Date(lastTime + 1);\n      this.lastCreatedAt = newDate.getTime();\n      return newDate;\n    }\n\n    this.lastCreatedAt = nowTime;\n    return now;\n  }\n\n  private newMessageId(): string {\n    if (this.generateMessageId) {\n      return this.generateMessageId();\n    }\n    return randomUUID();\n  }\n\n  private mastraMessageV1ToMastraMessageV2(message: MastraMessageV1, messageSource: MessageSource): MastraMessageV2 {\n    const coreV2 = this.vercelCoreMessageToMastraMessageV2(\n      {\n        content: message.content,\n        role: message.role,\n      } as CoreMessage,\n      messageSource,\n    );\n\n    return {\n      id: message.id,\n      role: coreV2.role,\n      createdAt: this.generateCreatedAt(messageSource, message.createdAt),\n      threadId: message.threadId,\n      resourceId: message.resourceId,\n      content: coreV2.content,\n    };\n  }\n  private hydrateMastraMessageV2Fields(message: MastraMessageV2): MastraMessageV2 {\n    if (!(message.createdAt instanceof Date)) message.createdAt = new Date(message.createdAt);\n    return message;\n  }\n  private vercelUIMessageToMastraMessageV2(\n    message: UIMessage | UIMessageWithMetadata,\n    messageSource: MessageSource,\n  ): MastraMessageV2 {\n    const content: MastraMessageContentV2 = {\n      format: 2,\n      parts: message.parts,\n    };\n\n    if (message.toolInvocations) content.toolInvocations = message.toolInvocations;\n    if (message.reasoning) content.reasoning = message.reasoning;\n    if (message.annotations) content.annotations = message.annotations;\n    if (message.experimental_attachments) {\n      content.experimental_attachments = message.experimental_attachments;\n    }\n\n    // Preserve metadata field if present\n    if ('metadata' in message && message.metadata !== null && message.metadata !== undefined) {\n      content.metadata = message.metadata as Record<string, unknown>;\n    }\n\n    return {\n      id: message.id || this.newMessageId(),\n      role: MessageList.getRole(message),\n      createdAt: this.generateCreatedAt(messageSource, message.createdAt),\n      threadId: this.memoryInfo?.threadId,\n      resourceId: this.memoryInfo?.resourceId,\n      content,\n    } satisfies MastraMessageV2;\n  }\n  private vercelCoreMessageToMastraMessageV2(coreMessage: CoreMessage, messageSource: MessageSource): MastraMessageV2 {\n    const id = `id` in coreMessage ? (coreMessage.id as string) : this.newMessageId();\n    const parts: UIMessage['parts'] = [];\n    const experimentalAttachments: UIMessage['experimental_attachments'] = [];\n    const toolInvocations: ToolInvocation[] = [];\n\n    if (typeof coreMessage.content === 'string') {\n      parts.push({ type: 'step-start' });\n      parts.push({\n        type: 'text',\n        text: coreMessage.content,\n      });\n    } else if (Array.isArray(coreMessage.content)) {\n      for (const part of coreMessage.content) {\n        switch (part.type) {\n          case 'text':\n            parts.push({\n              type: 'text',\n              text: part.text,\n            });\n            break;\n\n          case 'tool-call':\n            parts.push({\n              type: 'tool-invocation',\n              toolInvocation: {\n                state: 'call',\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                args: part.args,\n              },\n            });\n            break;\n\n          case 'tool-result':\n            const invocation = {\n              state: 'result' as const,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              result: part.result ?? '', // undefined will cause AI SDK to throw an error, but for client side tool calls this really could be undefined\n              args: {}, // when we combine this invocation onto the existing tool-call part it will have args already\n            };\n            parts.push({\n              type: 'tool-invocation',\n              toolInvocation: invocation,\n            });\n            toolInvocations.push(invocation);\n            break;\n\n          case 'reasoning':\n            parts.push({\n              type: 'reasoning',\n              reasoning: '', // leave this blank so we aren't double storing it in the db along with details\n              details: [{ type: 'text', text: part.text, signature: part.signature }],\n            });\n            break;\n          case 'redacted-reasoning':\n            parts.push({\n              type: 'reasoning',\n              reasoning: '', // No text reasoning for redacted parts\n              details: [{ type: 'redacted', data: part.data }],\n            });\n            break;\n          case 'image':\n            parts.push({ type: 'file', data: part.image.toString(), mimeType: part.mimeType! });\n            break;\n          case 'file':\n            // CoreMessage file parts can have mimeType and data (binary/data URL) or just a URL\n            if (part.data instanceof URL) {\n              parts.push({\n                type: 'file',\n                data: part.data.toString(),\n                mimeType: part.mimeType,\n              });\n            } else {\n              // If it's binary data, convert to base64 and add to parts\n              try {\n                parts.push({\n                  type: 'file',\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data),\n                });\n              } catch (error) {\n                console.error(`Failed to convert binary data to base64 in CoreMessage file part: ${error}`, error);\n              }\n            }\n            break;\n        }\n      }\n    }\n\n    const content: MastraMessageV2['content'] = {\n      format: 2,\n      parts,\n    };\n\n    if (toolInvocations.length) content.toolInvocations = toolInvocations;\n    if (typeof coreMessage.content === `string`) content.content = coreMessage.content;\n    if (experimentalAttachments.length) content.experimental_attachments = experimentalAttachments;\n\n    return {\n      id,\n      role: MessageList.getRole(coreMessage),\n      createdAt: this.generateCreatedAt(messageSource),\n      threadId: this.memoryInfo?.threadId,\n      resourceId: this.memoryInfo?.resourceId,\n      content,\n    };\n  }\n\n  static isVercelUIMessage(msg: MessageInput): msg is UIMessage | UIMessageWithMetadata {\n    return !MessageList.isMastraMessage(msg) && isUiMessage(msg);\n  }\n  static isVercelCoreMessage(msg: MessageInput): msg is CoreMessage {\n    return !MessageList.isMastraMessage(msg) && isCoreMessage(msg);\n  }\n  static isMastraMessage(msg: MessageInput): msg is MastraMessageV2 | MastraMessageV1 {\n    return MessageList.isMastraMessageV2(msg) || MessageList.isMastraMessageV1(msg);\n  }\n  static isMastraMessageV1(msg: MessageInput): msg is MastraMessageV1 {\n    return !MessageList.isMastraMessageV2(msg) && (`threadId` in msg || `resourceId` in msg);\n  }\n  static isMastraMessageV2(msg: MessageInput): msg is MastraMessageV2 {\n    return Boolean(\n      msg.content &&\n        !Array.isArray(msg.content) &&\n        typeof msg.content !== `string` &&\n        // any newly saved Mastra message v2 shape will have content: { format: 2 }\n        `format` in msg.content &&\n        msg.content.format === 2,\n    );\n  }\n  private static getRole(message: MessageInput): MastraMessageV2['role'] {\n    if (message.role === `assistant` || message.role === `tool`) return `assistant`;\n    if (message.role === `user`) return `user`;\n    // TODO: how should we handle data role?\n    throw new Error(\n      `BUG: add handling for message role ${message.role} in message ${JSON.stringify(message, null, 2)}`,\n    );\n  }\n  private static cacheKeyFromParts(parts: UIMessage['parts']): string {\n    let key = ``;\n    for (const part of parts) {\n      key += part.type;\n      if (part.type === `text`) {\n        // TODO: we may need to hash this with something like xxhash instead of using length\n        // for 99.999% of cases this will be fine though because we're comparing messages that have the same ID already.\n        key += `${part.text.length}${part.text}`;\n      }\n      if (part.type === `tool-invocation`) {\n        key += part.toolInvocation.toolCallId;\n        key += part.toolInvocation.state;\n      }\n      if (part.type === `reasoning`) {\n        // TODO: we may need to hash this with something like xxhash instead of using length\n        // for 99.999% of cases this will be fine though because we're comparing messages that have the same ID already.\n        key += part.reasoning.length;\n        key += part.details.reduce((prev, current) => {\n          if (current.type === `text`) {\n            return prev + current.text.length + (current.signature?.length || 0);\n          }\n          return prev;\n        }, 0);\n      }\n      if (part.type === `file`) {\n        // TODO: we may need to hash this with something like xxhash instead of using length\n        // for 99.999% of cases this will be fine though because we're comparing messages that have the same ID already.\n        key += part.data.length;\n        key += part.mimeType;\n      }\n    }\n    return key;\n  }\n  private static coreContentToString(content: CoreMessage['content']): string {\n    if (typeof content === `string`) return content;\n\n    return content.reduce((p, c) => {\n      if (c.type === `text`) {\n        p += c.text;\n      }\n      return p;\n    }, '');\n  }\n  private static cacheKeyFromContent(content: CoreMessage['content']): string {\n    if (typeof content === `string`) return content;\n    let key = ``;\n    for (const part of content) {\n      key += part.type;\n      if (part.type === `text`) {\n        key += part.text.length;\n      }\n      if (part.type === `reasoning`) {\n        key += part.text.length;\n      }\n      if (part.type === `tool-call`) {\n        key += part.toolCallId;\n        key += part.toolName;\n      }\n      if (part.type === `tool-result`) {\n        key += part.toolCallId;\n        key += part.toolName;\n      }\n      if (part.type === `file`) {\n        key += part.filename;\n        key += part.mimeType;\n      }\n      if (part.type === `image`) {\n        key += part.image instanceof URL ? part.image.toString() : part.image.toString().length;\n        key += part.mimeType;\n      }\n      if (part.type === `redacted-reasoning`) {\n        key += part.data.length;\n      }\n    }\n    return key;\n  }\n  private static messagesAreEqual(one: MessageInput, two: MessageInput) {\n    const oneUI = MessageList.isVercelUIMessage(one) && one;\n    const twoUI = MessageList.isVercelUIMessage(two) && two;\n    if (oneUI && !twoUI) return false;\n    if (oneUI && twoUI) {\n      return MessageList.cacheKeyFromParts(one.parts) === MessageList.cacheKeyFromParts(two.parts);\n    }\n\n    const oneCM = MessageList.isVercelCoreMessage(one) && one;\n    const twoCM = MessageList.isVercelCoreMessage(two) && two;\n    if (oneCM && !twoCM) return false;\n    if (oneCM && twoCM) {\n      return MessageList.cacheKeyFromContent(oneCM.content) === MessageList.cacheKeyFromContent(twoCM.content);\n    }\n\n    const oneMM1 = MessageList.isMastraMessageV1(one) && one;\n    const twoMM1 = MessageList.isMastraMessageV1(two) && two;\n    if (oneMM1 && !twoMM1) return false;\n    if (oneMM1 && twoMM1) {\n      return (\n        oneMM1.id === twoMM1.id &&\n        MessageList.cacheKeyFromContent(oneMM1.content) === MessageList.cacheKeyFromContent(twoMM1.content)\n      );\n    }\n\n    const oneMM2 = MessageList.isMastraMessageV2(one) && one;\n    const twoMM2 = MessageList.isMastraMessageV2(two) && two;\n    if (oneMM2 && !twoMM2) return false;\n    if (oneMM2 && twoMM2) {\n      return (\n        oneMM2.id === twoMM2.id &&\n        MessageList.cacheKeyFromParts(oneMM2.content.parts) === MessageList.cacheKeyFromParts(twoMM2.content.parts)\n      );\n    }\n\n    // default to it did change. we'll likely never reach this codepath\n    return true;\n  }\n}\n"]}