{"version":3,"sources":["../../src/network/network.ts"],"names":["MastraBase","RegisteredLogger","Agent","createTool","z","agent","MastraError"],"mappings":"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","file":"index.cjs","sourcesContent":["import type {\n  CoreMessage,\n  GenerateObjectResult,\n  GenerateTextResult,\n  LanguageModelV1,\n  StreamObjectResult,\n  StreamTextResult,\n} from 'ai';\nimport type { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport type { ZodSchema } from 'zod';\n\nimport { Agent } from '../agent';\nimport type { AgentGenerateOptions, AgentStreamOptions, AiMessageType } from '../agent';\nimport { MastraBase } from '../base';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\n\nimport type { GenerateReturn } from '../llm/model/base.types';\nimport { RegisteredLogger } from '../logger';\nimport type { Mastra } from '../mastra';\nimport type { RuntimeContext } from '../runtime-context';\nimport { createTool } from '../tools';\nimport type { ToolAction } from '../tools';\nimport type { AgentNetworkConfig } from './types';\n\nexport class AgentNetwork extends MastraBase {\n  #instructions: string;\n  #agents: Agent[];\n  #model: LanguageModelV1;\n  #routingAgent: Agent;\n  #agentHistory: Record<\n    string,\n    Array<{\n      input: string;\n      output: string;\n      timestamp: string;\n    }>\n  > = {};\n\n  constructor(config: AgentNetworkConfig) {\n    super({ component: RegisteredLogger.NETWORK, name: config.name || 'AgentNetwork' });\n\n    this.#instructions = config.instructions;\n    this.#agents = config.agents;\n    this.#model = config.model;\n\n    this.#routingAgent = new Agent({\n      name: config.name,\n      instructions: this.getInstructions(),\n      model: this.#model,\n      tools: this.getTools() as Record<string, ToolAction>,\n    });\n  }\n\n  formatAgentId(name: string) {\n    return name.replace(/[^a-zA-Z0-9_-]/g, '_');\n  }\n\n  getTools() {\n    return {\n      transmit: createTool({\n        id: 'transmit',\n        description: 'Call one or more specialized agents to handle specific tasks',\n        inputSchema: z.object({\n          actions: z.array(\n            z.object({\n              agent: z.string().describe('The name of the agent to call'),\n              input: z.string().describe('The input to pass to the agent'),\n              includeHistory: z\n                .boolean()\n                .optional()\n                .describe('Whether to include previous agent outputs in the context'),\n            }),\n          ),\n        }),\n        execute: async ({ context, runtimeContext }) => {\n          try {\n            // Extract the actions from the context\n            const actions = context.actions;\n\n            this.logger.debug(`Executing ${actions.length} specialized agents`);\n\n            // Execute each agent in parallel and collect results\n            const results = await Promise.all(\n              actions.map(action =>\n                this.executeAgent(\n                  action.agent,\n                  [{ role: 'user', content: action.input }],\n                  action.includeHistory,\n                  runtimeContext,\n                ),\n              ),\n            );\n\n            this.logger.debug('Results:', { results });\n\n            // Store the results in the agent history for future reference\n            actions.forEach((action, index) => {\n              this.#addToAgentHistory(action.agent, {\n                input: action.input,\n                output: results[index] || '', // Ensure output is always a string\n              });\n            });\n\n            // Format the results with agent names for clarity\n            return actions.map((action, index) => `[${action.agent}]: ${results[index]}`).join('\\n\\n');\n          } catch (err) {\n            // Properly type the error\n            const error = err as Error;\n            this.logger.error('Error in transmit tool:', { error });\n            return `Error executing agents: ${error.message}`;\n          }\n        },\n      }),\n    } as const;\n  }\n\n  #addToAgentHistory(agentId: string, interaction: { input: string; output: string }) {\n    if (!this.#agentHistory[agentId]) {\n      this.#agentHistory[agentId] = [];\n    }\n    // Add timestamp to the interaction\n    this.#agentHistory[agentId].push({\n      ...interaction,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  getAgentHistory(agentId: string) {\n    return this.#agentHistory[agentId] || [];\n  }\n\n  #clearNetworkHistoryBeforeRun() {\n    this.#agentHistory = {};\n  }\n\n  /**\n   * Get the history of all agent interactions that have occurred in this network\n   * @returns A record of agent interactions, keyed by agent ID\n   */\n  getAgentInteractionHistory() {\n    return { ...this.#agentHistory };\n  }\n\n  /**\n   * Get a summary of agent interactions in a more readable format, displayed chronologically\n   * @returns A formatted string with all agent interactions in chronological order\n   */\n  getAgentInteractionSummary() {\n    const history = this.#agentHistory;\n    const agentIds = Object.keys(history);\n\n    if (agentIds.length === 0) {\n      return 'No agent interactions have occurred yet.';\n    }\n\n    // Collect all interactions with their agent IDs\n    const allInteractions: Array<{\n      agentId: string;\n      interaction: { input: string; output: string; timestamp: string };\n      index: number;\n      // We'll use a global sequence number to track the true chronological order\n      sequence: number;\n    }> = [];\n\n    // Track the global sequence of interactions\n    let globalSequence = 0;\n\n    // Gather all interactions with their source agent\n    agentIds.forEach(agentId => {\n      const interactions = history[agentId] || [];\n      interactions.forEach((interaction, index) => {\n        allInteractions.push({\n          agentId,\n          interaction,\n          index,\n          // Assign a sequence number based on when it was added to the history\n          sequence: globalSequence++,\n        });\n      });\n    });\n\n    // Sort by timestamp for true chronological order\n    allInteractions.sort((a, b) => {\n      // Compare timestamps if available\n      if (a.interaction.timestamp && b.interaction.timestamp) {\n        return new Date(a.interaction.timestamp).getTime() - new Date(b.interaction.timestamp).getTime();\n      }\n      // Fall back to sequence number if timestamps aren't available\n      return a.sequence - b.sequence;\n    });\n\n    // Format the chronological summary\n    if (allInteractions.length === 0) {\n      return 'No agent interactions have occurred yet.';\n    }\n\n    return (\n      '# Chronological Agent Interactions\\n\\n' +\n      allInteractions\n        .map(\n          (item, i) =>\n            `## Step ${i + 1}: Agent ${item.agentId} at ${item.interaction.timestamp}\\n` +\n            `**Input:** ${item.interaction.input.substring(0, 100)}${item.interaction.input.length > 100 ? '...' : ''}\\n\\n` +\n            `**Output:** ${item.interaction.output.substring(0, 100)}${item.interaction.output.length > 100 ? '...' : ''}`,\n        )\n        .join('\\n\\n')\n    );\n  }\n\n  async executeAgent(agentId: string, input: CoreMessage[], includeHistory = false, runtimeContext?: RuntimeContext) {\n    try {\n      // Find the agent by its formatted ID\n      const agent = this.#agents.find(agent => this.formatAgentId(agent.name) === agentId);\n\n      if (!agent) {\n        const error = new MastraError({\n          id: 'AGENT_NETWORK_EXECUTE_UNKNOWN_AGENT',\n          domain: ErrorDomain.AGENT_NETWORK,\n          category: ErrorCategory.USER,\n          text: `Agent \"${agentId}\" not found.`,\n        });\n        this.logger.trackException?.(error);\n        throw error;\n      }\n\n      // If requested, include relevant history from other agents\n      let messagesWithContext = [...input];\n\n      if (includeHistory) {\n        // Get all agent histories\n        const allHistory = Object.entries(this.#agentHistory);\n\n        if (allHistory.length > 0) {\n          // Add a system message with the context from other agents\n          const contextMessage = {\n            role: 'system' as const,\n            content: `Previous agent interactions:\\n\\n${allHistory\n              .map(([agentName, interactions]) => {\n                return `## ${agentName}\\n${interactions\n                  .map(\n                    (interaction, i) =>\n                      `Interaction ${i + 1} (${interaction.timestamp || 'No timestamp'}):\\n- Input: ${interaction.input}\\n- Output: ${interaction.output}`,\n                  )\n                  .join('\\n\\n')}`;\n              })\n              .join('\\n\\n')}`,\n          };\n\n          // Add the context message before the user input\n          messagesWithContext = [contextMessage, ...messagesWithContext];\n        }\n      }\n\n      // Generate a response from the agent\n      const result = await agent.generate(messagesWithContext, { runtimeContext });\n\n      return result.text;\n    } catch (err) {\n      // Properly type the error\n      const error = err as Error;\n      this.logger.error(`Error executing agent \"${agentId}\":`, { error });\n      return `Unable to execute agent \"${agentId}\": ${error.message}`;\n    }\n  }\n\n  getInstructions() {\n    // Create a formatted list of available agents with their names\n    const agentList = this.#agents\n      .map(agent => {\n        const id = this.formatAgentId(agent.name);\n        // Use agent name instead of description since description might not exist\n        return ` - **${id}**: ${agent.name}`;\n      })\n      .join('\\n');\n\n    return `\n            You are a router in a network of specialized AI agents. \n            Your job is to decide which agent should handle each step of a task.\n            \n            ## System Instructions\n            ${this.#instructions}\n            \n            ## Available Specialized Agents\n            You can call these agents using the \"transmit\" tool:\n            ${agentList}\n            \n            ## How to Use the \"transmit\" Tool\n            \n            The \"transmit\" tool allows you to call one or more specialized agents.\n            \n            ### Single Agent Call\n            To call a single agent, use this format:\n            \\`\\`\\`json\n            {\n              \"actions\": [\n                {\n                  \"agent\": \"agent_name\",\n                  \"input\": \"detailed instructions for the agent\"\n                }\n              ]\n            }\n            \\`\\`\\`\n            \n            ### Multiple Parallel Agent Calls\n            To call multiple agents in parallel, use this format:\n            \\`\\`\\`json\n            {\n              \"actions\": [\n                {\n                  \"agent\": \"first_agent_name\",\n                  \"input\": \"detailed instructions for the first agent\"\n                },\n                {\n                  \"agent\": \"second_agent_name\",\n                  \"input\": \"detailed instructions for the second agent\"\n                }\n              ]\n            }\n            \\`\\`\\`\n            \n            ## Context Sharing\n            \n            When calling an agent, you can choose to include the output from previous agents in the context.\n            This allows the agent to take into account the results from previous steps.\n            \n            To include context, add the \"includeHistory\" field to the action and set it to true:\n            \\`\\`\\`json\n            {\n              \"actions\": [\n                {\n                  \"agent\": \"agent_name\",\n                  \"input\": \"detailed instructions for the agent\",\n                  \"includeHistory\": true\n                }\n              ]\n            }\n            \\`\\`\\`\n            \n            ## Best Practices\n            1. Break down complex tasks into smaller steps\n            2. Choose the most appropriate agent for each step\n            3. Provide clear, detailed instructions to each agent\n            4. Synthesize the results from multiple agents when needed\n            5. Provide a final summary or answer to the user\n            \n            ## Workflow\n            1. Analyze the user's request\n            2. Identify which specialized agent(s) can help\n            3. Call the appropriate agent(s) using the transmit tool\n            4. Review the agent's response\n            5. Either call more agents or provide a final answer\n        `;\n  }\n\n  getRoutingAgent() {\n    return this.#routingAgent;\n  }\n\n  getAgents() {\n    return this.#agents;\n  }\n\n  async generate(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentGenerateOptions<undefined, undefined> & { output?: never; experimental_output?: never },\n  ): Promise<GenerateTextResult<any, undefined>>;\n  async generate<OUTPUT extends ZodSchema | JSONSchema7>(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentGenerateOptions<OUTPUT, undefined> & { output?: OUTPUT; experimental_output?: never },\n  ): Promise<GenerateObjectResult<OUTPUT>>;\n  async generate<EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7>(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentGenerateOptions<undefined, EXPERIMENTAL_OUTPUT> & {\n      output?: never;\n      experimental_output?: EXPERIMENTAL_OUTPUT;\n    },\n  ): Promise<GenerateTextResult<any, EXPERIMENTAL_OUTPUT>>;\n  async generate<\n    OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n    EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n  >(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentGenerateOptions<OUTPUT, EXPERIMENTAL_OUTPUT>,\n  ): Promise<GenerateReturn<any, OUTPUT, EXPERIMENTAL_OUTPUT>> {\n    this.#clearNetworkHistoryBeforeRun();\n    this.logger.debug(`AgentNetwork: Starting generation with ${this.#agents.length} available agents`);\n\n    const ops = {\n      maxSteps: this.#agents?.length * 10, // Default to 10 steps per agent\n      ...args,\n    };\n\n    // Log the start of the routing process\n    this.logger.debug(`AgentNetwork: Routing with max steps: ${ops.maxSteps}`);\n\n    // Generate a response using the routing agent\n    const result = await this.#routingAgent.generate(\n      messages,\n      ops as AgentGenerateOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & { output?: never; experimental_output?: never },\n    );\n\n    // Log completion\n    this.logger.debug(`AgentNetwork: Generation complete with ${result.steps?.length || 0} steps`);\n\n    return result as unknown as GenerateReturn<any, OUTPUT, EXPERIMENTAL_OUTPUT>;\n  }\n\n  async stream<\n    OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n    EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n  >(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & { output?: never; experimental_output?: never },\n  ): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown>>;\n  async stream<\n    OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n    EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n  >(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & { output?: OUTPUT; experimental_output?: never },\n  ): Promise<StreamObjectResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown, any>>;\n  async stream<\n    OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n    EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n  >(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {\n      output?: never;\n      experimental_output?: EXPERIMENTAL_OUTPUT;\n    },\n  ): Promise<\n    StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown> & {\n      partialObjectStream: StreamTextResult<\n        any,\n        OUTPUT extends ZodSchema\n          ? z.infer<OUTPUT>\n          : EXPERIMENTAL_OUTPUT extends ZodSchema\n            ? z.infer<EXPERIMENTAL_OUTPUT>\n            : unknown\n      >['experimental_partialOutputStream'];\n    }\n  >;\n  async stream<\n    OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n    EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined,\n  >(\n    messages: string | string[] | CoreMessage[] | AiMessageType[],\n    args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT>,\n  ): Promise<\n    | StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown>\n    | StreamObjectResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown, any>\n  > {\n    this.#clearNetworkHistoryBeforeRun();\n    this.logger.debug(`AgentNetwork: Starting generation with ${this.#agents.length} available agents`);\n\n    const ops: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> = {\n      maxSteps: this.#agents?.length * 10, // Default to 10 steps per agent\n      ...args,\n    };\n\n    // Log the start of the routing process\n    this.logger.debug(`AgentNetwork: Routing with max steps: ${ops.maxSteps}`);\n\n    // Generate a response using the routing agent\n    const result = await this.#routingAgent.stream(\n      messages,\n      ops as AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & { output?: never; experimental_output?: never },\n    );\n\n    return result;\n  }\n\n  __registerMastra(p: Mastra) {\n    this.__setLogger(p.getLogger());\n    this.#routingAgent.__registerMastra(p);\n    // Register primitives for each agent in the network\n    for (const agent of this.#agents) {\n      if (typeof agent.__registerMastra === 'function') {\n        agent.__registerMastra(p);\n      }\n    }\n  }\n}\n"]}