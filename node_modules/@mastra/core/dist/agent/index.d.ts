import type { WritableStream } from 'stream/web';
import type { CoreMessage, StreamObjectResult, StreamTextResult, UIMessage } from 'ai';
import type { JSONSchema7 } from 'json-schema';
import type { ZodSchema, z } from 'zod';
import type { MastraPrimitives } from '../action/index.js';
import { MastraBase } from '../base.js';
import type { Metric } from '../eval/index.js';
import type { MastraLLMBase } from '../llm/model/index.js';
import type { GenerateObjectResult, GenerateTextResult } from '../llm/model/base.types.js';
import type { Mastra } from '../mastra/index.js';
import type { MastraMemory } from '../memory/memory.js';
import type { MemoryConfig, StorageThreadType } from '../memory/types.js';
import { RuntimeContext } from '../runtime-context/index.js';
import type { MastraScorers } from '../scores/index.js';
import { MastraAgentStream } from '../stream/MastraAgentStream.js';
import type { ChunkType } from '../stream/MastraAgentStream.js';
import type { CoreTool } from '../tools/types.js';
import type { DynamicArgument } from '../types.js';
import type { CompositeVoice } from '../voice/index.js';
import { DefaultVoice } from '../voice/index.js';
import type { Workflow } from '../workflows/index.js';
import { LegacyStep as Step } from '../workflows/legacy/index.js';
import type { AgentVNextStreamOptions } from './agent.types.js';
import { MessageList } from './message-list/index.js';
import type { MessageInput, UIMessageWithMetadata } from './message-list/index.js';
import { SaveQueueManager } from './save-queue/index.js';
import { TripWire } from './trip-wire.js';
import type { AgentConfig, MastraLanguageModel, AgentGenerateOptions, AgentStreamOptions, AiMessageType, ToolsetsInput, ToolsInput } from './types.js';
export type { ChunkType, MastraAgentStream } from '../stream/MastraAgentStream.js';
export * from './input-processor/index.js';
export { TripWire };
export { MessageList };
export * from './types.js';
export declare class Agent<TAgentId extends string = string, TTools extends ToolsInput = ToolsInput, TMetrics extends Record<string, Metric> = Record<string, Metric>> extends MastraBase {
    #private;
    id: TAgentId;
    name: TAgentId;
    readonly model?: DynamicArgument<MastraLanguageModel>;
    evals: TMetrics;
    private _agentNetworkAppend;
    constructor(config: AgentConfig<TAgentId, TTools, TMetrics>);
    hasOwnMemory(): boolean;
    getMemory({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<MastraMemory | undefined>;
    get voice(): CompositeVoice;
    getWorkflows({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<Record<string, Workflow>>;
    getScorers({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<MastraScorers>;
    getVoice({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): Promise<CompositeVoice | DefaultVoice>;
    get instructions(): string;
    getInstructions({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): string | Promise<string>;
    getDescription(): string;
    getDefaultGenerateOptions({ runtimeContext, }?: {
        runtimeContext?: RuntimeContext;
    }): AgentGenerateOptions | Promise<AgentGenerateOptions>;
    getDefaultStreamOptions({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): AgentStreamOptions | Promise<AgentStreamOptions>;
    getDefaultVNextStreamOptions<Output extends ZodSchema | undefined, StructuredOutput extends ZodSchema | undefined>({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): AgentVNextStreamOptions<Output, StructuredOutput> | Promise<AgentVNextStreamOptions<Output, StructuredOutput>>;
    get tools(): TTools;
    getTools({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): TTools | Promise<TTools>;
    get llm(): MastraLLMBase | Promise<MastraLLMBase>;
    /**
     * Gets or creates an LLM instance based on the current model
     * @param options Options for getting the LLM
     * @returns A promise that resolves to the LLM instance
     */
    getLLM({ runtimeContext, model, }?: {
        runtimeContext?: RuntimeContext;
        model?: MastraLanguageModel | DynamicArgument<MastraLanguageModel>;
    }): MastraLLMBase | Promise<MastraLLMBase>;
    /**
     * Gets the model, resolving it if it's a function
     * @param options Options for getting the model
     * @returns A promise that resolves to the model
     */
    getModel({ runtimeContext }?: {
        runtimeContext?: RuntimeContext;
    }): MastraLanguageModel | Promise<MastraLanguageModel>;
    __updateInstructions(newInstructions: string): void;
    __registerPrimitives(p: MastraPrimitives): void;
    __registerMastra(mastra: Mastra): void;
    /**
     * Set the concrete tools for the agent
     * @param tools
     */
    __setTools(tools: TTools): void;
    generateTitleFromUserMessage({ message, runtimeContext, model, instructions, }: {
        message: string | MessageInput;
        runtimeContext?: RuntimeContext;
        model?: DynamicArgument<MastraLanguageModel>;
        instructions?: DynamicArgument<string>;
    }): Promise<string>;
    getMostRecentUserMessage(messages: Array<UIMessage | UIMessageWithMetadata>): UIMessage | UIMessageWithMetadata | undefined;
    genTitle(userMessage: string | MessageInput | undefined, runtimeContext: RuntimeContext, model?: DynamicArgument<MastraLanguageModel>, instructions?: DynamicArgument<string>): Promise<string | undefined>;
    fetchMemory({ threadId, thread: passedThread, memoryConfig, resourceId, runId, userMessages, systemMessage, messageList, runtimeContext, }: {
        resourceId: string;
        threadId: string;
        thread?: StorageThreadType;
        memoryConfig?: MemoryConfig;
        userMessages?: CoreMessage[];
        systemMessage?: CoreMessage;
        runId?: string;
        messageList?: MessageList;
        runtimeContext?: RuntimeContext;
    }): Promise<{
        threadId: string;
        messages: CoreMessage[];
    }>;
    private getMemoryTools;
    private __runInputProcessors;
    private getMemoryMessages;
    private getAssignedTools;
    private getToolsets;
    private getClientTools;
    private getWorkflowTools;
    private convertTools;
    /**
     * Adds response messages from a step to the MessageList and schedules persistence.
     * This is used for incremental saving: after each agent step, messages are added to a save queue
     * and a debounced save operation is triggered to avoid redundant writes.
     *
     * @param result - The step result containing response messages.
     * @param messageList - The MessageList instance for the current thread.
     * @param threadId - The thread ID.
     * @param memoryConfig - The memory configuration for saving.
     * @param runId - (Optional) The run ID for logging.
     */
    private saveStepMessages;
    __primitive({ instructions, messages, context, thread, memoryConfig, resourceId, runId, toolsets, clientTools, runtimeContext, saveQueueManager, writableStream, }: {
        instructions: string;
        toolsets?: ToolsetsInput;
        clientTools?: ToolsInput;
        resourceId?: string;
        thread?: (Partial<StorageThreadType> & {
            id: string;
        }) | undefined;
        memoryConfig?: MemoryConfig;
        context?: CoreMessage[];
        runId?: string;
        messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[];
        runtimeContext: RuntimeContext;
        saveQueueManager: SaveQueueManager;
        writableStream?: WritableStream<ChunkType>;
    }): {
        before: () => Promise<{
            tripwire?: boolean | undefined;
            tripwireReason?: string | undefined;
            messageObjects: CoreMessage[];
            convertedTools: Record<string, CoreTool>;
            threadExists: boolean;
            thread: undefined;
            messageList: MessageList;
        } | {
            threadExists: boolean;
            tripwire?: boolean | undefined;
            tripwireReason?: string | undefined;
            convertedTools: Record<string, CoreTool>;
            thread: StorageThreadType;
            messageList: MessageList;
            messageObjects: CoreMessage[];
        }>;
        after: ({ result, thread: threadAfter, threadId, memoryConfig, outputText, runId, messageList, threadExists, structuredOutput, }: {
            runId: string;
            result: Record<string, any>;
            thread: StorageThreadType | null | undefined;
            threadId?: string;
            memoryConfig: MemoryConfig | undefined;
            outputText: string;
            messageList: MessageList;
            threadExists: boolean;
            structuredOutput?: boolean;
        }) => Promise<void>;
    };
    private prepareLLMOptions;
    generate(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentGenerateOptions<undefined, undefined> & {
        output?: never;
        experimental_output?: never;
    }): Promise<GenerateTextResult<any, undefined>>;
    generate<OUTPUT extends ZodSchema | JSONSchema7>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentGenerateOptions<OUTPUT, undefined> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<GenerateObjectResult<OUTPUT>>;
    generate<EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentGenerateOptions<undefined, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<GenerateTextResult<any, EXPERIMENTAL_OUTPUT>>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: never;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown>>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: OUTPUT;
        experimental_output?: never;
    }): Promise<StreamObjectResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown, any>>;
    stream<OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined, EXPERIMENTAL_OUTPUT extends ZodSchema | JSONSchema7 | undefined = undefined>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], args?: AgentStreamOptions<OUTPUT, EXPERIMENTAL_OUTPUT> & {
        output?: never;
        experimental_output?: EXPERIMENTAL_OUTPUT;
    }): Promise<StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : unknown> & {
        partialObjectStream: StreamTextResult<any, OUTPUT extends ZodSchema ? z.infer<OUTPUT> : EXPERIMENTAL_OUTPUT extends ZodSchema ? z.infer<EXPERIMENTAL_OUTPUT> : unknown>['experimental_partialOutputStream'];
    }>;
    streamVNext<Output extends ZodSchema | undefined = undefined, StructuredOutput extends ZodSchema | undefined = undefined>(messages: string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[], streamOptions?: AgentVNextStreamOptions<Output, StructuredOutput>): MastraAgentStream<Output extends ZodSchema ? z.infer<Output> : StructuredOutput extends ZodSchema ? z.infer<StructuredOutput> : unknown>;
    /**
     * Convert text to speech using the configured voice provider
     * @param input Text or text stream to convert to speech
     * @param options Speech options including speaker and provider-specific options
     * @returns Audio stream
     * @deprecated Use agent.voice.speak() instead
     */
    speak(input: string | NodeJS.ReadableStream, options?: {
        speaker?: string;
        [key: string]: any;
    }): Promise<NodeJS.ReadableStream | void>;
    /**
     * Convert speech to text using the configured voice provider
     * @param audioStream Audio stream to transcribe
     * @param options Provider-specific transcription options
     * @returns Text or text stream
     * @deprecated Use agent.voice.listen() instead
     */
    listen(audioStream: NodeJS.ReadableStream, options?: {
        [key: string]: any;
    }): Promise<string | NodeJS.ReadableStream | void>;
    /**
     * Get a list of available speakers from the configured voice provider
     * @throws {Error} If no voice provider is configured
     * @returns {Promise<Array<{voiceId: string}>>} List of available speakers
     * @deprecated Use agent.voice.getSpeakers() instead
     */
    getSpeakers(): Promise<{
        voiceId: string;
    }[]>;
    toStep(): Step<TAgentId, z.ZodObject<{
        prompt: z.ZodString;
    }>, z.ZodObject<{
        text: z.ZodString;
    }>, any>;
    /**
     * Resolves the configuration for title generation.
     * @private
     */
    private resolveTitleGenerationConfig;
    /**
     * Resolves title generation instructions, handling both static strings and dynamic functions
     * @private
     */
    private resolveTitleInstructions;
}
//# sourceMappingURL=index.d.ts.map