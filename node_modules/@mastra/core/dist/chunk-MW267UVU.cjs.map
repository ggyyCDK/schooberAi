{"version":3,"sources":["../src/tools/tool-builder/builder.ts","../src/utils.ts"],"names":["MastraBase","isVercelTool","z","convertZodSchemaToAISDKSchema","RuntimeContext","ToolStream","logger","MastraError","OpenAIReasoningSchemaCompatLayer","OpenAISchemaCompatLayer","GoogleSchemaCompatLayer","AnthropicSchemaCompatLayer","DeepSeekSchemaCompatLayer","MetaSchemaCompatLayer","applyCompatLayer","createHash","jsonSchemaToZod"],"mappings":"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","file":"chunk-MW267UVU.cjs","sourcesContent":["import {\n  OpenAIReasoningSchemaCompatLayer,\n  OpenAISchemaCompatLayer,\n  GoogleSchemaCompatLayer,\n  AnthropicSchemaCompatLayer,\n  DeepSeekSchemaCompatLayer,\n  MetaSchemaCompatLayer,\n  applyCompatLayer,\n  convertZodSchemaToAISDKSchema,\n} from '@mastra/schema-compat';\nimport type { ToolExecutionOptions } from 'ai';\nimport { z } from 'zod';\nimport { MastraBase } from '../../base';\nimport { ErrorCategory, MastraError, ErrorDomain } from '../../error';\nimport { RuntimeContext } from '../../runtime-context';\nimport { isVercelTool } from '../../tools/toolchecks';\nimport type { ToolOptions } from '../../utils';\nimport { ToolStream } from '../stream';\nimport type { CoreTool, ToolAction, VercelTool } from '../types';\n\nexport type ToolToConvert = VercelTool | ToolAction<any, any, any>;\nexport type LogType = 'tool' | 'toolset' | 'client-tool';\n\ninterface LogOptions {\n  agentName?: string;\n  toolName: string;\n  type?: 'tool' | 'toolset' | 'client-tool';\n}\n\ninterface LogMessageOptions {\n  start: string;\n  error: string;\n}\n\nexport class CoreToolBuilder extends MastraBase {\n  private originalTool: ToolToConvert;\n  private options: ToolOptions;\n  private logType?: LogType;\n\n  constructor(input: { originalTool: ToolToConvert; options: ToolOptions; logType?: LogType }) {\n    super({ name: 'CoreToolBuilder' });\n    this.originalTool = input.originalTool;\n    this.options = input.options;\n    this.logType = input.logType;\n  }\n\n  // Helper to get parameters based on tool type\n  private getParameters = () => {\n    if (isVercelTool(this.originalTool)) {\n      return this.originalTool.parameters ?? z.object({});\n    }\n\n    return this.originalTool.inputSchema ?? z.object({});\n  };\n\n  private getOutputSchema = () => {\n    if ('outputSchema' in this.originalTool) return this.originalTool.outputSchema;\n    return null;\n  };\n\n  // For provider-defined tools, we need to include all required properties\n  private buildProviderTool(tool: ToolToConvert): (CoreTool & { id: `${string}.${string}` }) | undefined {\n    if (\n      'type' in tool &&\n      tool.type === 'provider-defined' &&\n      'id' in tool &&\n      typeof tool.id === 'string' &&\n      tool.id.includes('.')\n    ) {\n      const parameters = this.getParameters();\n      const outputSchema = this.getOutputSchema();\n      return {\n        type: 'provider-defined' as const,\n        id: tool.id,\n        args: ('args' in this.originalTool ? this.originalTool.args : {}) as Record<string, unknown>,\n        description: tool.description,\n        parameters: convertZodSchemaToAISDKSchema(parameters),\n        ...(outputSchema ? { outputSchema: convertZodSchemaToAISDKSchema(outputSchema) } : {}),\n        execute: this.originalTool.execute\n          ? this.createExecute(\n              this.originalTool,\n              { ...this.options, description: this.originalTool.description },\n              this.logType,\n            )\n          : undefined,\n      };\n    }\n\n    return undefined;\n  }\n\n  private createLogMessageOptions({ agentName, toolName, type }: LogOptions): LogMessageOptions {\n    // If no agent name, use default format\n    if (!agentName) {\n      return {\n        start: `Executing tool ${toolName}`,\n        error: `Failed tool execution`,\n      };\n    }\n\n    const prefix = `[Agent:${agentName}]`;\n    const toolType = type === 'toolset' ? 'toolset' : 'tool';\n\n    return {\n      start: `${prefix} - Executing ${toolType} ${toolName}`,\n      error: `${prefix} - Failed ${toolType} execution`,\n    };\n  }\n\n  private createExecute(tool: ToolToConvert, options: ToolOptions, logType?: 'tool' | 'toolset' | 'client-tool') {\n    // dont't add memory or mastra to logging\n    const { logger, mastra: _mastra, memory: _memory, runtimeContext, ...rest } = options;\n\n    const { start, error } = this.createLogMessageOptions({\n      agentName: options.agentName,\n      toolName: options.name,\n      type: logType,\n    });\n\n    const execFunction = async (args: any, execOptions: ToolExecutionOptions) => {\n      if (isVercelTool(tool)) {\n        return tool?.execute?.(args, execOptions) ?? undefined;\n      }\n\n      return (\n        tool?.execute?.(\n          {\n            context: args,\n            threadId: options.threadId,\n            resourceId: options.resourceId,\n            mastra: options.mastra,\n            memory: options.memory,\n            runId: options.runId,\n            runtimeContext: options.runtimeContext ?? new RuntimeContext(),\n            writer: new ToolStream(\n              {\n                prefix: 'tool',\n                callId: execOptions.toolCallId,\n                name: options.name,\n                runId: options.runId!,\n              },\n              options.writableStream,\n            ),\n          },\n          execOptions,\n        ) ?? undefined\n      );\n    };\n\n    return async (args: any, execOptions?: any) => {\n      let logger = options.logger || this.logger;\n      try {\n        logger.debug(start, { ...rest, args });\n\n        // there is a small delay in stream output so we add an immediate to ensure the stream is ready\n        return await new Promise((resolve, reject) => {\n          setImmediate(async () => {\n            try {\n              const result = await execFunction(args, execOptions);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n      } catch (err) {\n        const mastraError = new MastraError(\n          {\n            id: 'TOOL_EXECUTION_FAILED',\n            domain: ErrorDomain.TOOL,\n            category: ErrorCategory.USER,\n            details: {\n              error,\n              args,\n              model: rest.model?.modelId ?? '',\n            },\n          },\n          err,\n        );\n        logger.trackException(mastraError);\n        logger.error(error, { ...rest, error: mastraError, args });\n        return mastraError;\n      }\n    };\n  }\n\n  build(): CoreTool {\n    const providerTool = this.buildProviderTool(this.originalTool);\n    if (providerTool) {\n      return providerTool;\n    }\n\n    const definition = {\n      type: 'function' as const,\n      description: this.originalTool.description,\n      parameters: this.getParameters(),\n      outputSchema: this.getOutputSchema(),\n      execute: this.originalTool.execute\n        ? this.createExecute(\n            this.originalTool,\n            { ...this.options, description: this.originalTool.description },\n            this.logType,\n          )\n        : undefined,\n    };\n\n    const model = this.options.model;\n\n    const schemaCompatLayers = [];\n\n    if (model) {\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(model),\n        new OpenAISchemaCompatLayer(model),\n        new GoogleSchemaCompatLayer(model),\n        new AnthropicSchemaCompatLayer(model),\n        new DeepSeekSchemaCompatLayer(model),\n        new MetaSchemaCompatLayer(model),\n      );\n    }\n\n    const processedSchema = applyCompatLayer({\n      schema: this.getParameters(),\n      compatLayers: schemaCompatLayers,\n      mode: 'aiSdkSchema',\n    });\n\n    let processedOutputSchema;\n\n    if (this.getOutputSchema()) {\n      processedOutputSchema = applyCompatLayer({\n        schema: this.getOutputSchema(),\n        compatLayers: schemaCompatLayers,\n        mode: 'aiSdkSchema',\n      });\n    }\n\n    return {\n      ...definition,\n      parameters: processedSchema,\n      outputSchema: processedOutputSchema,\n    };\n  }\n}\n","import { createHash } from 'crypto';\nimport type { CoreMessage, LanguageModelV1 } from 'ai';\nimport jsonSchemaToZod from 'json-schema-to-zod';\nimport { z } from 'zod';\nimport type { MastraPrimitives } from './action';\nimport type { ToolsInput } from './agent';\nimport type { IMastraLogger } from './logger';\nimport type { Mastra } from './mastra';\nimport type { AiMessageType, MastraMemory } from './memory';\nimport type { RuntimeContext } from './runtime-context';\nimport type { ChunkType } from './stream/MastraAgentStream';\nimport type { CoreTool, ToolAction, VercelTool } from './tools';\nimport { CoreToolBuilder } from './tools/tool-builder/builder';\nimport { isVercelTool } from './tools/toolchecks';\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Deep merges two objects, recursively merging nested objects and arrays\n */\nexport function deepMerge<T extends object = object>(target: T, source: Partial<T>): T {\n  const output = { ...target };\n\n  if (!source) return output;\n\n  Object.keys(source).forEach(key => {\n    const targetValue = output[key as keyof T];\n    const sourceValue = source[key as keyof T];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      (output as any)[key] = sourceValue;\n    } else if (\n      sourceValue instanceof Object &&\n      targetValue instanceof Object &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      (output as any)[key] = deepMerge(targetValue, sourceValue as T);\n    } else if (sourceValue !== undefined) {\n      (output as any)[key] = sourceValue;\n    }\n  });\n\n  return output;\n}\n\nexport function generateEmptyFromSchema(schema: string) {\n  try {\n    const parsedSchema = JSON.parse(schema);\n    if (!parsedSchema || parsedSchema.type !== 'object' || !parsedSchema.properties) return {};\n    const obj: Record<string, any> = {};\n    const TYPE_DEFAULTS = {\n      string: '',\n      array: [],\n      object: {},\n      number: 0,\n      integer: 0,\n      boolean: false,\n    };\n    for (const [key, prop] of Object.entries<any>(parsedSchema.properties)) {\n      obj[key] = TYPE_DEFAULTS[prop.type as keyof typeof TYPE_DEFAULTS] ?? null;\n    }\n    return obj;\n  } catch {\n    return {};\n  }\n}\n\nexport interface TagMaskOptions {\n  /** Called when masking begins */\n  onStart?: () => void;\n  /** Called when masking ends */\n  onEnd?: () => void;\n  /** Called for each chunk that is masked */\n  onMask?: (chunk: string) => void;\n}\n\n/**\n * Transforms a stream by masking content between XML tags.\n * @param stream Input stream to transform\n * @param tag Tag name to mask between (e.g. for <foo>...</foo>, use 'foo')\n * @param options Optional configuration for masking behavior\n */\nexport async function* maskStreamTags(\n  stream: AsyncIterable<string>,\n  tag: string,\n  options: TagMaskOptions = {},\n): AsyncIterable<string> {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n\n  let buffer = '';\n  let fullContent = '';\n  let isMasking = false;\n  let isBuffering = false;\n\n  // used for checking in chunks that include tags or partial tags + some other non-tag text\n  // eg: \"o <tag_name\" or \"name> w\", can trim before-start to get \"<tag_name\" or after-end to get \"name>\"\n  const trimOutsideDelimiter = (text: string, delimiter: string, trim: 'before-start' | 'after-end') => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n\n    const parts = text.split(delimiter);\n\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n\n    return `${parts[0]}${delimiter}`;\n  };\n\n  // Helper to check if text starts with pattern (ignoring whitespace)\n  // When checking partial tags: startsWith(buffer, openTag) checks if buffer could be start of tag\n  // When checking full tags: startsWith(chunk, openTag) checks if chunk starts with full tag\n  const startsWith = (text: string, pattern: string) => {\n    // check start of opening tag\n    if (pattern.includes(openTag.substring(0, 3))) {\n      // our pattern for checking the start is always based on xml-like tags\n      // if the pattern looks like our opening tag and the pattern also includes\n      // some other chunked text before it, we just wanted to check the xml part of the pattern\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n\n    return text.trim().startsWith(pattern.trim());\n  };\n\n  for await (const chunk of stream) {\n    fullContent += chunk;\n\n    if (isBuffering) buffer += chunk;\n\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n\n    let toYieldBeforeMaskedStartTag = ``;\n    // Check if we should start masking chunks\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n\n      // check if the buffered text includes text before the start tag. ex \"o <tag_name\", \"o\" should be yielded and not masked\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n\n      buffer = '';\n      onStart?.();\n    }\n\n    // Check if we should start buffering (looks like part of the opening tag but it's not the full <tag> yet eg <ta - could be <table> but we don't know yet)\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== '') {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n\n    // We're buffering, need to check again if our buffer has deviated from the opening <tag> eg <tag2>\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = '';\n      isBuffering = false;\n      continue;\n    }\n\n    // Check if we should stop masking chunks (since the content includes the closing </tag>)\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``; // reset to handle streams with multiple full tags that have text inbetween\n\n      // check to see if we have a partial chunk outside the close tag. if we do we need to yield it so it isn't swallowed with the masked text\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, 'after-end');\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n\n      continue;\n    }\n\n    // We're currently masking chunks inside a <tag>\n    if (isMasking) {\n      onMask?.(chunk);\n      // in the case that there was a chunk that included a tag to mask and some other text, ex \"o <tag_name\" we need to still yield the\n      // text before the tag (\"o \") so it's not swallowed with the masked text\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n\n    // default yield the chunk\n    yield chunk;\n  }\n}\n\n/**\n * Resolve serialized zod output - This function takes the string output ot the `jsonSchemaToZod` function\n * and instantiates the zod object correctly.\n *\n * @param schema - serialized zod object\n * @returns resolved zod object\n */\nexport function resolveSerializedZodOutput(schema: string): z.ZodType {\n  // Creates and immediately executes a new function that takes 'z' as a parameter\n  // The function body is a string that returns the serialized zod schema\n  // When executed with the 'z' parameter, it reconstructs the zod schema in the current context\n  return Function('z', `\"use strict\";return (${schema});`)(z);\n}\n\nexport interface ToolOptions {\n  name: string;\n  runId?: string;\n  threadId?: string;\n  resourceId?: string;\n  logger?: IMastraLogger;\n  description?: string;\n  mastra?: (Mastra & MastraPrimitives) | MastraPrimitives;\n  runtimeContext: RuntimeContext;\n  memory?: MastraMemory;\n  agentName?: string;\n  model?: LanguageModelV1;\n  writableStream?: WritableStream<ChunkType>;\n}\n\ntype ToolToConvert = VercelTool | ToolAction<any, any, any>;\n\n/**\n * Checks if a value is a Zod type\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n */\nexport function isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n// Helper function to create a deterministic hash\nfunction createDeterministicId(input: string): string {\n  return createHash('sha256').update(input).digest('hex').slice(0, 8); // Take first 8 characters for a shorter but still unique ID\n}\n\n/**\n * Sets the properties for a Vercel Tool, including an ID and inputSchema\n * @param tool - The tool to set the properties for\n * @returns The tool with the properties set\n */\nfunction setVercelToolProperties(tool: VercelTool) {\n  const inputSchema = convertVercelToolParameters(tool);\n  const toolId = !('id' in tool)\n    ? tool.description\n      ? `tool-${createDeterministicId(tool.description)}`\n      : `tool-${Math.random().toString(36).substring(2, 9)}`\n    : tool.id;\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema,\n  };\n}\n\n/**\n * Ensures a tool has an ID and inputSchema by generating one if not present\n * @param tool - The tool to ensure has an ID and inputSchema\n * @returns The tool with an ID and inputSchema\n */\nexport function ensureToolProperties(tools: ToolsInput): ToolsInput {\n  const toolsWithProperties = Object.keys(tools).reduce<ToolsInput>((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool) as VercelTool;\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n\n  return toolsWithProperties;\n}\n\nfunction convertVercelToolParameters(tool: VercelTool): z.ZodType {\n  // If the tool is a Vercel Tool, check if the parameters are already a zod object\n  // If not, convert the parameters to a zod object using jsonSchemaToZod\n  const schema = tool.parameters ?? z.object({});\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\n\n/**\n * Converts a Vercel Tool or Mastra Tool into a CoreTool format\n * @param originalTool - The tool to convert (either VercelTool or ToolAction)\n * @param options - Tool options including Mastra-specific settings\n * @param logType - Type of tool to log (tool or toolset)\n * @returns A CoreTool that can be used by the system\n */\nexport function makeCoreTool(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n): CoreTool {\n  return new CoreToolBuilder({ originalTool, options, logType }).build();\n}\n\n/**\n * Creates a proxy for a Mastra instance to handle deprecated properties\n * @param mastra - The Mastra instance to proxy\n * @param logger - The logger to use for warnings\n * @returns A proxy for the Mastra instance\n */\nexport function createMastraProxy({ mastra, logger }: { mastra: Mastra; logger: IMastraLogger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === 'function';\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n\n      if (prop === 'logger') {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n\n      if (prop === 'telemetry') {\n        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);\n        return Reflect.apply(target.getTelemetry, target, []);\n      }\n\n      if (prop === 'storage') {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, 'storage');\n      }\n\n      if (prop === 'agents') {\n        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.getAgents, target, []);\n      }\n\n      if (prop === 'tts') {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n\n      if (prop === 'vectors') {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n\n      if (prop === 'memory') {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, 'memory');\n      }\n\n      return Reflect.get(target, prop);\n    },\n  });\n}\n\nexport function checkEvalStorageFields(traceObject: any, logger?: IMastraLogger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push('input');\n  if (!traceObject.output) missingFields.push('output');\n  if (!traceObject.agentName) missingFields.push('agent_name');\n  if (!traceObject.metricName) missingFields.push('metric_name');\n  if (!traceObject.instructions) missingFields.push('instructions');\n  if (!traceObject.globalRunId) missingFields.push('global_run_id');\n  if (!traceObject.runId) missingFields.push('run_id');\n\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    } else {\n      console.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// lifted from https://github.com/vercel/ai/blob/main/packages/ai/core/prompt/detect-prompt-type.ts#L27\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n\nexport function isUiMessage(message: CoreMessage | AiMessageType): message is AiMessageType {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nexport function isCoreMessage(message: CoreMessage | AiMessageType): message is CoreMessage {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\n\n/** Represents a validated SQL identifier (e.g., table or column name). */\ntype SqlIdentifier = string & { __brand: 'SqlIdentifier' };\n/** Represents a validated dot-separated SQL field key. */\ntype FieldKey = string & { __brand: 'FieldKey' };\n\nconst SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\n/**\n * Parses and returns a valid SQL identifier (such as a table or column name).\n * The identifier must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param name - The identifier string to parse.\n * @param kind - Optional label for error messages (e.g., 'table name').\n * @returns The validated identifier as a branded type.\n * @throws {Error} If the identifier does not conform to SQL naming rules.\n *\n * @example\n * const id = parseSqlIdentifier('my_table'); // Ok\n * parseSqlIdentifier('123table'); // Throws error\n */\nexport function parseSqlIdentifier(name: string, kind = 'identifier'): SqlIdentifier {\n  if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {\n    throw new Error(\n      `Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`,\n    );\n  }\n  return name as SqlIdentifier;\n}\n\n/**\n * Parses and returns a valid dot-separated SQL field key (e.g., 'user.profile.name').\n * Each segment must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param key - The dot-separated field key string to parse.\n * @returns The validated field key as a branded type.\n * @throws {Error} If any segment of the key is invalid.\n *\n * @example\n * const key = parseFieldKey('user_profile.name'); // Ok\n * parseFieldKey('user..name'); // Throws error\n * parseFieldKey('user.123name'); // Throws error\n */\nexport function parseFieldKey(key: string): FieldKey {\n  if (!key) throw new Error('Field key cannot be empty');\n  const segments = key.split('.');\n  for (const segment of segments) {\n    if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {\n      throw new Error(`Invalid field key segment: ${segment} in ${key}`);\n    }\n  }\n  return key as FieldKey;\n}\n"]}