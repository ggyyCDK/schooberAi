{"version":3,"sources":["../src/workflows/execution-engine.ts","../src/workflows/default.ts","../src/stream/MastraWorkflowStream.ts","../src/workflows/workflow.ts"],"names":["result","step","otlpContext","randomUUID","mappingStep","type"],"mappings":"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","file":"chunk-TE4VA3NA.js","sourcesContent":["import type { Mastra, SerializedStepFlowEntry } from '..';\nimport { MastraBase } from '../base';\nimport type { RuntimeContext } from '../di';\nimport { RegisteredLogger } from '../logger';\nimport type { ChunkType } from '../stream/MastraWorkflowStream';\nimport type { Emitter, StepResult } from './types';\nimport type { StepFlowEntry } from '.';\n\n/**\n * Represents an execution graph for a workflow\n */\nexport interface ExecutionGraph<TEngineType = any> {\n  id: string;\n  steps: StepFlowEntry<TEngineType>[];\n  // Additional properties will be added in future implementations\n}\n/**\n * Execution engine abstract class for building and executing workflow graphs\n * Providers will implement this class to provide their own execution logic\n */\nexport abstract class ExecutionEngine extends MastraBase {\n  protected mastra?: Mastra;\n  constructor({ mastra }: { mastra?: Mastra }) {\n    super({ name: 'ExecutionEngine', component: RegisteredLogger.WORKFLOW });\n    this.mastra = mastra;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n  }\n\n  /**\n   * Executes a workflow run with the provided execution graph and input\n   * @param graph The execution graph to execute\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  abstract execute<TInput, TOutput>(params: {\n    workflowId: string;\n    runId: string;\n    graph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    input?: TInput;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    emitter: Emitter;\n    runtimeContext: RuntimeContext;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    abortController: AbortController;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<TOutput>;\n}\n","import { randomUUID } from 'crypto';\nimport { context as otlpContext, trace } from '@opentelemetry/api';\nimport type { Span } from '@opentelemetry/api';\nimport type { RuntimeContext } from '../di';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../error';\nimport type { ChunkType } from '../stream/MastraAgentStream';\nimport { ToolStream } from '../tools/stream';\nimport { EMITTER_SYMBOL } from './constants';\nimport type { ExecutionGraph } from './execution-engine';\nimport { ExecutionEngine } from './execution-engine';\nimport type { ExecuteFunction, Step } from './step';\nimport type { Emitter, StepFailure, StepResult, StepSuccess } from './types';\nimport type { DefaultEngineType, SerializedStepFlowEntry, StepFlowEntry } from './workflow';\n\nexport type ExecutionContext = {\n  workflowId: string;\n  runId: string;\n  executionPath: number[];\n  suspendedPaths: Record<string, number[]>;\n  retryConfig: {\n    attempts: number;\n    delay: number;\n  };\n  executionSpan: Span;\n};\n\n/**\n * Default implementation of the ExecutionEngine using XState\n */\nexport class DefaultExecutionEngine extends ExecutionEngine {\n  /**\n   * The runCounts map is used to keep track of the run count for each step.\n   * The step id is used as the key and the run count is the value.\n   */\n  protected runCounts = new Map<string, number>();\n\n  /**\n   * Get or generate the run count for a step.\n   * If the step id is not in the map, it will be added and the run count will be 0.\n   * If the step id is in the map, it will return the run count.\n   *\n   * @param stepId - The id of the step.\n   * @returns The run count for the step.\n   */\n  protected getOrGenerateRunCount(stepId: Step['id']) {\n    if (this.runCounts.has(stepId)) {\n      const currentRunCount = this.runCounts.get(stepId) as number;\n      const nextRunCount = currentRunCount + 1;\n\n      this.runCounts.set(stepId, nextRunCount);\n\n      return nextRunCount;\n    }\n\n    const runCount = 0;\n\n    this.runCounts.set(stepId, runCount);\n\n    return runCount;\n  }\n\n  protected async fmtReturnValue<TOutput>(\n    executionSpan: Span | undefined,\n    emitter: Emitter,\n    stepResults: Record<string, StepResult<any, any, any, any>>,\n    lastOutput: StepResult<any, any, any, any>,\n    error?: Error | string,\n  ): Promise<TOutput> {\n    const base: any = {\n      status: lastOutput.status,\n      steps: stepResults,\n    };\n    if (lastOutput.status === 'success') {\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          workflowState: {\n            status: lastOutput.status,\n            steps: stepResults,\n            result: lastOutput.output,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n\n      base.result = lastOutput.output;\n    } else if (lastOutput.status === 'failed') {\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          workflowState: {\n            status: lastOutput.status,\n            steps: stepResults,\n            result: null,\n            error: lastOutput.error,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n\n      base.error =\n        error instanceof Error\n          ? (error?.stack ?? error)\n          : (lastOutput.error ??\n            (typeof error === 'string'\n              ? error\n              : (new Error('Unknown error: ' + error)?.stack ?? new Error('Unknown error: ' + error))));\n    } else if (lastOutput.status === 'suspended') {\n      const suspendedStepIds = Object.entries(stepResults).flatMap(([stepId, stepResult]) => {\n        if (stepResult?.status === 'suspended') {\n          const nestedPath = stepResult?.suspendPayload?.__workflow_meta?.path;\n          return nestedPath ? [[stepId, ...nestedPath]] : [[stepId]];\n        }\n\n        return [];\n      });\n      base.suspended = suspendedStepIds;\n\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          workflowState: {\n            status: lastOutput.status,\n            steps: stepResults,\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n    }\n\n    executionSpan?.end();\n    return base as TOutput;\n  }\n\n  /**\n   * Executes a workflow run with the provided execution graph and input\n   * @param graph The execution graph to execute\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  async execute<TInput, TOutput>(params: {\n    workflowId: string;\n    runId: string;\n    graph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    input?: TInput;\n    resume?: {\n      // TODO: add execute path\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    emitter: Emitter;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    runtimeContext: RuntimeContext;\n    abortController: AbortController;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<TOutput> {\n    const { workflowId, runId, graph, input, resume, retryConfig } = params;\n    const { attempts = 0, delay = 0 } = retryConfig ?? {};\n    const steps = graph.steps;\n\n    //clear runCounts\n    this.runCounts.clear();\n\n    if (steps.length === 0) {\n      throw new MastraError({\n        id: 'WORKFLOW_EXECUTE_EMPTY_GRAPH',\n        text: 'Workflow must have at least one step',\n        domain: ErrorDomain.MASTRA_WORKFLOW,\n        category: ErrorCategory.USER,\n      });\n    }\n\n    const executionSpan = this.mastra?.getTelemetry()?.tracer.startSpan(`workflow.${workflowId}.execute`, {\n      attributes: { componentName: workflowId, runId },\n    });\n\n    let startIdx = 0;\n    if (resume?.resumePath) {\n      startIdx = resume.resumePath[0]!;\n      resume.resumePath.shift();\n    }\n\n    const stepResults: Record<string, any> = resume?.stepResults || { input };\n    let lastOutput: any;\n    for (let i = startIdx; i < steps.length; i++) {\n      const entry = steps[i]!;\n\n      try {\n        lastOutput = await this.executeEntry({\n          workflowId,\n          runId,\n          entry,\n          serializedStepGraph: params.serializedStepGraph,\n          prevStep: steps[i - 1]!,\n          stepResults,\n          resume,\n          executionContext: {\n            workflowId,\n            runId,\n            executionPath: [i],\n            suspendedPaths: {},\n            retryConfig: { attempts, delay },\n            executionSpan: executionSpan as Span,\n          },\n          abortController: params.abortController,\n          emitter: params.emitter,\n          runtimeContext: params.runtimeContext,\n          writableStream: params.writableStream,\n        });\n\n        if (lastOutput.result.status !== 'success') {\n          if (lastOutput.result.status === 'bailed') {\n            lastOutput.result.status = 'success';\n          }\n\n          const result = (await this.fmtReturnValue(\n            executionSpan,\n            params.emitter,\n            stepResults,\n            lastOutput.result,\n          )) as any;\n          await this.persistStepUpdate({\n            workflowId,\n            runId,\n            stepResults: lastOutput.stepResults as any,\n            serializedStepGraph: params.serializedStepGraph,\n            executionContext: lastOutput.executionContext as ExecutionContext,\n            workflowStatus: result.status,\n            result: result.result,\n            error: result.error,\n            runtimeContext: params.runtimeContext,\n          });\n          return result;\n        }\n      } catch (e) {\n        const error =\n          e instanceof MastraError\n            ? e\n            : new MastraError(\n                {\n                  id: 'WORKFLOW_ENGINE_STEP_EXECUTION_FAILED',\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  category: ErrorCategory.USER,\n                  details: { workflowId, runId },\n                },\n                e,\n              );\n\n        this.logger?.trackException(error);\n        this.logger?.error(`Error executing step: ${error?.stack}`);\n        const result = (await this.fmtReturnValue(\n          executionSpan,\n          params.emitter,\n          stepResults,\n          lastOutput.result,\n          e as Error,\n        )) as any;\n        await this.persistStepUpdate({\n          workflowId,\n          runId,\n          stepResults: lastOutput.stepResults as any,\n          serializedStepGraph: params.serializedStepGraph,\n          executionContext: lastOutput.executionContext as ExecutionContext,\n          workflowStatus: result.status,\n          result: result.result,\n          error: result.error,\n          runtimeContext: params.runtimeContext,\n        });\n        return result;\n      }\n    }\n\n    const result = (await this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput.result)) as any;\n    await this.persistStepUpdate({\n      workflowId,\n      runId,\n      stepResults: lastOutput.stepResults as any,\n      serializedStepGraph: params.serializedStepGraph,\n      executionContext: lastOutput.executionContext as ExecutionContext,\n      workflowStatus: result.status,\n      result: result.result,\n      error: result.error,\n      runtimeContext: params.runtimeContext,\n    });\n    return result;\n  }\n\n  getStepOutput(stepResults: Record<string, any>, step?: StepFlowEntry): any {\n    if (!step) {\n      return stepResults.input;\n    } else if (step.type === 'step' || step.type === 'waitForEvent') {\n      return stepResults[step.step.id]?.output;\n    } else if (step.type === 'sleep' || step.type === 'sleepUntil') {\n      return stepResults[step.id]?.output;\n    } else if (step.type === 'parallel' || step.type === 'conditional') {\n      return step.steps.reduce(\n        (acc, entry) => {\n          if (entry.type === 'step' || entry.type === 'waitForEvent') {\n            acc[entry.step.id] = stepResults[entry.step.id]?.output;\n          } else if (entry.type === 'parallel' || entry.type === 'conditional') {\n            const parallelResult = this.getStepOutput(stepResults, entry)?.output;\n            acc = { ...acc, ...parallelResult };\n          } else if (entry.type === 'loop') {\n            acc[entry.step.id] = stepResults[entry.step.id]?.output;\n          } else if (entry.type === 'foreach') {\n            acc[entry.step.id] = stepResults[entry.step.id]?.output;\n          } else if (entry.type === 'sleep' || entry.type === 'sleepUntil') {\n            acc[entry.id] = stepResults[entry.id]?.output;\n          }\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n    } else if (step.type === 'loop') {\n      return stepResults[step.step.id]?.output;\n    } else if (step.type === 'foreach') {\n      return stepResults[step.step.id]?.output;\n    }\n  }\n\n  async executeSleep({\n    workflowId,\n    runId,\n    entry,\n    prevOutput,\n    stepResults,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    entry: {\n      type: 'sleep';\n      id: string;\n      duration?: number;\n      fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;\n    };\n    prevStep: StepFlowEntry;\n    prevOutput: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<void> {\n    let { duration, fn } = entry;\n\n    if (fn) {\n      const stepCallId = randomUUID();\n      duration = await fn({\n        runId,\n        workflowId,\n        mastra: this.mastra!,\n        runtimeContext,\n        inputData: prevOutput,\n        runCount: -1,\n        getInitData: () => stepResults?.input as any,\n        getStepResult: (step: any) => {\n          if (!step?.id) {\n            return null;\n          }\n\n          const result = stepResults[step.id];\n          if (result?.status === 'success') {\n            return result.output;\n          }\n\n          return null;\n        },\n\n        // TODO: this function shouldn't have suspend probably?\n        suspend: async (_suspendPayload: any): Promise<any> => {},\n        bail: () => {},\n        abort: () => {\n          abortController?.abort();\n        },\n        [EMITTER_SYMBOL]: emitter,\n        engine: {},\n        abortSignal: abortController?.signal,\n        writer: new ToolStream(\n          {\n            prefix: 'step',\n            callId: stepCallId,\n            name: 'sleep',\n            runId,\n          },\n          writableStream,\n        ),\n      });\n    }\n\n    await new Promise(resolve => setTimeout(resolve, !duration || duration < 0 ? 0 : duration));\n  }\n\n  async executeSleepUntil({\n    workflowId,\n    runId,\n    entry,\n    prevOutput,\n    stepResults,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    entry: {\n      type: 'sleepUntil';\n      id: string;\n      date?: Date;\n      fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;\n    };\n    prevStep: StepFlowEntry;\n    prevOutput: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<void> {\n    let { date, fn } = entry;\n\n    if (fn) {\n      const stepCallId = randomUUID();\n      date = await fn({\n        runId,\n        workflowId,\n        mastra: this.mastra!,\n        runtimeContext,\n        inputData: prevOutput,\n        runCount: -1,\n        getInitData: () => stepResults?.input as any,\n        getStepResult: (step: any) => {\n          if (!step?.id) {\n            return null;\n          }\n\n          const result = stepResults[step.id];\n          if (result?.status === 'success') {\n            return result.output;\n          }\n\n          return null;\n        },\n\n        // TODO: this function shouldn't have suspend probably?\n        suspend: async (_suspendPayload: any): Promise<any> => {},\n        bail: () => {},\n        abort: () => {\n          abortController?.abort();\n        },\n        [EMITTER_SYMBOL]: emitter,\n        engine: {},\n        abortSignal: abortController?.signal,\n        writer: new ToolStream(\n          {\n            prefix: 'step',\n            callId: stepCallId,\n            name: 'sleepUntil',\n            runId,\n          },\n          writableStream,\n        ),\n      });\n    }\n\n    const time = !date ? 0 : date?.getTime() - Date.now();\n    await new Promise(resolve => setTimeout(resolve, time < 0 ? 0 : time));\n  }\n\n  async executeWaitForEvent({\n    event,\n    emitter,\n    timeout,\n  }: {\n    event: string;\n    emitter: Emitter;\n    timeout?: number;\n  }): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const cb = (eventData: any) => {\n        resolve(eventData);\n      };\n      if (timeout) {\n        setTimeout(() => {\n          emitter.off(`user-event-${event}`, cb);\n          reject(new Error('Timeout waiting for event'));\n        }, timeout);\n      }\n\n      emitter.once(`user-event-${event}`, cb);\n    });\n  }\n\n  async executeStep({\n    workflowId,\n    runId,\n    step,\n    stepResults,\n    executionContext,\n    resume,\n    prevOutput,\n    emitter,\n    abortController,\n    runtimeContext,\n    skipEmits = false,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    step: Step<string, any, any>;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    executionContext: ExecutionContext;\n    resume?: {\n      steps: string[];\n      resumePayload: any;\n    };\n    prevOutput: any;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    skipEmits?: boolean;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<StepResult<any, any, any, any>> {\n    const startTime = resume?.steps[0] === step.id ? undefined : Date.now();\n    const resumeTime = resume?.steps[0] === step.id ? Date.now() : undefined;\n    const stepCallId = randomUUID();\n\n    const stepInfo = {\n      ...stepResults[step.id],\n      ...(resume?.steps[0] === step.id ? { resumePayload: resume?.resumePayload } : { payload: prevOutput }),\n      ...(startTime ? { startedAt: startTime } : {}),\n      ...(resumeTime ? { resumedAt: resumeTime } : {}),\n    };\n\n    if (!skipEmits) {\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: step.id,\n            status: 'running',\n            ...stepInfo,\n          },\n          workflowState: {\n            status: 'running',\n            steps: {\n              ...stepResults,\n              [step.id]: {\n                status: 'running',\n                ...stepInfo,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-start',\n        payload: {\n          id: step.id,\n          stepCallId,\n          ...stepInfo,\n          status: 'running',\n        },\n      });\n    }\n\n    const _runStep = (step: Step<any, any, any, any>, spanName: string, attributes?: Record<string, string>) => {\n      return async (data: any) => {\n        const telemetry = this.mastra?.getTelemetry();\n        const span = executionContext.executionSpan;\n        if (!telemetry || !span) {\n          return step.execute(data);\n        }\n\n        return otlpContext.with(trace.setSpan(otlpContext.active(), span), async () => {\n          return telemetry.traceMethod(step.execute.bind(step), {\n            spanName,\n            attributes,\n          })(data);\n        });\n      };\n    };\n\n    const runStep = _runStep(step, `workflow.${workflowId}.step.${step.id}`, {\n      componentName: workflowId,\n      runId,\n    });\n\n    let execResults: any;\n\n    const retries = step.retries ?? executionContext.retryConfig.attempts ?? 0;\n    const delay = executionContext.retryConfig.delay ?? 0;\n\n    // +1 for the initial attempt\n    for (let i = 0; i < retries + 1; i++) {\n      if (i > 0 && delay) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      try {\n        let suspended: { payload: any } | undefined;\n        let bailed: { payload: any } | undefined;\n\n        const result = await runStep({\n          runId,\n          workflowId,\n          mastra: this.mastra!,\n          runtimeContext,\n          inputData: prevOutput,\n          runCount: this.getOrGenerateRunCount(step.id),\n          resumeData: resume?.steps[0] === step.id ? resume?.resumePayload : undefined,\n          getInitData: () => stepResults?.input as any,\n          getStepResult: (step: any) => {\n            if (!step?.id) {\n              return null;\n            }\n\n            const result = stepResults[step.id];\n            if (result?.status === 'success') {\n              return result.output;\n            }\n\n            return null;\n          },\n          suspend: async (suspendPayload: any): Promise<any> => {\n            executionContext.suspendedPaths[step.id] = executionContext.executionPath;\n            suspended = { payload: suspendPayload };\n          },\n          bail: (result: any) => {\n            bailed = { payload: result };\n          },\n          abort: () => {\n            abortController?.abort();\n          },\n          // Only pass resume data if this step was actually suspended before\n          // This prevents pending nested workflows from trying to resume instead of start\n          resume:\n            stepResults[step.id]?.status === 'suspended'\n              ? {\n                  steps: resume?.steps?.slice(1) || [],\n                  resumePayload: resume?.resumePayload,\n                  // @ts-ignore\n                  runId: stepResults[step.id]?.suspendPayload?.__workflow_meta?.runId,\n                }\n              : undefined,\n          [EMITTER_SYMBOL]: emitter,\n          engine: {},\n          abortSignal: abortController?.signal,\n          writer: new ToolStream(\n            {\n              prefix: 'step',\n              callId: stepCallId,\n              name: step.id,\n              runId,\n            },\n            writableStream,\n          ),\n        });\n\n        if (suspended) {\n          execResults = { status: 'suspended', suspendPayload: suspended.payload, suspendedAt: Date.now() };\n        } else if (bailed) {\n          execResults = { status: 'bailed', output: bailed.payload, endedAt: Date.now() };\n        } else {\n          execResults = { status: 'success', output: result, endedAt: Date.now() };\n        }\n\n        break;\n      } catch (e) {\n        const error =\n          e instanceof MastraError\n            ? e\n            : new MastraError(\n                {\n                  id: 'WORKFLOW_STEP_INVOKE_FAILED',\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  category: ErrorCategory.USER,\n                  details: { workflowId, runId, stepId: step.id },\n                },\n                e,\n              );\n        this.logger.trackException(error);\n        this.logger.error(`Error executing step ${step.id}: ` + error?.stack);\n        execResults = {\n          status: 'failed',\n          error: error?.stack,\n          endedAt: Date.now(),\n        };\n      }\n    }\n\n    if (!skipEmits) {\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: step.id,\n            ...stepInfo,\n            ...execResults,\n          },\n          workflowState: {\n            status: 'running',\n            steps: {\n              ...stepResults,\n              [step.id]: {\n                ...stepInfo,\n                ...execResults,\n              },\n            },\n\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n\n      if (execResults.status === 'suspended') {\n        await emitter.emit('watch-v2', {\n          type: 'step-suspended',\n          payload: {\n            id: step.id,\n            stepCallId,\n            ...execResults,\n          },\n        });\n      } else {\n        await emitter.emit('watch-v2', {\n          type: 'step-result',\n          payload: {\n            id: step.id,\n            stepCallId,\n            ...execResults,\n          },\n        });\n\n        await emitter.emit('watch-v2', {\n          type: 'step-finish',\n          payload: {\n            id: step.id,\n            stepCallId,\n            metadata: {},\n          },\n        });\n      }\n    }\n\n    return { ...stepInfo, ...execResults };\n  }\n\n  async executeParallel({\n    workflowId,\n    runId,\n    entry,\n    prevStep,\n    serializedStepGraph,\n    stepResults,\n    resume,\n    executionContext,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    entry: { type: 'parallel'; steps: StepFlowEntry[] };\n    serializedStepGraph: SerializedStepFlowEntry[];\n    prevStep: StepFlowEntry;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<StepResult<any, any, any, any>> {\n    let execResults: any;\n    const results: { result: StepResult<any, any, any, any> }[] = await Promise.all(\n      entry.steps.map((step, i) =>\n        this.executeEntry({\n          workflowId,\n          runId,\n          entry: step,\n          prevStep,\n          stepResults,\n          serializedStepGraph,\n          resume,\n          executionContext: {\n            workflowId,\n            runId,\n            executionPath: [...executionContext.executionPath, i],\n            suspendedPaths: executionContext.suspendedPaths,\n            retryConfig: executionContext.retryConfig,\n            executionSpan: executionContext.executionSpan,\n          },\n          emitter,\n          abortController,\n          runtimeContext,\n          writableStream,\n        }),\n      ),\n    );\n    const hasFailed = results.find(result => result.result.status === 'failed') as {\n      result: StepFailure<any, any, any>;\n    };\n    const hasSuspended = results.find(result => result.result.status === 'suspended');\n    if (hasFailed) {\n      execResults = { status: 'failed', error: hasFailed.result.error };\n    } else if (hasSuspended) {\n      execResults = { status: 'suspended', payload: hasSuspended.result.suspendPayload };\n    } else if (abortController?.signal?.aborted) {\n      execResults = { status: 'canceled' };\n    } else {\n      execResults = {\n        status: 'success',\n        output: results.reduce((acc: Record<string, any>, result, index) => {\n          if (result.result.status === 'success') {\n            // @ts-ignore\n            acc[entry.steps[index]!.step.id] = result.result.output;\n          }\n\n          return acc;\n        }, {}),\n      };\n    }\n\n    return execResults;\n  }\n\n  async executeConditional({\n    workflowId,\n    runId,\n    entry,\n    prevOutput,\n    prevStep,\n    serializedStepGraph,\n    stepResults,\n    resume,\n    executionContext,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    entry: {\n      type: 'conditional';\n      steps: StepFlowEntry[];\n      conditions: ExecuteFunction<any, any, any, any, DefaultEngineType>[];\n    };\n    prevStep: StepFlowEntry;\n    prevOutput: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<StepResult<any, any, any, any>> {\n    let execResults: any;\n    const truthyIndexes = (\n      await Promise.all(\n        entry.conditions.map(async (cond, index) => {\n          try {\n            const result = await cond({\n              runId,\n              workflowId,\n              mastra: this.mastra!,\n              runtimeContext,\n              inputData: prevOutput,\n              runCount: -1,\n              getInitData: () => stepResults?.input as any,\n              getStepResult: (step: any) => {\n                if (!step?.id) {\n                  return null;\n                }\n\n                const result = stepResults[step.id];\n                if (result?.status === 'success') {\n                  return result.output;\n                }\n\n                return null;\n              },\n\n              // TODO: this function shouldn't have suspend probably?\n              suspend: async (_suspendPayload: any): Promise<any> => {},\n              bail: () => {},\n              abort: () => {\n                abortController?.abort();\n              },\n              [EMITTER_SYMBOL]: emitter,\n              engine: {},\n              abortSignal: abortController?.signal,\n              writer: new ToolStream(\n                {\n                  prefix: 'step',\n                  callId: randomUUID(),\n                  name: 'conditional',\n                  runId,\n                },\n                writableStream,\n              ),\n            });\n            return result ? index : null;\n          } catch (e: unknown) {\n            const error =\n              e instanceof MastraError\n                ? e\n                : new MastraError(\n                    {\n                      id: 'WORKFLOW_CONDITION_EVALUATION_FAILED',\n                      domain: ErrorDomain.MASTRA_WORKFLOW,\n                      category: ErrorCategory.USER,\n                      details: { workflowId, runId },\n                    },\n                    e,\n                  );\n            this.logger.trackException(error);\n            this.logger.error('Error evaluating condition: ' + error?.stack);\n            return null;\n          }\n        }),\n      )\n    ).filter((index): index is number => index !== null);\n\n    const stepsToRun = entry.steps.filter((_, index) => truthyIndexes.includes(index));\n\n    // During resume, avoid re-executing steps that are already successfully completed\n    const stepsToExecute = stepsToRun.filter(step => {\n      if (resume && step.type === 'step') {\n        const existingResult = stepResults[step.step.id];\n        // Only re-execute if step is suspended, failed, or not yet executed\n        return !existingResult || existingResult.status === 'suspended' || existingResult.status === 'failed';\n      }\n      return true; // Always execute during initial run\n    });\n\n    const results: { result: StepResult<any, any, any, any> }[] = await Promise.all(\n      stepsToExecute.map((step, _index) =>\n        this.executeEntry({\n          workflowId,\n          runId,\n          entry: step,\n          prevStep,\n          stepResults,\n          serializedStepGraph,\n          resume,\n          executionContext: {\n            workflowId,\n            runId,\n            executionPath: [...executionContext.executionPath, stepsToRun.indexOf(step)],\n            suspendedPaths: executionContext.suspendedPaths,\n            retryConfig: executionContext.retryConfig,\n            executionSpan: executionContext.executionSpan,\n          },\n          emitter,\n          abortController,\n          runtimeContext,\n          writableStream,\n        }),\n      ),\n    );\n\n    // For conditional blocks, merge executed results with preserved existing results\n    const mergedStepResults: Record<string, StepResult<any, any, any, any>> = { ...stepResults };\n\n    // Update with newly executed results\n    results.forEach(result => {\n      if ('stepResults' in result && result.stepResults) {\n        Object.assign(mergedStepResults, result.stepResults);\n      }\n    });\n\n    // Build allResults based on the merged step results for stepsToRun\n    const allResults = stepsToRun\n      .map(step => {\n        if (step.type === 'step') {\n          const stepResult = mergedStepResults[step.step.id];\n          if (stepResult) {\n            return { result: stepResult };\n          }\n        }\n        return { result: { status: 'success', output: {} } };\n      })\n      .filter(Boolean) as { result: StepResult<any, any, any, any> }[];\n    const hasFailed = allResults.find(result => result.result.status === 'failed') as {\n      result: StepFailure<any, any, any>;\n    };\n    const hasSuspended = allResults.find(result => result.result.status === 'suspended');\n    if (hasFailed) {\n      execResults = { status: 'failed', error: hasFailed.result.error };\n    } else if (hasSuspended) {\n      execResults = { status: 'suspended', payload: hasSuspended.result.suspendPayload };\n    } else if (abortController?.signal?.aborted) {\n      execResults = { status: 'canceled' };\n    } else {\n      execResults = {\n        status: 'success',\n        output: allResults.reduce((acc: Record<string, any>, result, index) => {\n          if (result.result.status === 'success') {\n            // @ts-ignore\n            acc[stepsToRun[index]!.step.id] = result.result.output;\n          }\n\n          return acc;\n        }, {}),\n      };\n    }\n\n    return execResults;\n  }\n\n  async executeLoop({\n    workflowId,\n    runId,\n    entry,\n    prevOutput,\n    stepResults,\n    resume,\n    executionContext,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    entry: {\n      type: 'loop';\n      step: Step;\n      condition: ExecuteFunction<any, any, any, any, DefaultEngineType>;\n      loopType: 'dowhile' | 'dountil';\n    };\n    prevStep: StepFlowEntry;\n    prevOutput: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<StepResult<any, any, any, any>> {\n    const { step, condition } = entry;\n    let isTrue = true;\n    let result = { status: 'success', output: prevOutput } as unknown as StepResult<any, any, any, any>;\n    let currentResume = resume;\n\n    do {\n      result = await this.executeStep({\n        workflowId,\n        runId,\n        step,\n        stepResults,\n        executionContext,\n        resume: currentResume,\n        prevOutput: (result as { output: any }).output,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n\n      // Clear resume for next iteration only if the step has completed resuming\n      // This prevents the same resume data from being used multiple times\n      if (currentResume && result.status !== 'suspended') {\n        currentResume = undefined;\n      }\n\n      if (result.status !== 'success') {\n        return result;\n      }\n\n      isTrue = await condition({\n        workflowId,\n        runId,\n        mastra: this.mastra!,\n        runtimeContext,\n        inputData: result.output,\n        runCount: -1,\n        getInitData: () => stepResults?.input as any,\n        getStepResult: (step: any) => {\n          if (!step?.id) {\n            return null;\n          }\n\n          const result = stepResults[step.id];\n          return result?.status === 'success' ? result.output : null;\n        },\n        suspend: async (_suspendPayload: any): Promise<any> => {},\n        bail: () => {},\n        abort: () => {\n          abortController?.abort();\n        },\n        [EMITTER_SYMBOL]: emitter,\n        engine: {},\n        abortSignal: abortController?.signal,\n        writer: new ToolStream(\n          {\n            prefix: 'step',\n            callId: randomUUID(),\n            name: 'loop',\n            runId,\n          },\n          writableStream,\n        ),\n      });\n    } while (entry.loopType === 'dowhile' ? isTrue : !isTrue);\n\n    return result;\n  }\n\n  async executeForeach({\n    workflowId,\n    runId,\n    entry,\n    prevOutput,\n    stepResults,\n    resume,\n    executionContext,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    entry: {\n      type: 'foreach';\n      step: Step;\n      opts: {\n        concurrency: number;\n      };\n    };\n    prevStep: StepFlowEntry;\n    prevOutput: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<StepResult<any, any, any, any>> {\n    const { step, opts } = entry;\n    const results: StepResult<any, any, any, any>[] = [];\n    const concurrency = opts.concurrency;\n    const startTime = resume?.steps[0] === step.id ? undefined : Date.now();\n    const resumeTime = resume?.steps[0] === step.id ? Date.now() : undefined;\n\n    const stepInfo = {\n      ...stepResults[step.id],\n      ...(resume?.steps[0] === step.id ? { resumePayload: resume?.resumePayload } : { payload: prevOutput }),\n      ...(startTime ? { startedAt: startTime } : {}),\n      ...(resumeTime ? { resumedAt: resumeTime } : {}),\n    };\n\n    await emitter.emit('watch', {\n      type: 'watch',\n      payload: {\n        currentStep: {\n          id: step.id,\n          status: 'running',\n          ...stepInfo,\n        },\n        workflowState: {\n          status: 'running',\n          steps: {\n            ...stepResults,\n            [step.id]: {\n              status: 'running',\n              ...stepInfo,\n            },\n          },\n          result: null,\n          error: null,\n        },\n      },\n      eventTimestamp: Date.now(),\n    });\n    await emitter.emit('watch-v2', {\n      type: 'step-start',\n      payload: {\n        id: step.id,\n        ...stepInfo,\n        status: 'running',\n      },\n    });\n\n    for (let i = 0; i < prevOutput.length; i += concurrency) {\n      const items = prevOutput.slice(i, i + concurrency);\n      const itemsResults = await Promise.all(\n        items.map((item: any) => {\n          return this.executeStep({\n            workflowId,\n            runId,\n            step,\n            stepResults,\n            executionContext,\n            resume,\n            prevOutput: item,\n            emitter,\n            abortController,\n            runtimeContext,\n            skipEmits: true,\n            writableStream,\n          });\n        }),\n      );\n\n      for (const result of itemsResults) {\n        if (result.status !== 'success') {\n          const { status, error, suspendPayload, suspendedAt, endedAt, output } = result;\n          const execResults = { status, error, suspendPayload, suspendedAt, endedAt, output };\n\n          await emitter.emit('watch', {\n            type: 'watch',\n            payload: {\n              currentStep: {\n                id: step.id,\n                ...stepInfo,\n                ...execResults,\n              },\n              workflowState: {\n                status: 'running',\n                steps: {\n                  ...stepResults,\n                  [step.id]: {\n                    ...stepInfo,\n                    ...execResults,\n                  },\n                },\n\n                result: null,\n                error: null,\n              },\n            },\n            eventTimestamp: Date.now(),\n          });\n\n          if (execResults.status === 'suspended') {\n            await emitter.emit('watch-v2', {\n              type: 'step-suspended',\n              payload: {\n                id: step.id,\n                ...execResults,\n              },\n            });\n          } else {\n            await emitter.emit('watch-v2', {\n              type: 'step-result',\n              payload: {\n                id: step.id,\n                ...execResults,\n              },\n            });\n\n            await emitter.emit('watch-v2', {\n              type: 'step-finish',\n              payload: {\n                id: step.id,\n                metadata: {},\n              },\n            });\n          }\n          return result;\n        }\n\n        results.push(result?.output);\n      }\n    }\n\n    await emitter.emit('watch', {\n      type: 'watch',\n      payload: {\n        currentStep: {\n          id: step.id,\n          ...stepInfo,\n          status: 'success',\n          output: results,\n          endedAt: Date.now(),\n        },\n        workflowState: {\n          status: 'running',\n          steps: {\n            ...stepResults,\n            [step.id]: {\n              ...stepInfo,\n              status: 'success',\n              output: results,\n              endedAt: Date.now(),\n            },\n          },\n\n          result: null,\n          error: null,\n        },\n      },\n      eventTimestamp: Date.now(),\n    });\n\n    await emitter.emit('watch-v2', {\n      type: 'step-result',\n      payload: {\n        id: step.id,\n        status: 'success',\n        output: results,\n        endedAt: Date.now(),\n      },\n    });\n\n    await emitter.emit('watch-v2', {\n      type: 'step-finish',\n      payload: {\n        id: step.id,\n        metadata: {},\n      },\n    });\n\n    return {\n      ...stepInfo,\n      status: 'success',\n      output: results,\n      //@ts-ignore\n      endedAt: Date.now(),\n    } as StepSuccess<any, any, any, any>;\n  }\n\n  protected async persistStepUpdate({\n    workflowId,\n    runId,\n    stepResults,\n    serializedStepGraph,\n    executionContext,\n    workflowStatus,\n    result,\n    error,\n    runtimeContext,\n  }: {\n    workflowId: string;\n    runId: string;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    executionContext: ExecutionContext;\n    workflowStatus: 'success' | 'failed' | 'suspended' | 'running' | 'waiting';\n    result?: Record<string, any>;\n    error?: string | Error;\n    runtimeContext: RuntimeContext;\n  }) {\n    const runtimeContextObj: Record<string, any> = {};\n    runtimeContext.forEach((value, key) => {\n      runtimeContextObj[key] = value;\n    });\n\n    await this.mastra?.getStorage()?.persistWorkflowSnapshot({\n      workflowName: workflowId,\n      runId,\n      snapshot: {\n        runId,\n        status: workflowStatus,\n        value: {},\n        context: stepResults as any,\n        activePaths: [],\n        serializedStepGraph,\n        suspendedPaths: executionContext.suspendedPaths,\n        result,\n        error,\n        runtimeContext: runtimeContextObj,\n        // @ts-ignore\n        timestamp: Date.now(),\n      },\n    });\n  }\n\n  async executeEntry({\n    workflowId,\n    runId,\n    entry,\n    prevStep,\n    serializedStepGraph,\n    stepResults,\n    resume,\n    executionContext,\n    emitter,\n    abortController,\n    runtimeContext,\n    writableStream,\n  }: {\n    workflowId: string;\n    runId: string;\n    entry: StepFlowEntry;\n    prevStep: StepFlowEntry;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n    };\n    executionContext: ExecutionContext;\n    emitter: Emitter;\n    abortController: AbortController;\n    runtimeContext: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<{\n    result: StepResult<any, any, any, any>;\n    stepResults?: Record<string, StepResult<any, any, any, any>>;\n    executionContext?: ExecutionContext;\n  }> {\n    const prevOutput = this.getStepOutput(stepResults, prevStep);\n    let execResults: any;\n\n    if (entry.type === 'step') {\n      const { step } = entry;\n      execResults = await this.executeStep({\n        workflowId,\n        runId,\n        step,\n        stepResults,\n        executionContext,\n        resume,\n        prevOutput,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n    } else if (resume?.resumePath?.length && entry.type === 'parallel') {\n      const idx = resume.resumePath.shift();\n      const resumedStepResult = await this.executeEntry({\n        workflowId,\n        runId,\n        entry: entry.steps[idx!]!,\n        prevStep,\n        serializedStepGraph,\n        stepResults,\n        resume,\n        executionContext: {\n          workflowId,\n          runId,\n          executionPath: [...executionContext.executionPath, idx!],\n          suspendedPaths: executionContext.suspendedPaths,\n          retryConfig: executionContext.retryConfig,\n          executionSpan: executionContext.executionSpan,\n        },\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n\n      // After resuming one parallel step, check if ALL parallel steps are complete\n      // Update stepResults with the resumed step's result\n      if (resumedStepResult.stepResults) {\n        Object.assign(stepResults, resumedStepResult.stepResults);\n      }\n\n      // Check the status of all parallel steps in this block\n      const allParallelStepsComplete = entry.steps.every(parallelStep => {\n        if (parallelStep.type === 'step') {\n          const stepResult = stepResults[parallelStep.step.id];\n          return stepResult && stepResult.status === 'success';\n        }\n        return true; // Non-step entries are considered complete\n      });\n\n      if (allParallelStepsComplete) {\n        // All parallel steps are complete, return success for the parallel block\n        execResults = {\n          status: 'success',\n          output: entry.steps.reduce((acc: Record<string, any>, parallelStep) => {\n            if (parallelStep.type === 'step') {\n              const stepResult = stepResults[parallelStep.step.id];\n              if (stepResult && stepResult.status === 'success') {\n                acc[parallelStep.step.id] = stepResult.output;\n              }\n            }\n            return acc;\n          }, {}),\n        };\n      } else {\n        // Some parallel steps are still suspended, keep the parallel block suspended\n        const stillSuspended = entry.steps.find(parallelStep => {\n          if (parallelStep.type === 'step') {\n            const stepResult = stepResults[parallelStep.step.id];\n            return stepResult && stepResult.status === 'suspended';\n          }\n          return false;\n        });\n        execResults = {\n          status: 'suspended',\n          payload:\n            stillSuspended && stillSuspended.type === 'step' ? stepResults[stillSuspended.step.id]?.suspendPayload : {},\n        };\n      }\n\n      // Ensure execution context includes suspended paths for non-resumed steps\n      const updatedExecutionContext: ExecutionContext = {\n        ...executionContext,\n        ...resumedStepResult.executionContext,\n        suspendedPaths: {\n          ...executionContext.suspendedPaths,\n          ...resumedStepResult.executionContext?.suspendedPaths,\n        },\n      };\n\n      // For suspended parallel blocks, maintain suspended paths for non-resumed steps\n      if (execResults.status === 'suspended') {\n        entry.steps.forEach((parallelStep, stepIndex) => {\n          if (parallelStep.type === 'step') {\n            const stepResult = stepResults[parallelStep.step.id];\n            if (stepResult && stepResult.status === 'suspended') {\n              // Ensure this step remains in suspendedPaths\n              updatedExecutionContext.suspendedPaths[parallelStep.step.id] = [\n                ...executionContext.executionPath,\n                stepIndex,\n              ];\n            }\n          }\n        });\n      }\n\n      return {\n        result: execResults,\n        stepResults: resumedStepResult.stepResults,\n        executionContext: updatedExecutionContext,\n      };\n    } else if (entry.type === 'parallel') {\n      execResults = await this.executeParallel({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        stepResults,\n        serializedStepGraph,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n    } else if (entry.type === 'conditional') {\n      execResults = await this.executeConditional({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        prevOutput,\n        stepResults,\n        serializedStepGraph,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n    } else if (entry.type === 'loop') {\n      execResults = await this.executeLoop({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        prevOutput,\n        stepResults,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n    } else if (entry.type === 'foreach') {\n      execResults = await this.executeForeach({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        prevOutput,\n        stepResults,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n    } else if (entry.type === 'sleep') {\n      const startedAt = Date.now();\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: entry.id,\n            status: 'waiting',\n            payload: prevOutput,\n            startedAt,\n          },\n          workflowState: {\n            status: 'waiting',\n            steps: {\n              ...stepResults,\n              [entry.id]: {\n                status: 'waiting',\n                payload: prevOutput,\n                startedAt,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-waiting',\n        payload: {\n          id: entry.id,\n          payload: prevOutput,\n          startedAt,\n          status: 'waiting',\n        },\n      });\n      await this.persistStepUpdate({\n        workflowId,\n        runId,\n        serializedStepGraph,\n        stepResults,\n        executionContext,\n        workflowStatus: 'waiting',\n        runtimeContext,\n      });\n\n      await this.executeSleep({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        prevOutput,\n        stepResults,\n        serializedStepGraph,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n\n      await this.persistStepUpdate({\n        workflowId,\n        runId,\n        serializedStepGraph,\n        stepResults,\n        executionContext,\n        workflowStatus: 'running',\n        runtimeContext,\n      });\n\n      const endedAt = Date.now();\n      const stepInfo = {\n        payload: prevOutput,\n        startedAt,\n        endedAt,\n      };\n\n      execResults = { ...stepInfo, status: 'success', output: prevOutput };\n      stepResults[entry.id] = { ...stepInfo, status: 'success', output: prevOutput };\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: entry.id,\n            ...execResults,\n          },\n          workflowState: {\n            status: 'running',\n            steps: {\n              ...stepResults,\n              [entry.id]: {\n                ...execResults,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-result',\n        payload: {\n          id: entry.id,\n          endedAt,\n          status: 'success',\n          output: prevOutput,\n        },\n      });\n\n      await emitter.emit('watch-v2', {\n        type: 'step-finish',\n        payload: {\n          id: entry.id,\n          metadata: {},\n        },\n      });\n    } else if (entry.type === 'sleepUntil') {\n      const startedAt = Date.now();\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: entry.id,\n            status: 'waiting',\n            payload: prevOutput,\n            startedAt,\n          },\n          workflowState: {\n            status: 'waiting',\n            steps: {\n              ...stepResults,\n              [entry.id]: {\n                status: 'waiting',\n                payload: prevOutput,\n                startedAt,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-waiting',\n        payload: {\n          id: entry.id,\n          payload: prevOutput,\n          startedAt,\n          status: 'waiting',\n        },\n      });\n\n      await this.persistStepUpdate({\n        workflowId,\n        runId,\n        serializedStepGraph,\n        stepResults,\n        executionContext,\n        workflowStatus: 'waiting',\n        runtimeContext,\n      });\n\n      await this.executeSleepUntil({\n        workflowId,\n        runId,\n        entry,\n        prevStep,\n        prevOutput,\n        stepResults,\n        serializedStepGraph,\n        resume,\n        executionContext,\n        emitter,\n        abortController,\n        runtimeContext,\n        writableStream,\n      });\n\n      await this.persistStepUpdate({\n        workflowId,\n        runId,\n        serializedStepGraph,\n        stepResults,\n        executionContext,\n        workflowStatus: 'running',\n        runtimeContext,\n      });\n\n      const endedAt = Date.now();\n      const stepInfo = {\n        payload: prevOutput,\n        startedAt,\n        endedAt,\n      };\n\n      execResults = { ...stepInfo, status: 'success', output: prevOutput };\n      stepResults[entry.id] = { ...stepInfo, status: 'success', output: prevOutput };\n\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: entry.id,\n            ...execResults,\n          },\n          workflowState: {\n            status: 'running',\n            steps: {\n              ...stepResults,\n              [entry.id]: {\n                ...execResults,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-result',\n        payload: {\n          id: entry.id,\n          endedAt,\n          status: 'success',\n          output: prevOutput,\n        },\n      });\n\n      await emitter.emit('watch-v2', {\n        type: 'step-finish',\n        payload: {\n          id: entry.id,\n          metadata: {},\n        },\n      });\n    } else if (entry.type === 'waitForEvent') {\n      const startedAt = Date.now();\n      let eventData: any;\n      await emitter.emit('watch', {\n        type: 'watch',\n        payload: {\n          currentStep: {\n            id: entry.step.id,\n            status: 'waiting',\n            payload: prevOutput,\n            startedAt,\n          },\n          workflowState: {\n            status: 'waiting',\n            steps: {\n              ...stepResults,\n              [entry.step.id]: {\n                status: 'waiting',\n                payload: prevOutput,\n                startedAt,\n              },\n            },\n            result: null,\n            error: null,\n          },\n        },\n        eventTimestamp: Date.now(),\n      });\n      await emitter.emit('watch-v2', {\n        type: 'step-waiting',\n        payload: {\n          id: entry.step.id,\n          payload: prevOutput,\n          startedAt,\n          status: 'waiting',\n        },\n      });\n\n      await this.persistStepUpdate({\n        workflowId,\n        runId,\n        serializedStepGraph,\n        stepResults,\n        executionContext,\n        workflowStatus: 'waiting',\n        runtimeContext,\n      });\n\n      try {\n        eventData = await this.executeWaitForEvent({ event: entry.event, emitter, timeout: entry.timeout });\n\n        await this.persistStepUpdate({\n          workflowId,\n          runId,\n          serializedStepGraph,\n          stepResults,\n          executionContext,\n          workflowStatus: 'running',\n          runtimeContext,\n        });\n\n        const { step } = entry;\n        execResults = await this.executeStep({\n          workflowId,\n          runId,\n          step,\n          stepResults,\n          executionContext,\n          resume: {\n            resumePayload: eventData,\n            steps: [entry.step.id],\n          },\n          prevOutput,\n          emitter,\n          abortController,\n          runtimeContext,\n          writableStream,\n        });\n      } catch (error) {\n        execResults = {\n          status: 'failed',\n          error: error as Error,\n        };\n      }\n      const endedAt = Date.now();\n      const stepInfo = {\n        payload: prevOutput,\n        startedAt,\n        endedAt,\n      };\n\n      execResults = { ...execResults, ...stepInfo };\n    }\n\n    if (entry.type === 'step' || entry.type === 'waitForEvent' || entry.type === 'loop' || entry.type === 'foreach') {\n      stepResults[entry.step.id] = execResults;\n    }\n\n    if (abortController?.signal?.aborted) {\n      execResults = { ...execResults, status: 'canceled' };\n    }\n\n    await this.persistStepUpdate({\n      workflowId,\n      runId,\n      serializedStepGraph,\n      stepResults,\n      executionContext,\n      workflowStatus: execResults.status === 'success' ? 'running' : execResults.status,\n      runtimeContext,\n    });\n\n    return { result: execResults, stepResults, executionContext };\n  }\n}\n","import { ReadableStream } from 'stream/web';\nimport type { Run } from '../workflows';\n\nexport type ChunkType = {\n  type: string;\n  runId: string;\n  from: string;\n  payload: Record<string, any>;\n};\n\nexport class MastraWorkflowStream extends ReadableStream<ChunkType> {\n  #usageCount = {\n    promptTokens: 0,\n    completionTokens: 0,\n    totalTokens: 0,\n  };\n  #streamPromise: {\n    promise: Promise<void>;\n    resolve: (value: void) => void;\n    reject: (reason?: any) => void;\n  };\n  #run: Run;\n\n  constructor({\n    createStream,\n    run,\n  }: {\n    createStream: (writer: WritableStream<ChunkType>) => Promise<ReadableStream<any>> | ReadableStream<any>;\n    run: Run;\n  }) {\n    const deferredPromise = {\n      promise: null,\n      resolve: null,\n      reject: null,\n    } as unknown as {\n      promise: Promise<void>;\n      resolve: (value: void) => void;\n      reject: (reason?: any) => void;\n    };\n    deferredPromise.promise = new Promise((resolve, reject) => {\n      deferredPromise.resolve = resolve;\n      deferredPromise.reject = reject;\n    });\n\n    const updateUsageCount = (usage: {\n      promptTokens?: `${number}` | number;\n      completionTokens?: `${number}` | number;\n      totalTokens?: `${number}` | number;\n    }) => {\n      this.#usageCount.promptTokens += parseInt(usage.promptTokens?.toString() ?? '0', 10);\n      this.#usageCount.completionTokens += parseInt(usage.completionTokens?.toString() ?? '0', 10);\n      this.#usageCount.totalTokens += parseInt(usage.totalTokens?.toString() ?? '0', 10);\n    };\n\n    super({\n      start: async controller => {\n        const writer = new WritableStream<ChunkType>({\n          write: chunk => {\n            if (\n              (chunk.type === 'step-output' &&\n                chunk.payload?.output?.from === 'AGENT' &&\n                chunk.payload?.output?.type === 'finish') ||\n              (chunk.type === 'step-output' &&\n                chunk.payload?.output?.from === 'WORKFLOW' &&\n                chunk.payload?.output?.type === 'finish')\n            ) {\n              const finishPayload = chunk.payload?.output.payload;\n              updateUsageCount(finishPayload.usage);\n            }\n\n            controller.enqueue(chunk);\n          },\n        });\n\n        controller.enqueue({\n          type: 'start',\n          runId: run.runId,\n          from: 'WORKFLOW',\n          payload: {},\n        });\n\n        const stream = await createStream(writer);\n\n        for await (const chunk of stream) {\n          // update the usage count\n          if (\n            (chunk.type === 'step-output' &&\n              chunk.payload?.output?.from === 'AGENT' &&\n              chunk.payload?.output?.type === 'finish') ||\n            (chunk.type === 'step-output' &&\n              chunk.payload?.output?.from === 'WORKFLOW' &&\n              chunk.payload?.output?.type === 'finish')\n          ) {\n            const finishPayload = chunk.payload?.output.payload;\n            updateUsageCount(finishPayload.usage);\n          }\n\n          controller.enqueue(chunk);\n        }\n\n        controller.enqueue({\n          type: 'finish',\n          runId: run.runId,\n          from: 'WORKFLOW',\n          payload: {\n            totalUsage: this.#usageCount,\n          },\n        });\n\n        stream;\n\n        controller.close();\n        deferredPromise.resolve();\n      },\n    });\n\n    this.#run = run;\n    this.#streamPromise = deferredPromise;\n  }\n\n  get status() {\n    return this.#streamPromise.promise.then(() => this.#run._getExecutionResults()).then(res => res!.status);\n  }\n\n  get result() {\n    return this.#streamPromise.promise.then(() => this.#run._getExecutionResults());\n  }\n\n  get usage() {\n    return this.#streamPromise.promise.then(() => this.#usageCount);\n  }\n}\n","import { randomUUID } from 'crypto';\nimport EventEmitter from 'events';\nimport type { ReadableStream, WritableStream } from 'node:stream/web';\nimport { TransformStream } from 'node:stream/web';\nimport { z } from 'zod';\nimport type { Mastra, WorkflowRun } from '..';\nimport type { MastraPrimitives } from '../action';\nimport { Agent } from '../agent';\nimport { MastraBase } from '../base';\nimport { RuntimeContext } from '../di';\nimport { RegisteredLogger } from '../logger';\nimport type { MastraScorers } from '../scores';\nimport { runScorer } from '../scores/hooks';\nimport type { ChunkType } from '../stream/MastraAgentStream';\nimport { MastraWorkflowStream } from '../stream/MastraWorkflowStream';\nimport { Tool } from '../tools';\nimport type { ToolExecutionContext } from '../tools/types';\nimport type { DynamicArgument } from '../types';\nimport { EMITTER_SYMBOL } from './constants';\nimport { DefaultExecutionEngine } from './default';\nimport type { ExecutionEngine, ExecutionGraph } from './execution-engine';\nimport type { ExecuteFunction, ExecuteFunctionParams, Step } from './step';\nimport type {\n  DynamicMapping,\n  ExtractSchemaFromStep,\n  ExtractSchemaType,\n  PathsToStringProps,\n  StepResult,\n  StepsRecord,\n  StreamEvent,\n  WatchEvent,\n  WorkflowRunState,\n} from './types';\n\nexport type DefaultEngineType = {};\n\nexport type StepFlowEntry<TEngineType = DefaultEngineType> =\n  | { type: 'step'; step: Step }\n  | { type: 'sleep'; id: string; duration?: number; fn?: ExecuteFunction<any, any, any, any, TEngineType> }\n  | { type: 'sleepUntil'; id: string; date?: Date; fn?: ExecuteFunction<any, any, any, any, TEngineType> }\n  | { type: 'waitForEvent'; event: string; step: Step; timeout?: number }\n  | {\n      type: 'parallel';\n      steps: StepFlowEntry[];\n    }\n  | {\n      type: 'conditional';\n      steps: StepFlowEntry[];\n      conditions: ExecuteFunction<any, any, any, any, TEngineType>[];\n      serializedConditions: { id: string; fn: string }[];\n    }\n  | {\n      type: 'loop';\n      step: Step;\n      condition: ExecuteFunction<any, any, any, any, TEngineType>;\n      serializedCondition: { id: string; fn: string };\n      loopType: 'dowhile' | 'dountil';\n    }\n  | {\n      type: 'foreach';\n      step: Step;\n      opts: {\n        concurrency: number;\n      };\n    };\n\nexport type SerializedStep<TEngineType = DefaultEngineType> = Pick<\n  Step<any, any, any, any, any, TEngineType>,\n  'id' | 'description'\n> & {\n  component?: string;\n  serializedStepFlow?: SerializedStepFlowEntry[];\n  mapConfig?: string;\n};\n\nexport type SerializedStepFlowEntry =\n  | {\n      type: 'step';\n      step: SerializedStep;\n    }\n  | {\n      type: 'sleep';\n      id: string;\n      duration?: number;\n      fn?: string;\n    }\n  | {\n      type: 'sleepUntil';\n      id: string;\n      date?: Date;\n      fn?: string;\n    }\n  | {\n      type: 'waitForEvent';\n      event: string;\n      step: SerializedStep;\n      timeout?: number;\n    }\n  | {\n      type: 'parallel';\n      steps: SerializedStepFlowEntry[];\n    }\n  | {\n      type: 'conditional';\n      steps: SerializedStepFlowEntry[];\n      serializedConditions: { id: string; fn: string }[];\n    }\n  | {\n      type: 'loop';\n      step: SerializedStep;\n      serializedCondition: { id: string; fn: string };\n      loopType: 'dowhile' | 'dountil';\n    }\n  | {\n      type: 'foreach';\n      step: SerializedStep;\n      opts: {\n        concurrency: number;\n      };\n    };\n\nexport type StepWithComponent = Step<string, any, any, any, any, any> & {\n  component?: string;\n  steps?: Record<string, StepWithComponent>;\n};\n\nexport function mapVariable<TStep extends Step<string, any, any, any, any, any>>({\n  step,\n  path,\n}: {\n  step: TStep;\n  path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '.';\n}): {\n  step: TStep;\n  path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '.';\n};\nexport function mapVariable<TWorkflow extends Workflow<any, any, any, any, any, any>>({\n  initData: TWorkflow,\n  path,\n}: {\n  initData: TWorkflow;\n  path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TWorkflow, 'inputSchema'>>> | '.';\n}): {\n  initData: TWorkflow;\n  path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TWorkflow, 'inputSchema'>>> | '.';\n};\nexport function mapVariable(config: any): any {\n  return config;\n}\n\ntype StepParams<\n  TStepId extends string,\n  TStepInput extends z.ZodType<any>,\n  TStepOutput extends z.ZodType<any>,\n  TResumeSchema extends z.ZodType<any>,\n  TSuspendSchema extends z.ZodType<any>,\n> = {\n  id: TStepId;\n  description?: string;\n  inputSchema: TStepInput;\n  outputSchema: TStepOutput;\n  resumeSchema?: TResumeSchema;\n  suspendSchema?: TSuspendSchema;\n  retries?: number;\n  scorers?: DynamicArgument<MastraScorers>;\n  execute: ExecuteFunction<\n    z.infer<TStepInput>,\n    z.infer<TStepOutput>,\n    z.infer<TResumeSchema>,\n    z.infer<TSuspendSchema>,\n    DefaultEngineType\n  >;\n};\n\ntype ToolStep<\n  TSchemaIn extends z.ZodType<any>,\n  TSchemaOut extends z.ZodType<any>,\n  TContext extends ToolExecutionContext<TSchemaIn>,\n> = Tool<TSchemaIn, TSchemaOut, TContext> & {\n  inputSchema: TSchemaIn;\n  outputSchema: TSchemaOut;\n  execute: (context: TContext) => Promise<any>;\n};\n\n/**\n * Creates a new workflow step\n * @param params Configuration parameters for the step\n * @param params.id Unique identifier for the step\n * @param params.description Optional description of what the step does\n * @param params.inputSchema Zod schema defining the input structure\n * @param params.outputSchema Zod schema defining the output structure\n * @param params.execute Function that performs the step's operations\n * @returns A Step object that can be added to the workflow\n */\nexport function createStep<\n  TStepId extends string,\n  TStepInput extends z.ZodType<any>,\n  TStepOutput extends z.ZodType<any>,\n  TResumeSchema extends z.ZodType<any>,\n  TSuspendSchema extends z.ZodType<any>,\n>(\n  params: StepParams<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema>,\n): Step<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, DefaultEngineType>;\n\nexport function createStep<\n  TStepId extends string,\n  TStepInput extends z.ZodObject<{ prompt: z.ZodString }>,\n  TStepOutput extends z.ZodObject<{ text: z.ZodString }>,\n  TResumeSchema extends z.ZodType<any>,\n  TSuspendSchema extends z.ZodType<any>,\n>(\n  agent: Agent<TStepId, any, any>,\n): Step<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, DefaultEngineType>;\n\nexport function createStep<\n  TSchemaIn extends z.ZodType<any>,\n  TSchemaOut extends z.ZodType<any>,\n  TContext extends ToolExecutionContext<TSchemaIn>,\n>(\n  tool: ToolStep<TSchemaIn, TSchemaOut, TContext>,\n): Step<string, TSchemaIn, TSchemaOut, z.ZodType<any>, z.ZodType<any>, DefaultEngineType>;\n\nexport function createStep<\n  TStepId extends string,\n  TStepInput extends z.ZodType<any>,\n  TStepOutput extends z.ZodType<any>,\n  TResumeSchema extends z.ZodType<any>,\n  TSuspendSchema extends z.ZodType<any>,\n>(\n  params:\n    | StepParams<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema>\n    | Agent<any, any, any>\n    | ToolStep<TStepInput, TStepOutput, any>,\n): Step<TStepId, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, DefaultEngineType> {\n  const wrapExecute = (\n    execute: ExecuteFunction<\n      z.infer<TStepInput>,\n      z.infer<TStepOutput>,\n      z.infer<TResumeSchema>,\n      z.infer<TSuspendSchema>,\n      DefaultEngineType\n    >,\n  ) => {\n    return async (\n      executeParams: ExecuteFunctionParams<\n        z.infer<TStepInput>,\n        z.infer<TResumeSchema>,\n        z.infer<TSuspendSchema>,\n        DefaultEngineType\n      >,\n    ) => {\n      const executeResult = await execute(executeParams);\n\n      if (params instanceof Agent || params instanceof Tool) {\n        return executeResult;\n      }\n\n      let scorersToUse = params.scorers;\n\n      if (typeof scorersToUse === 'function') {\n        scorersToUse = await scorersToUse({\n          runtimeContext: executeParams.runtimeContext,\n        });\n      }\n\n      if (scorersToUse && Object.keys(scorersToUse || {}).length > 0) {\n        for (const [id, scorerObject] of Object.entries(scorersToUse || {})) {\n          runScorer({\n            scorerId: id,\n            scorerObject: scorerObject,\n            runId: executeParams.runId,\n            input: [executeParams.inputData],\n            output: executeResult,\n            runtimeContext: executeParams.runtimeContext,\n            entity: {\n              id: executeParams.workflowId,\n              stepId: params.id,\n            },\n            structuredOutput: true,\n            source: 'LIVE',\n            entityType: 'WORKFLOW',\n          });\n        }\n      }\n\n      return executeResult;\n    };\n  };\n\n  if (params instanceof Agent) {\n    return {\n      id: params.name,\n      // @ts-ignore\n      inputSchema: z.object({\n        prompt: z.string(),\n        // resourceId: z.string().optional(),\n        // threadId: z.string().optional(),\n      }),\n      // @ts-ignore\n      outputSchema: z.object({\n        text: z.string(),\n      }),\n      execute: wrapExecute(async ({ inputData, [EMITTER_SYMBOL]: emitter, runtimeContext, abortSignal, abort }) => {\n        let streamPromise = {} as {\n          promise: Promise<string>;\n          resolve: (value: string) => void;\n          reject: (reason?: any) => void;\n        };\n\n        streamPromise.promise = new Promise((resolve, reject) => {\n          streamPromise.resolve = resolve;\n          streamPromise.reject = reject;\n        });\n        const toolData = {\n          name: params.name,\n          args: inputData,\n        };\n        await emitter.emit('watch-v2', {\n          type: 'tool-call-streaming-start',\n          ...toolData,\n        });\n        const { fullStream } = await params.stream(inputData.prompt, {\n          // resourceId: inputData.resourceId,\n          // threadId: inputData.threadId,\n          runtimeContext,\n          onFinish: result => {\n            streamPromise.resolve(result.text);\n          },\n          abortSignal,\n        });\n\n        if (abortSignal.aborted) {\n          return abort();\n        }\n\n        for await (const chunk of fullStream) {\n          switch (chunk.type) {\n            case 'text-delta':\n              await emitter.emit('watch-v2', {\n                type: 'tool-call-delta',\n                ...toolData,\n                argsTextDelta: chunk.textDelta,\n              });\n              break;\n\n            case 'step-start':\n            case 'step-finish':\n            case 'finish':\n              break;\n\n            case 'tool-call':\n            case 'tool-result':\n            case 'tool-call-streaming-start':\n            case 'tool-call-delta':\n            case 'source':\n            case 'file':\n            default:\n              await emitter.emit('watch-v2', chunk);\n              break;\n          }\n        }\n\n        return {\n          text: await streamPromise.promise,\n        };\n      }),\n    };\n  }\n\n  if (params instanceof Tool) {\n    if (!params.inputSchema || !params.outputSchema) {\n      throw new Error('Tool must have input and output schemas defined');\n    }\n\n    return {\n      // TODO: tool probably should have strong id type\n      // @ts-ignore\n      id: params.id,\n      inputSchema: params.inputSchema,\n      outputSchema: params.outputSchema,\n      execute: wrapExecute(async ({ inputData, mastra, runtimeContext }) => {\n        return params.execute({\n          context: inputData,\n          mastra,\n          runtimeContext,\n        });\n      }),\n    };\n  }\n\n  return {\n    id: params.id,\n    description: params.description,\n    inputSchema: params.inputSchema,\n    outputSchema: params.outputSchema,\n    resumeSchema: params.resumeSchema,\n    suspendSchema: params.suspendSchema,\n    scorers: params.scorers,\n    retries: params.retries,\n    execute: wrapExecute(params.execute),\n  };\n}\n\nexport function cloneStep<TStepId extends string>(\n  step: Step<string, any, any, any, any, DefaultEngineType>,\n  opts: { id: TStepId },\n): Step<TStepId, any, any, any, any, DefaultEngineType> {\n  return {\n    id: opts.id,\n    description: step.description,\n    inputSchema: step.inputSchema,\n    outputSchema: step.outputSchema,\n    execute: step.execute,\n    retries: step.retries,\n  };\n}\n\nexport function createWorkflow<\n  TWorkflowId extends string = string,\n  TInput extends z.ZodType<any> = z.ZodType<any>,\n  TOutput extends z.ZodType<any> = z.ZodType<any>,\n  TSteps extends Step<string, any, any, any, any, DefaultEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    DefaultEngineType\n  >[],\n>(params: WorkflowConfig<TWorkflowId, TInput, TOutput, TSteps>) {\n  return new Workflow<DefaultEngineType, TSteps, TWorkflowId, TInput, TOutput, TInput>(params);\n}\n\nexport function cloneWorkflow<\n  TWorkflowId extends string = string,\n  TInput extends z.ZodType<any> = z.ZodType<any>,\n  TOutput extends z.ZodType<any> = z.ZodType<any>,\n  TSteps extends Step<string, any, any, any, any, DefaultEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    DefaultEngineType\n  >[],\n  TPrevSchema extends z.ZodType<any> = TInput,\n>(\n  workflow: Workflow<DefaultEngineType, TSteps, string, TInput, TOutput, TPrevSchema>,\n  opts: { id: TWorkflowId },\n): Workflow<DefaultEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema> {\n  const wf: Workflow<DefaultEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema> = new Workflow({\n    id: opts.id,\n    inputSchema: workflow.inputSchema,\n    outputSchema: workflow.outputSchema,\n    steps: workflow.stepDefs,\n    mastra: workflow.mastra,\n  });\n\n  wf.setStepFlow(workflow.stepGraph);\n  wf.commit();\n  return wf;\n}\n\nexport type WorkflowResult<TOutput extends z.ZodType<any>, TSteps extends Step<string, any, any>[]> =\n  | {\n      status: 'success';\n      result: z.infer<TOutput>;\n      steps: {\n        [K in keyof StepsRecord<TSteps>]: StepsRecord<TSteps>[K]['outputSchema'] extends undefined\n          ? StepResult<unknown, unknown, unknown, unknown>\n          : StepResult<\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['inputSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['resumeSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['suspendSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['outputSchema']>>\n            >;\n      };\n    }\n  | {\n      status: 'failed';\n      steps: {\n        [K in keyof StepsRecord<TSteps>]: StepsRecord<TSteps>[K]['outputSchema'] extends undefined\n          ? StepResult<unknown, unknown, unknown, unknown>\n          : StepResult<\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['inputSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['resumeSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['suspendSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['outputSchema']>>\n            >;\n      };\n      error: Error;\n    }\n  | {\n      status: 'suspended';\n      steps: {\n        [K in keyof StepsRecord<TSteps>]: StepsRecord<TSteps>[K]['outputSchema'] extends undefined\n          ? StepResult<unknown, unknown, unknown, unknown>\n          : StepResult<\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['inputSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['resumeSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['suspendSchema']>>,\n              z.infer<NonNullable<StepsRecord<TSteps>[K]['outputSchema']>>\n            >;\n      };\n      suspended: [string[], ...string[][]];\n    };\n\nexport type WorkflowConfig<\n  TWorkflowId extends string = string,\n  TInput extends z.ZodType<any> = z.ZodType<any>,\n  TOutput extends z.ZodType<any> = z.ZodType<any>,\n  TSteps extends Step<string, any, any, any, any, any>[] = Step<string, any, any, any, any, any>[],\n> = {\n  mastra?: Mastra;\n  id: TWorkflowId;\n  description?: string | undefined;\n  inputSchema: TInput;\n  outputSchema: TOutput;\n  executionEngine?: ExecutionEngine;\n  steps?: TSteps;\n  retryConfig?: {\n    attempts?: number;\n    delay?: number;\n  };\n};\n\nexport class Workflow<\n    TEngineType = any,\n    TSteps extends Step<string, any, any, any, any, TEngineType>[] = Step<string, any, any, any, any, TEngineType>[],\n    TWorkflowId extends string = string,\n    TInput extends z.ZodType<any> = z.ZodType<any>,\n    TOutput extends z.ZodType<any> = z.ZodType<any>,\n    TPrevSchema extends z.ZodType<any> = TInput,\n  >\n  extends MastraBase\n  implements Step<TWorkflowId, TInput, TOutput, any, any, DefaultEngineType>\n{\n  public id: TWorkflowId;\n  public description?: string | undefined;\n  public inputSchema: TInput;\n  public outputSchema: TOutput;\n  public steps: Record<string, StepWithComponent>;\n  public stepDefs?: TSteps;\n  protected stepFlow: StepFlowEntry<TEngineType>[];\n  protected serializedStepFlow: SerializedStepFlowEntry[];\n  protected executionEngine: ExecutionEngine;\n  protected executionGraph: ExecutionGraph;\n  protected retryConfig: {\n    attempts?: number;\n    delay?: number;\n  };\n\n  #mastra?: Mastra;\n\n  #runs: Map<string, Run<TEngineType, TSteps, TInput, TOutput>> = new Map();\n\n  constructor({\n    mastra,\n    id,\n    inputSchema,\n    outputSchema,\n    description,\n    executionEngine,\n    retryConfig,\n    steps,\n  }: WorkflowConfig<TWorkflowId, TInput, TOutput, TSteps>) {\n    super({ name: id, component: RegisteredLogger.WORKFLOW });\n    this.id = id;\n    this.description = description;\n    this.inputSchema = inputSchema;\n    this.outputSchema = outputSchema;\n    this.retryConfig = retryConfig ?? { attempts: 0, delay: 0 };\n    this.executionGraph = this.buildExecutionGraph();\n    this.stepFlow = [];\n    this.serializedStepFlow = [];\n    this.#mastra = mastra;\n    this.steps = {};\n    this.stepDefs = steps;\n\n    if (!executionEngine) {\n      // TODO: this should be configured using the Mastra class instance that's passed in\n      this.executionEngine = new DefaultExecutionEngine({ mastra: this.#mastra });\n    } else {\n      this.executionEngine = executionEngine;\n    }\n\n    this.#runs = new Map();\n  }\n\n  get runs() {\n    return this.#runs;\n  }\n\n  get mastra() {\n    return this.#mastra;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.#mastra = mastra;\n    this.executionEngine.__registerMastra(mastra);\n  }\n\n  __registerPrimitives(p: MastraPrimitives) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n  }\n\n  setStepFlow(stepFlow: StepFlowEntry<TEngineType>[]) {\n    this.stepFlow = stepFlow;\n  }\n\n  /**\n   * Adds a step to the workflow\n   * @param step The step to add to the workflow\n   * @returns The workflow instance for chaining\n   */\n  then<TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut extends z.ZodType<any>>(\n    step: Step<TStepId, TStepInputSchema, TSchemaOut, any, any, TEngineType>,\n  ) {\n    this.stepFlow.push({ type: 'step', step: step as any });\n    this.serializedStepFlow.push({\n      type: 'step',\n      step: {\n        id: step.id,\n        description: step.description,\n        component: (step as SerializedStep).component,\n        serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n      },\n    });\n    this.steps[step.id] = step;\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TSchemaOut>;\n  }\n\n  /**\n   * Adds a sleep step to the workflow\n   * @param duration The duration to sleep for\n   * @returns The workflow instance for chaining\n   */\n  sleep(duration: number | ExecuteFunction<z.infer<TPrevSchema>, number, any, any, TEngineType>) {\n    const id = `sleep_${this.#mastra?.generateId() || randomUUID()}`;\n\n    const opts: StepFlowEntry<TEngineType> =\n      typeof duration === 'function'\n        ? { type: 'sleep', id, fn: duration }\n        : { type: 'sleep', id, duration: duration as number };\n    const serializedOpts: SerializedStepFlowEntry =\n      typeof duration === 'function'\n        ? { type: 'sleep', id, fn: duration.toString() }\n        : { type: 'sleep', id, duration: duration as number };\n\n    this.stepFlow.push(opts);\n    this.serializedStepFlow.push(serializedOpts);\n    this.steps[id] = createStep({\n      id,\n      inputSchema: z.object({}),\n      outputSchema: z.object({}),\n      execute: async () => {\n        return {};\n      },\n    });\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema>;\n  }\n\n  /**\n   * Adds a sleep until step to the workflow\n   * @param date The date to sleep until\n   * @returns The workflow instance for chaining\n   */\n  sleepUntil(date: Date | ExecuteFunction<z.infer<TPrevSchema>, Date, any, any, TEngineType>) {\n    const id = `sleep_${this.#mastra?.generateId() || randomUUID()}`;\n    const opts: StepFlowEntry<TEngineType> =\n      typeof date === 'function'\n        ? { type: 'sleepUntil', id, fn: date }\n        : { type: 'sleepUntil', id, date: date as Date };\n    const serializedOpts: SerializedStepFlowEntry =\n      typeof date === 'function'\n        ? { type: 'sleepUntil', id, fn: date.toString() }\n        : { type: 'sleepUntil', id, date: date as Date };\n\n    this.stepFlow.push(opts);\n    this.serializedStepFlow.push(serializedOpts);\n    this.steps[id] = createStep({\n      id,\n      inputSchema: z.object({}),\n      outputSchema: z.object({}),\n      execute: async () => {\n        return {};\n      },\n    });\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TPrevSchema>;\n  }\n\n  waitForEvent<TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut extends z.ZodType<any>>(\n    event: string,\n    step: Step<TStepId, TStepInputSchema, TSchemaOut, any, any, TEngineType>,\n    opts?: {\n      timeout?: number;\n    },\n  ) {\n    this.stepFlow.push({ type: 'waitForEvent', event, step: step as any, timeout: opts?.timeout });\n    this.serializedStepFlow.push({\n      type: 'waitForEvent',\n      event,\n      step: {\n        id: step.id,\n        description: step.description,\n        component: (step as SerializedStep).component,\n        serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n      },\n      timeout: opts?.timeout,\n    });\n    this.steps[step.id] = step;\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TSchemaOut>;\n  }\n\n  map(\n    mappingConfig:\n      | {\n          [k: string]:\n            | {\n                step: Step<string, any, any, any, any, TEngineType> | Step<string, any, any, any, any, TEngineType>[];\n                path: string;\n              }\n            | { value: any; schema: z.ZodType<any> }\n            | {\n                initData: Workflow<TEngineType, any, any, any, any, any>;\n                path: string;\n              }\n            | {\n                runtimeContextPath: string;\n                schema: z.ZodType<any>;\n              }\n            | DynamicMapping<TPrevSchema, z.ZodType<any>>;\n        }\n      | ExecuteFunction<z.infer<TPrevSchema>, any, any, any, TEngineType>,\n  ) {\n    // Create an implicit step that handles the mapping\n    if (typeof mappingConfig === 'function') {\n      // @ts-ignore\n      const mappingStep: any = createStep({\n        id: `mapping_${this.#mastra?.generateId() || randomUUID()}`,\n        inputSchema: z.object({}),\n        outputSchema: z.object({}),\n        execute: mappingConfig as any,\n      });\n\n      this.stepFlow.push({ type: 'step', step: mappingStep as any });\n      this.serializedStepFlow.push({\n        type: 'step',\n        step: {\n          id: mappingStep.id,\n          mapConfig: mappingConfig.toString(),\n        },\n      });\n      return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, any>;\n    }\n\n    const newMappingConfig: Record<string, any> = Object.entries(mappingConfig).reduce(\n      (a, [key, mapping]) => {\n        const m: any = mapping;\n        if (m.value !== undefined) {\n          a[key] = m;\n        } else if (m.fn !== undefined) {\n          a[key] = {\n            fn: m.fn.toString(),\n            schema: m.schema,\n          };\n        } else if (m.runtimeContextPath) {\n          a[key] = {\n            runtimeContextPath: m.runtimeContextPath,\n            schema: m.schema,\n          };\n        } else {\n          a[key] = m;\n        }\n        return a;\n      },\n      {} as Record<string, any>,\n    );\n\n    const mappingStep: any = createStep({\n      id: `mapping_${this.#mastra?.generateId() || randomUUID()}`,\n      inputSchema: z.object({}),\n      outputSchema: z.object({}),\n      execute: async ctx => {\n        const { getStepResult, getInitData, runtimeContext } = ctx;\n\n        const result: Record<string, any> = {};\n        for (const [key, mapping] of Object.entries(mappingConfig)) {\n          const m: any = mapping;\n\n          if (m.value !== undefined) {\n            result[key] = m.value;\n            continue;\n          }\n\n          if (m.fn !== undefined) {\n            result[key] = await m.fn(ctx);\n            continue;\n          }\n\n          if (m.runtimeContextPath) {\n            result[key] = runtimeContext.get(m.runtimeContextPath);\n            continue;\n          }\n\n          const stepResult = m.initData\n            ? getInitData()\n            : getStepResult(Array.isArray(m.step) ? m.step.find((s: any) => getStepResult(s)) : m.step);\n\n          if (m.path === '.') {\n            result[key] = stepResult;\n            continue;\n          }\n\n          const pathParts = m.path.split('.');\n          let value: any = stepResult;\n          for (const part of pathParts) {\n            if (typeof value === 'object' && value !== null) {\n              value = value[part];\n            } else {\n              throw new Error(`Invalid path ${m.path} in step ${m.step.id}`);\n            }\n          }\n\n          result[key] = value;\n        }\n        return result as z.infer<typeof mappingStep.outputSchema>;\n      },\n    });\n\n    type MappedOutputSchema = z.ZodType<any>;\n\n    this.stepFlow.push({ type: 'step', step: mappingStep as any });\n    this.serializedStepFlow.push({\n      type: 'step',\n      step: {\n        id: mappingStep.id,\n        mapConfig: JSON.stringify(newMappingConfig, null, 2),\n      },\n    });\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, MappedOutputSchema>;\n  }\n\n  // TODO: make typing better here\n  parallel<TParallelSteps extends Step<string, TPrevSchema, any, any, any, TEngineType>[]>(steps: TParallelSteps) {\n    this.stepFlow.push({ type: 'parallel', steps: steps.map(step => ({ type: 'step', step: step as any })) });\n    this.serializedStepFlow.push({\n      type: 'parallel',\n      steps: steps.map(step => ({\n        type: 'step',\n        step: {\n          id: step.id,\n          description: step.description,\n          component: (step as SerializedStep).component,\n          serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n        },\n      })),\n    });\n    steps.forEach(step => {\n      this.steps[step.id] = step;\n    });\n    return this as unknown as Workflow<\n      TEngineType,\n      TSteps,\n      TWorkflowId,\n      TInput,\n      TOutput,\n      z.ZodObject<\n        {\n          [K in keyof StepsRecord<TParallelSteps>]: StepsRecord<TParallelSteps>[K]['outputSchema'];\n        },\n        any,\n        z.ZodTypeAny\n      >\n    >;\n  }\n\n  // TODO: make typing better here\n  branch<\n    TBranchSteps extends Array<\n      [\n        ExecuteFunction<z.infer<TPrevSchema>, any, any, any, TEngineType>,\n        Step<string, TPrevSchema, any, any, any, TEngineType>,\n      ]\n    >,\n  >(steps: TBranchSteps) {\n    this.stepFlow.push({\n      type: 'conditional',\n      steps: steps.map(([_cond, step]) => ({ type: 'step', step: step as any })),\n      // @ts-ignore\n      conditions: steps.map(([cond]) => cond),\n      serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() })),\n    });\n    this.serializedStepFlow.push({\n      type: 'conditional',\n      steps: steps.map(([_cond, step]) => ({\n        type: 'step',\n        step: {\n          id: step.id,\n          description: step.description,\n          component: (step as SerializedStep).component,\n          serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n        },\n      })),\n      serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() })),\n    });\n    steps.forEach(([_, step]) => {\n      this.steps[step.id] = step;\n    });\n\n    // Extract just the Step elements from the tuples array\n    type BranchStepsArray = { [K in keyof TBranchSteps]: TBranchSteps[K][1] };\n\n    // This creates a mapped type that extracts the second element from each tuple\n    type ExtractedSteps = BranchStepsArray[number];\n\n    // Now we can use this type as an array, similar to TParallelSteps\n    return this as unknown as Workflow<\n      TEngineType,\n      TSteps,\n      TWorkflowId,\n      TInput,\n      TOutput,\n      z.ZodObject<\n        {\n          [K in keyof StepsRecord<ExtractedSteps[]>]: StepsRecord<ExtractedSteps[]>[K]['outputSchema'];\n        },\n        any,\n        z.ZodTypeAny\n      >\n    >;\n  }\n\n  dowhile<TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut extends z.ZodType<any>>(\n    step: Step<TStepId, TStepInputSchema, TSchemaOut, any, any, TEngineType>,\n    condition: ExecuteFunction<z.infer<TSchemaOut>, any, any, any, TEngineType>,\n  ) {\n    this.stepFlow.push({\n      type: 'loop',\n      step: step as any,\n      // @ts-ignore\n      condition,\n      loopType: 'dowhile',\n      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },\n    });\n    this.serializedStepFlow.push({\n      type: 'loop',\n      step: {\n        id: step.id,\n        description: step.description,\n        component: (step as SerializedStep).component,\n        serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n      },\n      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },\n      loopType: 'dowhile',\n    });\n    this.steps[step.id] = step;\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TSchemaOut>;\n  }\n\n  dountil<TStepInputSchema extends TPrevSchema, TStepId extends string, TSchemaOut extends z.ZodType<any>>(\n    step: Step<TStepId, TStepInputSchema, TSchemaOut, any, any, TEngineType>,\n    condition: ExecuteFunction<z.infer<TSchemaOut>, any, any, any, TEngineType>,\n  ) {\n    this.stepFlow.push({\n      type: 'loop',\n      step: step as any,\n      // @ts-ignore\n      condition,\n      loopType: 'dountil',\n      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },\n    });\n    this.serializedStepFlow.push({\n      type: 'loop',\n      step: {\n        id: step.id,\n        description: step.description,\n        component: (step as SerializedStep).component,\n        serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n      },\n      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },\n      loopType: 'dountil',\n    });\n    this.steps[step.id] = step;\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TSchemaOut>;\n  }\n\n  foreach<\n    TPrevIsArray extends TPrevSchema extends z.ZodArray<any> ? true : false,\n    TStepInputSchema extends TPrevSchema extends z.ZodArray<infer TElement> ? TElement : never,\n    TStepId extends string,\n    TSchemaOut extends z.ZodType<any>,\n  >(\n    step: TPrevIsArray extends true\n      ? Step<TStepId, TStepInputSchema, TSchemaOut, any, any, TEngineType>\n      : 'Previous step must return an array type',\n    opts?: {\n      concurrency: number;\n    },\n  ) {\n    this.stepFlow.push({ type: 'foreach', step: step as any, opts: opts ?? { concurrency: 1 } });\n    this.serializedStepFlow.push({\n      type: 'foreach',\n      step: {\n        id: (step as SerializedStep).id,\n        description: (step as SerializedStep).description,\n        component: (step as SerializedStep).component,\n        serializedStepFlow: (step as SerializedStep).serializedStepFlow,\n      },\n      opts: opts ?? { concurrency: 1 },\n    });\n    this.steps[(step as any).id] = step as any;\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, z.ZodArray<TSchemaOut>>;\n  }\n\n  /**\n   * Builds the execution graph for this workflow\n   * @returns The execution graph that can be used to execute the workflow\n   */\n  buildExecutionGraph(): ExecutionGraph {\n    return {\n      id: this.id,\n      steps: this.stepFlow,\n    };\n  }\n\n  /**\n   * Finalizes the workflow definition and prepares it for execution\n   * This method should be called after all steps have been added to the workflow\n   * @returns A built workflow instance ready for execution\n   */\n  commit() {\n    this.executionGraph = this.buildExecutionGraph();\n    return this as unknown as Workflow<TEngineType, TSteps, TWorkflowId, TInput, TOutput, TOutput>;\n  }\n\n  get stepGraph() {\n    return this.stepFlow;\n  }\n\n  get serializedStepGraph() {\n    return this.serializedStepFlow;\n  }\n\n  /**\n   * Creates a new workflow run instance\n   * @param options Optional configuration for the run\n   * @returns A Run instance that can be used to execute the workflow\n   */\n  createRun(options?: { runId?: string }): Run<TEngineType, TSteps, TInput, TOutput> {\n    if (this.stepFlow.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n    const runIdToUse = options?.runId || this.#mastra?.generateId() || randomUUID();\n\n    // Return a new Run instance with object parameters\n    const run =\n      this.#runs.get(runIdToUse) ??\n      new Run({\n        workflowId: this.id,\n        runId: runIdToUse,\n        executionEngine: this.executionEngine,\n        executionGraph: this.executionGraph,\n        mastra: this.#mastra,\n        retryConfig: this.retryConfig,\n        serializedStepGraph: this.serializedStepGraph,\n        cleanup: () => this.#runs.delete(runIdToUse),\n      });\n\n    this.#runs.set(runIdToUse, run);\n\n    this.mastra?.getLogger().warn('createRun() is deprecated. Use createRunAsync() instead.');\n\n    return run;\n  }\n\n  /**\n   * Creates a new workflow run instance and stores a snapshot of the workflow in the storage\n   * @param options Optional configuration for the run\n   * @returns A Run instance that can be used to execute the workflow\n   */\n  async createRunAsync(options?: { runId?: string }): Promise<Run<TEngineType, TSteps, TInput, TOutput>> {\n    if (this.stepFlow.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n    const runIdToUse = options?.runId || this.#mastra?.generateId() || randomUUID();\n\n    // Return a new Run instance with object parameters\n    const run =\n      this.#runs.get(runIdToUse) ??\n      new Run({\n        workflowId: this.id,\n        runId: runIdToUse,\n        executionEngine: this.executionEngine,\n        executionGraph: this.executionGraph,\n        mastra: this.#mastra,\n        retryConfig: this.retryConfig,\n        serializedStepGraph: this.serializedStepGraph,\n        cleanup: () => this.#runs.delete(runIdToUse),\n      });\n\n    this.#runs.set(runIdToUse, run);\n\n    const workflowSnapshotInStorage = await this.getWorkflowRunExecutionResult(runIdToUse);\n\n    if (!workflowSnapshotInStorage) {\n      await this.mastra?.getStorage()?.persistWorkflowSnapshot({\n        workflowName: this.id,\n        runId: runIdToUse,\n        snapshot: {\n          runId: runIdToUse,\n          status: 'pending',\n          value: {},\n          context: {},\n          activePaths: [],\n          serializedStepGraph: this.serializedStepGraph,\n          suspendedPaths: {},\n          result: undefined,\n          error: undefined,\n          // @ts-ignore\n          timestamp: Date.now(),\n        },\n      });\n    }\n\n    return run;\n  }\n\n  async getScorers({\n    runtimeContext = new RuntimeContext(),\n  }: { runtimeContext?: RuntimeContext } = {}): Promise<MastraScorers> {\n    const steps = this.steps;\n\n    if (!steps || Object.keys(steps).length === 0) {\n      return {};\n    }\n\n    const scorers: MastraScorers = {};\n\n    for (const step of Object.values(steps)) {\n      if (step.scorers) {\n        let scorersToUse = step.scorers;\n\n        if (typeof scorersToUse === 'function') {\n          scorersToUse = await scorersToUse({ runtimeContext });\n        }\n\n        for (const [id, scorer] of Object.entries(scorersToUse)) {\n          scorers[id] = scorer;\n        }\n      }\n    }\n\n    return scorers;\n  }\n\n  async execute({\n    inputData,\n    resumeData,\n    suspend,\n    resume,\n    [EMITTER_SYMBOL]: emitter,\n    mastra,\n    runtimeContext,\n    abort,\n    abortSignal,\n    runCount,\n  }: {\n    inputData: z.infer<TInput>;\n    resumeData?: any;\n    getStepResult<T extends Step<any, any, any, any, any, TEngineType>>(\n      stepId: T,\n    ): T['outputSchema'] extends undefined ? unknown : z.infer<NonNullable<T['outputSchema']>>;\n    suspend: (suspendPayload: any) => Promise<any>;\n    resume?: {\n      steps: string[];\n      resumePayload: any;\n      runId?: string;\n    };\n    [EMITTER_SYMBOL]: { emit: (event: string, data: any) => void };\n    mastra: Mastra;\n    runtimeContext?: RuntimeContext;\n    engine: DefaultEngineType;\n    abortSignal: AbortSignal;\n    bail: (result: any) => any;\n    abort: () => any;\n    runCount?: number;\n  }): Promise<z.infer<TOutput>> {\n    this.__registerMastra(mastra);\n\n    const run = resume?.steps?.length\n      ? await this.createRunAsync({ runId: resume.runId })\n      : await this.createRunAsync();\n    const nestedAbortCb = () => {\n      abort();\n    };\n    run.abortController.signal.addEventListener('abort', nestedAbortCb);\n    abortSignal.addEventListener('abort', async () => {\n      run.abortController.signal.removeEventListener('abort', nestedAbortCb);\n      await run.cancel();\n    });\n\n    const unwatchV2 = run.watch(event => {\n      emitter.emit('nested-watch-v2', { event, workflowId: this.id });\n    }, 'watch-v2');\n    const unwatch = run.watch(event => {\n      emitter.emit('nested-watch', { event, workflowId: this.id, runId: run.runId, isResume: !!resume?.steps?.length });\n    }, 'watch');\n\n    if (runCount && runCount > 0 && resume?.steps?.length && runtimeContext) {\n      runtimeContext.set('__mastraWorflowInputData', inputData);\n    }\n\n    const res = resume?.steps?.length\n      ? await run.resume({\n          resumeData,\n          step: resume.steps as any,\n          runtimeContext,\n          runCount,\n        })\n      : await run.start({ inputData, runtimeContext });\n    unwatch();\n    unwatchV2();\n    const suspendedSteps = Object.entries(res.steps).filter(([_stepName, stepResult]) => {\n      const stepRes: StepResult<any, any, any, any> = stepResult as StepResult<any, any, any, any>;\n      return stepRes?.status === 'suspended';\n    });\n\n    if (suspendedSteps?.length) {\n      for (const [stepName, stepResult] of suspendedSteps) {\n        // @ts-ignore\n        const suspendPath: string[] = [stepName, ...(stepResult?.suspendPayload?.__workflow_meta?.path ?? [])];\n        await suspend({\n          ...(stepResult as any)?.suspendPayload,\n          __workflow_meta: { runId: run.runId, path: suspendPath },\n        });\n      }\n    }\n\n    if (res.status === 'failed') {\n      throw res.error;\n    }\n\n    return res.status === 'success' ? res.result : undefined;\n  }\n\n  async getWorkflowRuns(args?: {\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  }) {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug('Cannot get workflow runs. Mastra storage is not initialized');\n      return { runs: [], total: 0 };\n    }\n\n    return storage.getWorkflowRuns({ workflowName: this.id, ...(args ?? {}) });\n  }\n\n  async getWorkflowRunById(runId: string) {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug('Cannot get workflow runs from storage. Mastra storage is not initialized');\n      //returning in memory run if no storage is initialized\n      return this.#runs.get(runId)\n        ? ({ ...this.#runs.get(runId), workflowName: this.id } as unknown as WorkflowRun)\n        : null;\n    }\n    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });\n\n    return (\n      run ??\n      (this.#runs.get(runId) ? ({ ...this.#runs.get(runId), workflowName: this.id } as unknown as WorkflowRun) : null)\n    );\n  }\n\n  async getWorkflowRunExecutionResult(runId: string): Promise<WatchEvent['payload']['workflowState'] | null> {\n    const storage = this.#mastra?.getStorage();\n    if (!storage) {\n      this.logger.debug('Cannot get workflow run execution result. Mastra storage is not initialized');\n      return null;\n    }\n\n    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });\n\n    let snapshot: WorkflowRunState | string = run?.snapshot!;\n\n    if (!snapshot) {\n      return null;\n    }\n\n    if (typeof snapshot === 'string') {\n      // this occurs whenever the parsing of snapshot fails in storage\n      try {\n        snapshot = JSON.parse(snapshot);\n      } catch (e) {\n        this.logger.debug('Cannot get workflow run execution result. Snapshot is not a valid JSON string', e);\n        return null;\n      }\n    }\n\n    return {\n      status: (snapshot as WorkflowRunState).status,\n      result: (snapshot as WorkflowRunState).result,\n      error: (snapshot as WorkflowRunState).error,\n      payload: (snapshot as WorkflowRunState).context?.input,\n      steps: (snapshot as WorkflowRunState).context as any,\n    };\n  }\n}\n\n/**\n * Represents a workflow run that can be executed\n */\nexport class Run<\n  TEngineType = any,\n  TSteps extends Step<string, any, any, any, any, TEngineType>[] = Step<string, any, any, any, any, TEngineType>[],\n  TInput extends z.ZodType<any> = z.ZodType<any>,\n  TOutput extends z.ZodType<any> = z.ZodType<any>,\n> {\n  #abortController?: AbortController;\n  protected emitter: EventEmitter;\n  /**\n   * Unique identifier for this workflow\n   */\n  readonly workflowId: string;\n\n  /**\n   * Unique identifier for this run\n   */\n  readonly runId: string;\n\n  /**\n   * Internal state of the workflow run\n   */\n  protected state: Record<string, any> = {};\n\n  /**\n   * The execution engine for this run\n   */\n  public executionEngine: ExecutionEngine;\n\n  /**\n   * The execution graph for this run\n   */\n  public executionGraph: ExecutionGraph;\n\n  /**\n   * The serialized step graph for this run\n   */\n  public serializedStepGraph: SerializedStepFlowEntry[];\n\n  /**\n   * The storage for this run\n   */\n  #mastra?: Mastra;\n\n  protected closeStreamAction?: () => Promise<void>;\n  protected executionResults?: Promise<WorkflowResult<TOutput, TSteps>>;\n\n  protected cleanup?: () => void;\n\n  protected retryConfig?: {\n    attempts?: number;\n    delay?: number;\n  };\n\n  constructor(params: {\n    workflowId: string;\n    runId: string;\n    executionEngine: ExecutionEngine;\n    executionGraph: ExecutionGraph;\n    mastra?: Mastra;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    cleanup?: () => void;\n    serializedStepGraph: SerializedStepFlowEntry[];\n  }) {\n    this.workflowId = params.workflowId;\n    this.runId = params.runId;\n    this.serializedStepGraph = params.serializedStepGraph;\n    this.executionEngine = params.executionEngine;\n    this.executionGraph = params.executionGraph;\n    this.#mastra = params.mastra;\n    this.emitter = new EventEmitter();\n    this.retryConfig = params.retryConfig;\n    this.cleanup = params.cleanup;\n  }\n\n  public get abortController(): AbortController {\n    if (!this.#abortController) {\n      this.#abortController = new AbortController();\n    }\n\n    return this.#abortController;\n  }\n\n  /**\n   * Cancels the workflow execution\n   */\n  async cancel() {\n    this.abortController?.abort();\n  }\n\n  async sendEvent(event: string, data: any) {\n    this.emitter.emit(`user-event-${event}`, data);\n  }\n\n  /**\n   * Starts the workflow execution with the provided input\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  async start({\n    inputData,\n    runtimeContext,\n    writableStream,\n  }: {\n    inputData?: z.infer<TInput>;\n    runtimeContext?: RuntimeContext;\n    writableStream?: WritableStream<ChunkType>;\n  }): Promise<WorkflowResult<TOutput, TSteps>> {\n    const result = await this.executionEngine.execute<z.infer<TInput>, WorkflowResult<TOutput, TSteps>>({\n      workflowId: this.workflowId,\n      runId: this.runId,\n      graph: this.executionGraph,\n      serializedStepGraph: this.serializedStepGraph,\n      input: inputData,\n      emitter: {\n        emit: async (event: string, data: any) => {\n          this.emitter.emit(event, data);\n        },\n        on: (event: string, callback: (data: any) => void) => {\n          this.emitter.on(event, callback);\n        },\n        off: (event: string, callback: (data: any) => void) => {\n          this.emitter.off(event, callback);\n        },\n        once: (event: string, callback: (data: any) => void) => {\n          this.emitter.once(event, callback);\n        },\n      },\n      retryConfig: this.retryConfig,\n      runtimeContext: runtimeContext ?? new RuntimeContext(),\n      abortController: this.abortController,\n      writableStream,\n    });\n\n    if (result.status !== 'suspended') {\n      this.cleanup?.();\n    }\n\n    return result;\n  }\n\n  /**\n   * Starts the workflow execution with the provided input as a stream\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  stream({ inputData, runtimeContext }: { inputData?: z.infer<TInput>; runtimeContext?: RuntimeContext } = {}): {\n    stream: ReadableStream<StreamEvent>;\n    getWorkflowState: () => Promise<WorkflowResult<TOutput, TSteps>>;\n  } {\n    const { readable, writable } = new TransformStream<StreamEvent, StreamEvent>();\n\n    const writer = writable.getWriter();\n    const unwatch = this.watch(async event => {\n      try {\n        // watch-v2 events are data stream events, so we need to cast them to the correct type\n        await writer.write(event as any);\n      } catch {}\n    }, 'watch-v2');\n\n    this.closeStreamAction = async () => {\n      this.emitter.emit('watch-v2', {\n        type: 'finish',\n        payload: { runId: this.runId },\n      });\n      unwatch();\n\n      try {\n        await writer.close();\n      } catch (err) {\n        console.error('Error closing stream:', err);\n      } finally {\n        writer.releaseLock();\n      }\n    };\n\n    this.emitter.emit('watch-v2', {\n      type: 'start',\n      payload: { runId: this.runId },\n    });\n    this.executionResults = this.start({ inputData, runtimeContext }).then(result => {\n      if (result.status !== 'suspended') {\n        this.closeStreamAction?.().catch(() => {});\n      }\n\n      return result;\n    });\n\n    return {\n      stream: readable,\n      getWorkflowState: () => this.executionResults!,\n    };\n  }\n\n  /**\n   * Starts the workflow execution with the provided input as a stream\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  streamVNext({ inputData, runtimeContext }: { inputData?: z.infer<TInput>; runtimeContext?: RuntimeContext } = {}) {\n    this.closeStreamAction = async () => {};\n\n    return new MastraWorkflowStream({\n      run: this,\n      createStream: writer => {\n        const { readable, writable } = new TransformStream<ChunkType, ChunkType>({\n          transform(chunk, controller) {\n            controller.enqueue(chunk);\n          },\n        });\n\n        let buffer: ChunkType[] = [];\n        let isWriting = false;\n        const tryWrite = async () => {\n          const chunkToWrite = buffer;\n          buffer = [];\n\n          if (chunkToWrite.length === 0 || isWriting) {\n            return;\n          }\n          isWriting = true;\n\n          let watchWriter = writer.getWriter();\n          try {\n            for (const chunk of chunkToWrite) {\n              await watchWriter.write(chunk);\n            }\n          } finally {\n            watchWriter.releaseLock();\n          }\n          isWriting = false;\n\n          setImmediate(tryWrite);\n        };\n\n        const unwatch = this.watch(async ({ type, payload }) => {\n          let newPayload: Record<string, any> = payload;\n\n          //@ts-ignore\n          if (type === 'step-start') {\n            const { payload: args, id, ...rest } = newPayload;\n            newPayload = {\n              args,\n              ...rest,\n            };\n            //@ts-ignore\n          } else if (type === 'step-result') {\n            const { output, id, ...rest } = newPayload;\n            newPayload = {\n              result: output,\n              ...rest,\n            };\n          }\n\n          buffer.push({\n            type,\n            runId: this.runId,\n            from: 'WORKFLOW',\n            payload: {\n              stepName: (payload as unknown as { id: string }).id,\n              ...newPayload,\n            },\n          });\n\n          await tryWrite();\n        }, 'watch-v2');\n\n        this.closeStreamAction = async () => {\n          unwatch();\n\n          try {\n            await writable.close();\n          } catch (err) {\n            console.error('Error closing stream:', err);\n          }\n        };\n\n        const executionResults = this.start({ inputData, runtimeContext, writableStream: writable }).then(result => {\n          if (result.status !== 'suspended') {\n            this.closeStreamAction?.().catch(() => {});\n          }\n\n          return result;\n        });\n        this.executionResults = executionResults;\n\n        return readable;\n      },\n    });\n  }\n\n  watch(cb: (event: WatchEvent) => void, type: 'watch' | 'watch-v2' = 'watch'): () => void {\n    const watchCb = (event: WatchEvent) => {\n      this.updateState(event.payload);\n      cb({ type: event.type, payload: this.getState() as any, eventTimestamp: event.eventTimestamp });\n    };\n\n    const nestedWatchCb = ({ event, workflowId }: { event: WatchEvent; workflowId: string }) => {\n      try {\n        const { type, payload, eventTimestamp } = event;\n        const prefixedSteps = Object.fromEntries(\n          Object.entries(payload?.workflowState?.steps ?? {}).map(([stepId, step]) => [\n            `${workflowId}.${stepId}`,\n            step,\n          ]),\n        );\n        const newPayload: any = {\n          currentStep: {\n            ...payload?.currentStep,\n            id: `${workflowId}.${payload?.currentStep?.id}`,\n          },\n          workflowState: {\n            steps: prefixedSteps,\n          },\n        };\n        this.updateState(newPayload);\n        cb({ type, payload: this.getState() as any, eventTimestamp: eventTimestamp });\n      } catch (e) {\n        console.error(e);\n      }\n    };\n\n    const nestedWatchV2Cb = ({\n      event,\n      workflowId,\n    }: {\n      event: { type: string; payload: { id: string } & Record<string, unknown> };\n      workflowId: string;\n    }) => {\n      this.emitter.emit('watch-v2', {\n        ...event,\n        ...(event.payload?.id ? { payload: { ...event.payload, id: `${workflowId}.${event.payload.id}` } } : {}),\n      });\n    };\n\n    if (type === 'watch') {\n      this.emitter.on('watch', watchCb);\n      this.emitter.on('nested-watch', nestedWatchCb);\n    } else if (type === 'watch-v2') {\n      this.emitter.on('watch-v2', cb);\n      this.emitter.on('nested-watch-v2', nestedWatchV2Cb);\n    }\n\n    return () => {\n      if (type === 'watch-v2') {\n        this.emitter.off('watch-v2', cb);\n        this.emitter.off('nested-watch-v2', nestedWatchV2Cb);\n      } else {\n        this.emitter.off('watch', watchCb);\n        this.emitter.off('nested-watch', nestedWatchCb);\n      }\n    };\n  }\n\n  async resume<TResumeSchema extends z.ZodType<any>>(params: {\n    resumeData?: z.infer<TResumeSchema>;\n    step?:\n      | Step<string, any, any, TResumeSchema, any, TEngineType>\n      | [...Step<string, any, any, any, any, TEngineType>[], Step<string, any, any, TResumeSchema, any, TEngineType>]\n      | string\n      | string[];\n    runtimeContext?: RuntimeContext;\n    runCount?: number;\n  }): Promise<WorkflowResult<TOutput, TSteps>> {\n    const snapshot = await this.#mastra?.getStorage()?.loadWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n    });\n\n    if (!snapshot) {\n      throw new Error('No snapshot found for this workflow run');\n    }\n\n    // Auto-detect suspended steps if no step is provided\n    let steps: string[];\n    if (params.step) {\n      steps = (Array.isArray(params.step) ? params.step : [params.step]).map(step =>\n        typeof step === 'string' ? step : step?.id,\n      );\n    } else {\n      // Use suspendedPaths to detect suspended steps\n      const suspendedStepPaths: string[][] = [];\n\n      Object.entries(snapshot?.suspendedPaths ?? {}).forEach(([stepId, _executionPath]) => {\n        // Check if this step has nested workflow suspension data\n        const stepResult = snapshot?.context?.[stepId];\n        if (stepResult && typeof stepResult === 'object' && 'status' in stepResult) {\n          const stepRes = stepResult as any;\n          if (stepRes.status === 'suspended') {\n            const nestedPath = stepRes.suspendPayload?.__workflow_meta?.path;\n            if (nestedPath && Array.isArray(nestedPath)) {\n              // For nested workflows, combine the parent step ID with the nested path\n              suspendedStepPaths.push([stepId, ...nestedPath]);\n            } else {\n              // For single-level suspension, just use the step ID\n              suspendedStepPaths.push([stepId]);\n            }\n          }\n        }\n      });\n\n      if (suspendedStepPaths.length === 0) {\n        throw new Error('No suspended steps found in this workflow run');\n      }\n\n      if (suspendedStepPaths.length === 1) {\n        // For single suspended step, use the full path\n        steps = suspendedStepPaths[0]!;\n      } else {\n        const pathStrings = suspendedStepPaths.map(path => `[${path.join(', ')}]`);\n        throw new Error(\n          `Multiple suspended steps found: ${pathStrings.join(', ')}. ` +\n            'Please specify which step to resume using the \"step\" parameter.',\n        );\n      }\n    }\n\n    if (!params.runCount) {\n      if (snapshot.status !== 'suspended') {\n        throw new Error('This workflow run was not suspended');\n      }\n\n      const suspendedStepIds = Object.keys(snapshot?.suspendedPaths ?? {});\n\n      const isStepSuspended = suspendedStepIds.includes(steps?.[0] ?? '');\n\n      if (!isStepSuspended) {\n        throw new Error(\n          `This workflow step \"${steps?.[0]}\" was not suspended. Available suspended steps: [${suspendedStepIds.join(', ')}]`,\n        );\n      }\n    }\n\n    let runtimeContextInput;\n    if (params.runCount && params.runCount > 0 && params.runtimeContext) {\n      runtimeContextInput = params.runtimeContext.get('__mastraWorflowInputData');\n      params.runtimeContext.delete('__mastraWorflowInputData');\n    }\n\n    const stepResults = { ...(snapshot?.context ?? {}), input: runtimeContextInput ?? snapshot?.context?.input } as any;\n\n    let runtimeContextToUse = params.runtimeContext ?? new RuntimeContext();\n\n    Object.entries(snapshot?.runtimeContext ?? {}).forEach(([key, value]) => {\n      if (!runtimeContextToUse.has(key)) {\n        runtimeContextToUse.set(key, value);\n      }\n    });\n\n    const executionResultPromise = this.executionEngine\n      .execute<z.infer<TInput>, WorkflowResult<TOutput, TSteps>>({\n        workflowId: this.workflowId,\n        runId: this.runId,\n        graph: this.executionGraph,\n        serializedStepGraph: this.serializedStepGraph,\n        input: snapshot?.context?.input,\n        resume: {\n          steps,\n          stepResults,\n          resumePayload: params.resumeData,\n          // @ts-ignore\n          resumePath: snapshot?.suspendedPaths?.[steps?.[0]] as any,\n        },\n        emitter: {\n          emit: (event: string, data: any) => {\n            this.emitter.emit(event, data);\n            return Promise.resolve();\n          },\n          on: (event: string, callback: (data: any) => void) => {\n            this.emitter.on(event, callback);\n          },\n          off: (event: string, callback: (data: any) => void) => {\n            this.emitter.off(event, callback);\n          },\n          once: (event: string, callback: (data: any) => void) => {\n            this.emitter.once(event, callback);\n          },\n        },\n        runtimeContext: runtimeContextToUse,\n        abortController: this.abortController,\n      })\n      .then(result => {\n        if (result.status !== 'suspended') {\n          this.closeStreamAction?.().catch(() => {});\n        }\n\n        return result;\n      });\n\n    this.executionResults = executionResultPromise;\n\n    return executionResultPromise;\n  }\n\n  /**\n   * Returns the current state of the workflow run\n   * @returns The current state of the workflow run\n   */\n  getState(): Record<string, any> {\n    return this.state;\n  }\n\n  updateState(state: Record<string, any>) {\n    if (state.currentStep) {\n      this.state.currentStep = state.currentStep;\n    } else if (state.workflowState?.status !== 'running') {\n      delete this.state.currentStep;\n    }\n\n    if (state.workflowState) {\n      this.state.workflowState = deepMergeWorkflowState(this.state.workflowState ?? {}, state.workflowState ?? {});\n    }\n  }\n\n  /**\n   * @access private\n   * @returns The execution results of the workflow run\n   */\n  _getExecutionResults() {\n    return this.executionResults;\n  }\n}\n\nfunction deepMergeWorkflowState(a: Record<string, any>, b: Record<string, any>): Record<string, any> {\n  if (!a || typeof a !== 'object') return b;\n  if (!b || typeof b !== 'object') return a;\n\n  const result = { ...a };\n\n  for (const key in b) {\n    if (b[key] === undefined) continue;\n\n    if (b[key] !== null && typeof b[key] === 'object') {\n      const aVal = result[key];\n      const bVal = b[key];\n\n      if (Array.isArray(bVal)) {\n        //we should just replace it instead of spreading as we do for others\n        //spreading aVal and then bVal will result in duplication of items\n        result[key] = bVal.filter(item => item !== undefined);\n      } else if (typeof aVal === 'object' && aVal !== null) {\n        // If both values are objects, merge them\n        result[key] = deepMergeWorkflowState(aVal, bVal);\n      } else {\n        // If the target isn't an object, use the source object\n        result[key] = bVal;\n      }\n    } else {\n      result[key] = b[key];\n    }\n  }\n\n  return result;\n}\n"]}