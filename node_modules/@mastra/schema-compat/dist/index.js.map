{"version":3,"sources":["../src/utils.ts","../src/schema-compatibility.ts","../src/provider-compats/anthropic.ts","../src/provider-compats/deepseek.ts","../src/provider-compats/google.ts","../src/provider-compats/meta.ts","../src/provider-compats/openai.ts","../src/provider-compats/openai-reasoning.ts"],"names":["z"],"mappings":"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","file":"index.js","sourcesContent":["import { jsonSchema } from 'ai';\nimport type { Schema } from 'ai';\nimport type { JSONSchema7 } from 'json-schema';\nimport type { z, ZodSchema } from 'zod';\nimport { convertJsonSchemaToZod } from 'zod-from-json-schema';\nimport type { JSONSchema as ZodFromJSONSchema_JSONSchema } from 'zod-from-json-schema';\nimport type { Targets } from 'zod-to-json-schema';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport type { SchemaCompatLayer } from './schema-compatibility';\n\n/**\n * Converts a Zod schema to an AI SDK Schema with validation support.\n *\n * This function mirrors the behavior of Vercel's AI SDK zod-schema utility but allows\n * customization of the JSON Schema target format.\n *\n * @param zodSchema - The Zod schema to convert\n * @param target - The JSON Schema target format (defaults to 'jsonSchema7')\n * @returns An AI SDK Schema object with built-in validation\n *\n * @example\n * ```typescript\n * import { z } from 'zod';\n * import { convertZodSchemaToAISDKSchema } from '@mastra/schema-compat';\n *\n * const userSchema = z.object({\n *   name: z.string(),\n *   age: z.number().min(0)\n * });\n *\n * const aiSchema = convertZodSchemaToAISDKSchema(userSchema);\n * ```\n */\n// mirrors https://github.com/vercel/ai/blob/main/packages/ui-utils/src/zod-schema.ts#L21 but with a custom target\nexport function convertZodSchemaToAISDKSchema(zodSchema: ZodSchema, target: Targets = 'jsonSchema7') {\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: 'none',\n      target,\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      },\n    },\n  );\n}\n\n/**\n * Checks if a value is a Zod type by examining its properties and methods.\n *\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n * @internal\n */\nfunction isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n/**\n * Converts an AI SDK Schema or Zod schema to a Zod schema.\n *\n * If the input is already a Zod schema, it returns it unchanged.\n * If the input is an AI SDK Schema, it extracts the JSON schema and converts it to Zod.\n *\n * @param schema - The schema to convert (AI SDK Schema or Zod schema)\n * @returns A Zod schema equivalent of the input\n * @throws Error if the conversion fails\n *\n * @example\n * ```typescript\n * import { jsonSchema } from 'ai';\n * import { convertSchemaToZod } from '@mastra/schema-compat';\n *\n * const aiSchema = jsonSchema({\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' }\n *   }\n * });\n *\n * const zodSchema = convertSchemaToZod(aiSchema);\n * ```\n */\nexport function convertSchemaToZod(schema: Schema | z.ZodSchema): z.ZodType {\n  if (isZodType(schema)) {\n    return schema;\n  } else {\n    const jsonSchemaToConvert = ('jsonSchema' in schema ? schema.jsonSchema : schema) as ZodFromJSONSchema_JSONSchema;\n    try {\n      return convertJsonSchemaToZod(jsonSchemaToConvert);\n    } catch (e: unknown) {\n      const errorMessage = `[Schema Builder] Failed to convert schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;\n      console.error(errorMessage, e);\n      throw new Error(errorMessage + (e instanceof Error ? `\\n${e.stack}` : '\\nUnknown error object'));\n    }\n  }\n}\n\n/**\n * Processes a schema using provider compatibility layers and converts it to an AI SDK Schema.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Must be 'aiSdkSchema'\n * @returns Processed schema as an AI SDK Schema\n */\nexport function applyCompatLayer(options: {\n  schema: Schema | z.ZodSchema;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'aiSdkSchema';\n}): Schema;\n\n/**\n * Processes a schema using provider compatibility layers and converts it to a JSON Schema.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Must be 'jsonSchema'\n * @returns Processed schema as a JSONSchema7\n */\nexport function applyCompatLayer(options: {\n  schema: Schema | z.ZodSchema;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'jsonSchema';\n}): JSONSchema7;\n\n/**\n * Processes a schema using provider compatibility layers and converts it to the specified format.\n *\n * This function automatically applies the first matching compatibility layer from the provided\n * list based on the model configuration. If no compatibility applies, it falls back to\n * standard conversion.\n *\n * @param options - Configuration object for schema processing\n * @param options.schema - The schema to process (AI SDK Schema or Zod object schema)\n * @param options.compatLayers - Array of compatibility layers to try\n * @param options.mode - Output format: 'jsonSchema' for JSONSchema7 or 'aiSdkSchema' for AI SDK Schema\n * @returns Processed schema in the requested format\n *\n * @example\n * ```typescript\n * import { z } from 'zod';\n * import { applyCompatLayer, OpenAISchemaCompatLayer, AnthropicSchemaCompatLayer } from '@mastra/schema-compat';\n *\n * const schema = z.object({\n *   query: z.string().email(),\n *   limit: z.number().min(1).max(100)\n * });\n *\n * const compatLayers = [\n *   new OpenAISchemaCompatLayer(model),\n *   new AnthropicSchemaCompatLayer(model)\n * ];\n *\n * const result = applyCompatLayer({\n *   schema,\n *   compatLayers,\n *   mode: 'aiSdkSchema'\n * });\n * ```\n */\nexport function applyCompatLayer({\n  schema,\n  compatLayers,\n  mode,\n}: {\n  schema: Schema | z.ZodSchema;\n  compatLayers: SchemaCompatLayer[];\n  mode: 'jsonSchema' | 'aiSdkSchema';\n}): JSONSchema7 | Schema {\n  let zodSchema: z.ZodSchema;\n\n  if (!isZodType(schema)) {\n    // Convert non-zod schema to Zod\n    zodSchema = convertSchemaToZod(schema);\n  } else {\n    zodSchema = schema;\n  }\n\n  for (const compat of compatLayers) {\n    if (compat.shouldApply()) {\n      return mode === 'jsonSchema' ? compat.processToJSONSchema(zodSchema) : compat.processToAISDKSchema(zodSchema);\n    }\n  }\n\n  // If no compatibility applied, convert back to appropriate format\n  if (mode === 'jsonSchema') {\n    return zodToJsonSchema(zodSchema, { $refStrategy: 'none', target: 'jsonSchema7' }) as JSONSchema7;\n  } else {\n    return convertZodSchemaToAISDKSchema(zodSchema);\n  }\n}\n","import type { Schema, LanguageModelV1 } from 'ai';\nimport type { JSONSchema7 } from 'json-schema';\nimport { z, ZodOptional, ZodObject, ZodArray, ZodUnion, ZodString, ZodNumber, ZodDate, ZodDefault, ZodNull } from 'zod';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport { convertZodSchemaToAISDKSchema } from './utils';\n\n/**\n * All supported string validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_STRING_CHECKS = ['regex', 'emoji', 'email', 'url', 'uuid', 'cuid', 'min', 'max'] as const;\n\n/**\n * All supported number validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_NUMBER_CHECKS = [\n  'min', // gte internally\n  'max', // lte internally\n  'multipleOf',\n] as const;\n\n/**\n * All supported array validation check types that can be processed or converted to descriptions.\n * @constant\n */\nexport const ALL_ARRAY_CHECKS = ['min', 'max', 'length'] as const;\n\nexport const isOptional = (v: ZodTypeAny): v is ZodOptional<any> => v instanceof ZodOptional;\nexport const isObj = (v: ZodTypeAny): v is ZodObject<any, any, any> => v instanceof ZodObject;\nexport const isNull = (v: ZodTypeAny): v is ZodNull => v instanceof ZodNull;\nexport const isArr = (v: ZodTypeAny): v is ZodArray<any, any> => v instanceof ZodArray;\nexport const isUnion = (v: ZodTypeAny): v is ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]> => v instanceof ZodUnion;\nexport const isString = (v: ZodTypeAny): v is ZodString => v instanceof ZodString;\nexport const isNumber = (v: ZodTypeAny): v is ZodNumber => v instanceof ZodNumber;\nexport const isDate = (v: ZodTypeAny): v is ZodDate => v instanceof ZodDate;\nexport const isDefault = (v: ZodTypeAny): v is ZodDefault<any> => v instanceof ZodDefault;\n\n/**\n * Zod types that are not supported by most AI model providers and should be avoided.\n * @constant\n */\nexport const UNSUPPORTED_ZOD_TYPES = ['ZodIntersection', 'ZodNever', 'ZodNull', 'ZodTuple', 'ZodUndefined'] as const;\n\n/**\n * Zod types that are generally supported by AI model providers.\n * @constant\n */\nexport const SUPPORTED_ZOD_TYPES = [\n  'ZodObject',\n  'ZodArray',\n  'ZodUnion',\n  'ZodString',\n  'ZodNumber',\n  'ZodDate',\n  'ZodAny',\n  'ZodDefault',\n] as const;\n\n/**\n * All Zod types (both supported and unsupported).\n * @constant\n */\nexport const ALL_ZOD_TYPES = [...SUPPORTED_ZOD_TYPES, ...UNSUPPORTED_ZOD_TYPES] as const;\n\n/**\n * Type representing string validation checks.\n */\nexport type StringCheckType = (typeof ALL_STRING_CHECKS)[number];\n\n/**\n * Type representing number validation checks.\n */\nexport type NumberCheckType = (typeof ALL_NUMBER_CHECKS)[number];\n\n/**\n * Type representing array validation checks.\n */\nexport type ArrayCheckType = (typeof ALL_ARRAY_CHECKS)[number];\n\n/**\n * Type representing unsupported Zod schema types.\n */\nexport type UnsupportedZodType = (typeof UNSUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing supported Zod schema types.\n */\nexport type SupportedZodType = (typeof SUPPORTED_ZOD_TYPES)[number];\n\n/**\n * Type representing all Zod schema types (supported and unsupported).\n */\nexport type AllZodType = (typeof ALL_ZOD_TYPES)[number];\n\n/**\n * Utility type to extract the shape of a Zod object schema.\n */\nexport type ZodShape<T extends z.AnyZodObject> = T['shape'];\n\n/**\n * Utility type to extract the keys from a Zod object shape.\n */\nexport type ShapeKey<T extends z.AnyZodObject> = keyof ZodShape<T>;\n\n/**\n * Utility type to extract the value types from a Zod object shape.\n */\nexport type ShapeValue<T extends z.AnyZodObject> = ZodShape<T>[ShapeKey<T>];\n\n// Add constraint types at the top\n\ntype StringConstraints = {\n  minLength?: number;\n  maxLength?: number;\n  email?: boolean;\n  url?: boolean;\n  uuid?: boolean;\n  cuid?: boolean;\n  emoji?: boolean;\n  regex?: { pattern: string; flags?: string };\n};\n\ntype NumberConstraints = {\n  gt?: number;\n  gte?: number;\n  lt?: number;\n  lte?: number;\n  multipleOf?: number;\n};\n\ntype ArrayConstraints = {\n  minLength?: number;\n  maxLength?: number;\n  exactLength?: number;\n};\n\ntype DateConstraints = {\n  minDate?: string;\n  maxDate?: string;\n  dateFormat?: string;\n};\n\n/**\n * Abstract base class for creating schema compatibility layers for different AI model providers.\n *\n * This class provides a framework for transforming Zod schemas to work with specific AI model\n * provider requirements and limitations. Each provider may have different support levels for\n * JSON Schema features, validation constraints, and data types.\n *\n * @abstract\n *\n * @example\n * ```typescript\n * import { SchemaCompatLayer } from '@mastra/schema-compat';\n * import type { LanguageModelV1 } from 'ai';\n *\n * class CustomProviderCompat extends SchemaCompatLayer {\n *   constructor(model: LanguageModelV1) {\n *     super(model);\n *   }\n *\n *   shouldApply(): boolean {\n *     return this.getModel().provider === 'custom-provider';\n *   }\n *\n *   getSchemaTarget() {\n *     return 'jsonSchema7';\n *   }\n *\n *   processZodType<T extends z.AnyZodObject>(value: z.ZodTypeAny): ShapeValue<T> {\n *     // Custom processing logic for this provider\n *     switch (value._def.typeName) {\n *       case 'ZodString':\n *         return this.defaultZodStringHandler(value, ['email', 'url']);\n *       default:\n *         return this.defaultUnsupportedZodTypeHandler(value);\n *     }\n *   }\n * }\n * ```\n */\nexport abstract class SchemaCompatLayer {\n  private model: LanguageModelV1;\n\n  /**\n   * Creates a new schema compatibility instance.\n   *\n   * @param model - The language model this compatibility layer applies to\n   */\n  constructor(model: LanguageModelV1) {\n    this.model = model;\n  }\n\n  /**\n   * Gets the language model associated with this compatibility layer.\n   *\n   * @returns The language model instance\n   */\n  getModel(): LanguageModelV1 {\n    return this.model;\n  }\n\n  /**\n   * Determines whether this compatibility layer should be applied for the current model.\n   *\n   * @returns True if this compatibility layer should be used, false otherwise\n   * @abstract\n   */\n  abstract shouldApply(): boolean;\n\n  /**\n   * Returns the JSON Schema target format for this provider.\n   *\n   * @returns The schema target format, or undefined to use the default 'jsonSchema7'\n   * @abstract\n   */\n  abstract getSchemaTarget(): Targets | undefined;\n\n  /**\n   * Processes a specific Zod type according to the provider's requirements.\n   *\n   * @param value - The Zod type to process\n   * @returns The processed Zod type\n   * @abstract\n   */\n  abstract processZodType(value: ZodTypeAny): ZodTypeAny;\n\n  /**\n   * Default handler for Zod object types. Recursively processes all properties in the object.\n   *\n   * @param value - The Zod object to process\n   * @returns The processed Zod object\n   */\n  public defaultZodObjectHandler(\n    value: ZodObject<any, any, any>,\n    options: { passthrough?: boolean } = { passthrough: true },\n  ): ZodObject<any, any, any> {\n    const processedShape = Object.entries(value.shape).reduce<Record<string, ZodTypeAny>>((acc, [key, propValue]) => {\n      acc[key] = this.processZodType(propValue as ZodTypeAny);\n      return acc;\n    }, {});\n\n    let result: ZodObject<any, any, any> = z.object(processedShape);\n\n    if (value._def.unknownKeys === 'strict') {\n      result = result.strict();\n    }\n    if (value._def.catchall && !(value._def.catchall instanceof z.ZodNever)) {\n      result = result.catchall(value._def.catchall);\n    }\n\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n\n    if (options.passthrough && value._def.unknownKeys === 'passthrough') {\n      result = result.passthrough();\n    }\n\n    return result;\n  }\n\n  /**\n   * Merges validation constraints into a parameter description.\n   *\n   * This helper method converts validation constraints that may not be supported\n   * by a provider into human-readable descriptions.\n   *\n   * @param description - The existing parameter description\n   * @param constraints - The validation constraints to merge\n   * @returns The updated description with constraints, or undefined if no constraints\n   */\n  public mergeParameterDescription(\n    description: string | undefined,\n    constraints:\n      | NumberConstraints\n      | StringConstraints\n      | ArrayConstraints\n      | DateConstraints\n      | { defaultValue?: unknown },\n  ): string | undefined {\n    if (Object.keys(constraints).length > 0) {\n      return (description ? description + '\\n' : '') + JSON.stringify(constraints);\n    } else {\n      return description;\n    }\n  }\n\n  /**\n   * Default handler for unsupported Zod types. Throws an error for specified unsupported types.\n   *\n   * @param value - The Zod type to check\n   * @param throwOnTypes - Array of type names to throw errors for\n   * @returns The original value if not in the throw list\n   * @throws Error if the type is in the unsupported list\n   */\n  public defaultUnsupportedZodTypeHandler<T extends z.AnyZodObject>(\n    value: z.ZodTypeAny,\n    throwOnTypes: readonly UnsupportedZodType[] = UNSUPPORTED_ZOD_TYPES,\n  ): ShapeValue<T> {\n    if (throwOnTypes.includes(value._def?.typeName as UnsupportedZodType)) {\n      throw new Error(`${this.model.modelId} does not support zod type: ${value._def?.typeName}`);\n    }\n    return value as ShapeValue<T>;\n  }\n\n  /**\n   * Default handler for Zod array types. Processes array constraints according to provider support.\n   *\n   * @param value - The Zod array to process\n   * @param handleChecks - Array constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod array\n   */\n  public defaultZodArrayHandler(\n    value: ZodArray<any, any>,\n    handleChecks: readonly ArrayCheckType[] = ALL_ARRAY_CHECKS,\n  ): ZodArray<any, any> {\n    const zodArrayDef = value._def;\n    const processedType = this.processZodType(zodArrayDef.type);\n\n    let result = z.array(processedType);\n\n    const constraints: ArrayConstraints = {};\n\n    if (zodArrayDef.minLength?.value !== undefined) {\n      if (handleChecks.includes('min')) {\n        constraints.minLength = zodArrayDef.minLength.value;\n      } else {\n        result = result.min(zodArrayDef.minLength.value);\n      }\n    }\n\n    if (zodArrayDef.maxLength?.value !== undefined) {\n      if (handleChecks.includes('max')) {\n        constraints.maxLength = zodArrayDef.maxLength.value;\n      } else {\n        result = result.max(zodArrayDef.maxLength.value);\n      }\n    }\n\n    if (zodArrayDef.exactLength?.value !== undefined) {\n      if (handleChecks.includes('length')) {\n        constraints.exactLength = zodArrayDef.exactLength.value;\n      } else {\n        result = result.length(zodArrayDef.exactLength.value);\n      }\n    }\n\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod union types. Processes all union options.\n   *\n   * @param value - The Zod union to process\n   * @returns The processed Zod union\n   * @throws Error if union has fewer than 2 options\n   */\n  public defaultZodUnionHandler(value: ZodUnion<[ZodTypeAny, ...ZodTypeAny[]]>): ZodTypeAny {\n    const processedOptions = value._def.options.map((option: ZodTypeAny) => this.processZodType(option));\n    if (processedOptions.length < 2) throw new Error('Union must have at least 2 options');\n    let result = z.union(processedOptions as [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]);\n    if (value.description) {\n      result = result.describe(value.description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod string types. Processes string validation constraints.\n   *\n   * @param value - The Zod string to process\n   * @param handleChecks - String constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod string\n   */\n  public defaultZodStringHandler(\n    value: ZodString,\n    handleChecks: readonly StringCheckType[] = ALL_STRING_CHECKS,\n  ): ZodString {\n    const constraints: StringConstraints = {};\n    const checks = value._def.checks || [];\n    type ZodStringCheck = (typeof checks)[number];\n    const newChecks: ZodStringCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        if (handleChecks.includes(check.kind as StringCheckType)) {\n          switch (check.kind) {\n            case 'regex': {\n              constraints.regex = {\n                pattern: check.regex.source,\n                flags: check.regex.flags,\n              };\n              break;\n            }\n            case 'emoji': {\n              constraints.emoji = true;\n              break;\n            }\n            case 'email': {\n              constraints.email = true;\n              break;\n            }\n            case 'url': {\n              constraints.url = true;\n              break;\n            }\n            case 'uuid': {\n              constraints.uuid = true;\n              break;\n            }\n            case 'cuid': {\n              constraints.cuid = true;\n              break;\n            }\n            case 'min': {\n              constraints.minLength = check.value;\n              break;\n            }\n            case 'max': {\n              constraints.maxLength = check.value;\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.string();\n    for (const check of newChecks) {\n      result = result._addCheck(check);\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod number types. Processes number validation constraints.\n   *\n   * @param value - The Zod number to process\n   * @param handleChecks - Number constraints to convert to descriptions vs keep as validation\n   * @returns The processed Zod number\n   */\n  public defaultZodNumberHandler(\n    value: ZodNumber,\n    handleChecks: readonly NumberCheckType[] = ALL_NUMBER_CHECKS,\n  ): ZodNumber {\n    const constraints: NumberConstraints = {};\n    const checks = value._def.checks || [];\n    type ZodNumberCheck = (typeof checks)[number];\n    const newChecks: ZodNumberCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        if (handleChecks.includes(check.kind as NumberCheckType)) {\n          switch (check.kind) {\n            case 'min':\n              if (check.inclusive) {\n                constraints.gte = check.value;\n              } else {\n                constraints.gt = check.value;\n              }\n              break;\n            case 'max':\n              if (check.inclusive) {\n                constraints.lte = check.value;\n              } else {\n                constraints.lt = check.value;\n              }\n              break;\n            case 'multipleOf': {\n              constraints.multipleOf = check.value;\n              break;\n            }\n          }\n        } else {\n          newChecks.push(check);\n        }\n      }\n    }\n    let result = z.number();\n    for (const check of newChecks) {\n      switch (check.kind) {\n        case 'int':\n          result = result.int();\n          break;\n        case 'finite':\n          result = result.finite();\n          break;\n        default:\n          result = result._addCheck(check);\n      }\n    }\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod date types. Converts dates to ISO strings with constraint descriptions.\n   *\n   * @param value - The Zod date to process\n   * @returns A Zod string schema representing the date in ISO format\n   */\n  public defaultZodDateHandler(value: ZodDate): ZodString {\n    const constraints: DateConstraints = {};\n    const checks = value._def.checks || [];\n    type ZodDateCheck = (typeof checks)[number];\n    const newChecks: ZodDateCheck[] = [];\n    for (const check of checks) {\n      if ('kind' in check) {\n        switch (check.kind) {\n          case 'min':\n            const minDate = new Date(check.value);\n            if (!isNaN(minDate.getTime())) {\n              constraints.minDate = minDate.toISOString();\n            }\n            break;\n          case 'max':\n            const maxDate = new Date(check.value);\n            if (!isNaN(maxDate.getTime())) {\n              constraints.maxDate = maxDate.toISOString();\n            }\n            break;\n          default:\n            newChecks.push(check);\n        }\n      }\n    }\n    constraints.dateFormat = 'date-time';\n    let result = z.string().describe('date-time');\n    const description = this.mergeParameterDescription(value.description, constraints);\n    if (description) {\n      result = result.describe(description);\n    }\n    return result;\n  }\n\n  /**\n   * Default handler for Zod optional types. Processes the inner type and maintains optionality.\n   *\n   * @param value - The Zod optional to process\n   * @param handleTypes - Types that should be processed vs passed through\n   * @returns The processed Zod optional\n   */\n  public defaultZodOptionalHandler(\n    value: ZodOptional<any>,\n    handleTypes: readonly AllZodType[] = SUPPORTED_ZOD_TYPES,\n  ): ZodTypeAny {\n    if (handleTypes.includes(value._def.innerType._def.typeName as AllZodType)) {\n      return this.processZodType(value._def.innerType).optional();\n    } else {\n      return value;\n    }\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to an AI SDK Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns An AI SDK Schema with provider-specific compatibility applied\n   */\n  public processToAISDKSchema(zodSchema: z.ZodSchema): Schema {\n    const processedSchema = this.processZodType(zodSchema);\n\n    return convertZodSchemaToAISDKSchema(processedSchema, this.getSchemaTarget());\n  }\n\n  /**\n   * Processes a Zod object schema and converts it to a JSON Schema.\n   *\n   * @param zodSchema - The Zod object schema to process\n   * @returns A JSONSchema7 object with provider-specific compatibility applied\n   */\n  public processToJSONSchema(zodSchema: z.ZodSchema): JSONSchema7 {\n    return this.processToAISDKSchema(zodSchema).jsonSchema;\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer, isArr, isObj, isOptional, isString, isUnion } from '../schema-compatibility';\nimport type { AllZodType } from '../schema-compatibility';\n\nexport class AnthropicSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().modelId.includes('claude');\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      const handleTypes: AllZodType[] = ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodNever', 'ZodUndefined', 'ZodTuple'];\n      if (this.getModel().modelId.includes('claude-3.5-haiku')) handleTypes.push('ZodString');\n      return this.defaultZodOptionalHandler(value, handleTypes);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      // the claude-3.5-haiku model support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n\n      if (this.getModel().modelId.includes('claude-3.5-haiku')) {\n        return this.defaultZodStringHandler(value, ['max', 'min']);\n      } else {\n        return value;\n      }\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value, ['ZodNever', 'ZodTuple', 'ZodUndefined']);\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer, isArr, isObj, isOptional, isString, isUnion } from '../schema-compatibility';\n\nexport class DeepSeekSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    // Deepseek R1 performs perfectly without this compat layer\n    return this.getModel().modelId.includes('deepseek') && !this.getModel().modelId.includes('r1');\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodString', 'ZodNumber']);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, ['min', 'max']);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n\n    return value;\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport type { ZodTypeAny } from 'zod';\nimport { z } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport {\n  SchemaCompatLayer,\n  UNSUPPORTED_ZOD_TYPES,\n  isArr,\n  isNull,\n  isNumber,\n  isObj,\n  isOptional,\n  isString,\n  isUnion,\n} from '../schema-compatibility';\n\nexport class GoogleSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().provider.includes('google') || this.getModel().modelId.includes('google');\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\n        'ZodObject',\n        'ZodArray',\n        'ZodUnion',\n        'ZodString',\n        'ZodNumber',\n        ...UNSUPPORTED_ZOD_TYPES,\n      ]);\n    } else if (isNull(value)) {\n      // Google models don't support null, so we need to convert it to any and then refine it to null\n      return z\n        .any()\n        .refine(v => v === null, { message: 'must be null' })\n        .describe(value._def.description || 'must be null');\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, []);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isString(value)) {\n      // Google models support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n      return this.defaultZodStringHandler(value);\n    } else if (isNumber(value)) {\n      // Google models support these properties but the model doesn't respect them, but it respects them when they're\n      // added to the tool description\n      return this.defaultZodNumberHandler(value);\n    }\n    return this.defaultUnsupportedZodTypeHandler(value);\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer, isArr, isNumber, isObj, isOptional, isString, isUnion } from '../schema-compatibility';\n\nexport class MetaSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return 'jsonSchema7';\n  }\n\n  shouldApply(): boolean {\n    return this.getModel().modelId.includes('meta');\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, ['ZodObject', 'ZodArray', 'ZodUnion', 'ZodString', 'ZodNumber']);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value, ['min', 'max']);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isNumber(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    }\n\n    return value;\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport { SchemaCompatLayer, isArr, isObj, isOptional, isString, isUnion } from '../schema-compatibility';\nimport type { StringCheckType } from '../schema-compatibility';\n\nexport class OpenAISchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return `jsonSchema7`;\n  }\n\n  shouldApply(): boolean {\n    if (\n      !this.getModel().supportsStructuredOutputs &&\n      (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      return this.defaultZodOptionalHandler(value, [\n        'ZodObject',\n        'ZodArray',\n        'ZodUnion',\n        'ZodString',\n        'ZodNever',\n        'ZodUndefined',\n        'ZodTuple',\n      ]);\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isString(value)) {\n      const model = this.getModel();\n      const checks: StringCheckType[] = ['emoji'];\n\n      if (model.modelId.includes('gpt-4o-mini')) {\n        checks.push('regex');\n      }\n      return this.defaultZodStringHandler(value, checks);\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value, ['ZodNever', 'ZodUndefined', 'ZodTuple']);\n  }\n}\n","import type { LanguageModelV1 } from 'ai';\nimport { z } from 'zod';\nimport type { ZodTypeAny } from 'zod';\nimport type { Targets } from 'zod-to-json-schema';\nimport {\n  SchemaCompatLayer,\n  isArr,\n  isDate,\n  isDefault,\n  isNumber,\n  isObj,\n  isOptional,\n  isString,\n  isUnion,\n} from '../schema-compatibility';\n\nexport class OpenAIReasoningSchemaCompatLayer extends SchemaCompatLayer {\n  constructor(model: LanguageModelV1) {\n    super(model);\n  }\n\n  getSchemaTarget(): Targets | undefined {\n    return `openApi3`;\n  }\n\n  isReasoningModel(): boolean {\n    // there isn't a good way to automatically detect reasoning models besides doing this.\n    // in the future when o5 is released this compat wont apply and we'll want to come back and update this class + our tests\n    return this.getModel().modelId.includes(`o3`) || this.getModel().modelId.includes(`o4`);\n  }\n\n  shouldApply(): boolean {\n    if (\n      (this.getModel().supportsStructuredOutputs || this.isReasoningModel()) &&\n      (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  processZodType(value: ZodTypeAny): ZodTypeAny {\n    if (isOptional(value)) {\n      const innerZodType = this.processZodType(value._def.innerType);\n      return innerZodType.nullable();\n    } else if (isObj(value)) {\n      return this.defaultZodObjectHandler(value, { passthrough: false });\n    } else if (isArr(value)) {\n      return this.defaultZodArrayHandler(value);\n    } else if (isUnion(value)) {\n      return this.defaultZodUnionHandler(value);\n    } else if (isDefault(value)) {\n      const defaultDef = value._def;\n      const innerType = defaultDef.innerType;\n      const defaultValue = defaultDef.defaultValue();\n      const constraints: { defaultValue?: unknown } = {};\n      if (defaultValue !== undefined) {\n        constraints.defaultValue = defaultValue;\n      }\n\n      const description = this.mergeParameterDescription(value.description, constraints);\n      let result = this.processZodType(innerType);\n      if (description) {\n        result = result.describe(description);\n      }\n      return result;\n    } else if (isNumber(value)) {\n      return this.defaultZodNumberHandler(value);\n    } else if (isString(value)) {\n      return this.defaultZodStringHandler(value);\n    } else if (isDate(value)) {\n      return this.defaultZodDateHandler(value);\n    } else if (value._def.typeName === 'ZodAny') {\n      // It's bad practice in the tool to use any, it's not reasonable for models that don't support that OOTB, to cast every single possible type\n      // in the schema. Usually when it's \"any\" it could be a json object or a union of specific types.\n      return z\n        .string()\n        .describe(\n          (value.description ?? '') +\n            `\\nArgument was an \"any\" type, but you (the LLM) do not support \"any\", so it was cast to a \"string\" type`,\n        );\n    }\n\n    return this.defaultUnsupportedZodTypeHandler(value);\n  }\n}\n"]}